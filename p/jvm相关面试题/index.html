<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="JVM相关面试题 1 JVM组成 1.1 JVM由那些部分组成，运行流程是什么？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n从图中可以看出 JVM 的主要组成部分\nClassLoader（类加载器） Runtime Data Area（运行时数据区，内存分区） Execution Engine（执行引擎） Native Method Library（本地库接口） 运行流程：\n">
<title>JVM相关面试题</title>

<link rel='canonical' href='https://example.com/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/'>

<link rel="stylesheet" href="/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css"><meta property='og:title' content="JVM相关面试题">
<meta property='og:description' content="JVM相关面试题 1 JVM组成 1.1 JVM由那些部分组成，运行流程是什么？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n从图中可以看出 JVM 的主要组成部分\nClassLoader（类加载器） Runtime Data Area（运行时数据区，内存分区） Execution Engine（执行引擎） Native Method Library（本地库接口） 运行流程：\n">
<meta property='og:url' content='https://example.com/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/'>
<meta property='og:site_name' content='GAJ-Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='JVM相关面试题' /><meta property='article:published_time' content='2024-11-09T16:02:00&#43;08:00'/><meta property='article:modified_time' content='2024-11-09T16:02:00&#43;08:00'/>
<meta name="twitter:title" content="JVM相关面试题">
<meta name="twitter:description" content="JVM相关面试题 1 JVM组成 1.1 JVM由那些部分组成，运行流程是什么？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n从图中可以看出 JVM 的主要组成部分\nClassLoader（类加载器） Runtime Data Area（运行时数据区，内存分区） Execution Engine（执行引擎） Native Method Library（本地库接口） 运行流程：\n">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu9246200855298101108.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🤔</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">GAJ-Blog</a></h1>
            <h2 class="site-description">步履不停，一往无前。</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/gajzj'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/update/' >
                
                
                
                    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-timeline-event"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 20m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" /><path d="M10 20h-6" /><path d="M14 20h6" /><path d="M12 15l-2 -2h-3a1 1 0 0 1 -1 -1v-8a1 1 0 0 1 1 -1h10a1 1 0 0 1 1 1v8a1 1 0 0 1 -1 1h-3l-2 2z" /></svg>
                
                <span>日志</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#1-jvm组成">1 JVM组成</a>
      <ol>
        <li><a href="#11-jvm由那些部分组成运行流程是什么">1.1 JVM由那些部分组成，运行流程是什么？</a></li>
        <li><a href="#12-说一下-jvm-运行时数据区">1.2 说一下 JVM 运行时数据区</a></li>
        <li><a href="#13-什么是程序计数器">1.3 什么是程序计数器？</a></li>
        <li><a href="#14-你能给我详细的介绍java堆吗">1.4 你能给我详细的介绍Java堆吗?</a>
          <ol>
            <li></li>
          </ol>
        </li>
        <li><a href="#15-能不能解释一下方法区">1.5 能不能解释一下方法区？</a></li>
        <li><a href="#16-你听过直接内存吗">1.6 你听过直接内存吗？</a></li>
        <li><a href="#17-什么是虚拟机栈">1.7 什么是虚拟机栈</a></li>
        <li><a href="#18-堆栈的区别是什么">1.8 堆栈的区别是什么？</a></li>
      </ol>
    </li>
    <li><a href="#2-类加载器">2 类加载器</a>
      <ol>
        <li><a href="#21-什么是类加载器类加载器有哪些">2.1 什么是类加载器，类加载器有哪些?</a></li>
        <li><a href="#22-说一下类装载的执行过程">2.2 说一下类装载的执行过程？</a></li>
        <li><a href="#23-什么是双亲委派模型">2.3 什么是双亲委派模型？</a></li>
        <li><a href="#24-jvm为什么采用双亲委派机制">2.4 JVM为什么采用双亲委派机制</a></li>
      </ol>
    </li>
    <li><a href="#3-垃圾收回">3 垃圾收回</a>
      <ol>
        <li><a href="#31-简述java垃圾回收机制gc是什么为什么要gc">3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）</a></li>
        <li><a href="#32-强引用软引用弱引用虚引用的区别">3.2 强引用、软引用、弱引用、虚引用的区别？</a>
          <ol>
            <li><a href="#321-强引用">3.2.1 强引用</a></li>
            <li><a href="#322-软引用">3.2.2 软引用</a></li>
            <li><a href="#323-弱引用">3.2.3 弱引用</a></li>
            <li><a href="#324-虚引用">3.2.4 虚引用</a></li>
          </ol>
        </li>
        <li><a href="#33-对象什么时候可以被垃圾器回收">3.3 对象什么时候可以被垃圾器回收</a>
          <ol>
            <li><a href="#331-引用计数法">3.3.1 引用计数法</a></li>
            <li><a href="#331-可达性分析算法">3.3.1 可达性分析算法</a></li>
          </ol>
        </li>
        <li><a href="#34-jvm-垃圾回收算法有哪些">3.4 JVM 垃圾回收算法有哪些？</a>
          <ol>
            <li><a href="#341-标记清除算法">3.4.1 标记清除算法</a></li>
            <li><a href="#342-复制算法">3.4.2 复制算法</a></li>
            <li><a href="#343-标记整理算法">3.4.3 标记整理算法</a></li>
            <li><a href="#344-分代收集算法">3.4.4 分代收集算法</a></li>
          </ol>
        </li>
        <li><a href="#35-讲一下新生代老年代永久代的区别">3.5 讲一下新生代、老年代、永久代的区别？</a></li>
        <li><a href="#36-说一下-jvm-有哪些垃圾回收器">3.6 说一下 JVM 有哪些垃圾回收器？</a>
          <ol>
            <li><a href="#361-serial收集器">3.6.1 Serial收集器</a></li>
            <li><a href="#362-parallelnew收集器">3.6.2 ParallelNew收集器</a></li>
            <li><a href="#363-parallel-scavenge收集器">3.6.3 Parallel Scavenge收集器</a></li>
            <li><a href="#364-serial-old收集器">3.6.4 Serial Old收集器</a></li>
            <li><a href="#365-parallel-old收集器">3.6.5 Parallel Old收集器</a></li>
            <li><a href="#366-cms垃圾收集器">3.6.6 CMS垃圾收集器</a></li>
            <li><a href="#367-g1垃圾收集器">3.6.7 G1垃圾收集器</a></li>
          </ol>
        </li>
        <li><a href="#37-minor-gcmajor-gcfull-gc是什么">3.7 Minor GC、Major GC、Full GC是什么</a></li>
      </ol>
    </li>
    <li><a href="#4-jvm实践调优">4 JVM实践（调优）</a>
      <ol>
        <li><a href="#41-jvm-调优的参数可以在哪里设置参数值">4.1 JVM 调优的参数可以在哪里设置参数值？</a>
          <ol>
            <li><a href="#411-tomcat的设置vm参数">4.1.1 tomcat的设置vm参数</a></li>
            <li><a href="#412-springboot项目jar文件启动">4.1.2 springboot项目jar文件启动</a></li>
          </ol>
        </li>
        <li><a href="#42-用的-jvm-调优的参数都有哪些">4.2 用的 JVM 调优的参数都有哪些？</a></li>
        <li><a href="#43-说一下-jvm-调优的工具">4.3 说一下 JVM 调优的工具？</a>
          <ol>
            <li><a href="#431-命令工具">4.3.1 命令工具</a></li>
            <li><a href="#432-可视化工具">4.3.2 可视化工具</a></li>
          </ol>
        </li>
        <li><a href="#44-java内存泄露的排查思路">4.4 java内存泄露的排查思路？</a></li>
        <li><a href="#45-cpu飙高排查方案与思路">4.5 CPU飙高排查方案与思路？</a></li>
      </ol>
    </li>
    <li><a href="#5面试现场">5.面试现场</a>
      <ol>
        <li><a href="#51-jvm组成">5.1 JVM组成</a></li>
        <li><a href="#52-类加载器">5.2 类加载器</a></li>
        <li><a href="#53-垃圾回收">5.3 垃圾回收</a></li>
        <li><a href="#54-jvm实践调优">5.4 JVM实践（调优）</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" >
                JVM相关面试题
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">JVM相关面试题</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">11-09,  2024</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="jvm相关面试题">JVM相关面试题
</h1><h2 id="1-jvm组成">1 JVM组成
</h2><h3 id="11-jvm由那些部分组成运行流程是什么">1.1 JVM由那些部分组成，运行流程是什么？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903233627146.png"
	width="1113"
	height="522"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903233627146_hu471400069268057499.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903233627146_hu8490872863058708578.png 1024w"
	loading="lazy"
	
		alt="image-20220903233627146"
	
	
		class="gallery-image" 
		data-flex-grow="213"
		data-flex-basis="511px"
	
></p>
<p>从图中可以看出 JVM 的主要组成部分</p>
<ul>
<li>ClassLoader（类加载器）</li>
<li>Runtime Data Area（运行时数据区，内存分区）</li>
<li>Execution Engine（执行引擎）</li>
<li>Native Method Library（本地库接口）</li>
</ul>
<p>运行流程：</p>
<p>（1）类加载器（ClassLoader）把Java代码转换为字节码</p>
<p>（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p>
<p>（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p>
<h3 id="12-说一下-jvm-运行时数据区">1.2 说一下 JVM 运行时数据区
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>组成部分：堆、方法区、栈、本地方法栈、程序计数器</p>
<p>1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。
2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。
3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。
4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。
5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p>
<h3 id="13-什么是程序计数器">1.3 什么是程序计数器？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>线程私有的。内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。</p>
<blockquote>
<p>javap -verbose  xx.class    打印堆栈大小，局部变量的数量和方法的参数。</p>
</blockquote>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220826235336379.png"
	width="1308"
	height="678"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220826235336379_hu18145343218829279438.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220826235336379_hu8108815346314262955.png 1024w"
	loading="lazy"
	
		alt="image-20220826235336379"
	
	
		class="gallery-image" 
		data-flex-grow="192"
		data-flex-basis="463px"
	
></p>
<p>​	java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。</p>
<p>​	那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。</p>
<p>​	程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。</p>
<h3 id="14-你能给我详细的介绍java堆吗">1.4 你能给我详细的介绍Java堆吗?
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p><strong>线程共享的区域</strong>。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903222719878.png"
	width="1349"
	height="478"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903222719878_hu189897339195508553.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903222719878_hu6430123009936787906.png 1024w"
	loading="lazy"
	
		alt="image-20220903222719878"
	
	
		class="gallery-image" 
		data-flex-grow="282"
		data-flex-basis="677px"
	
></p>
<p>​	在JAVA7中堆内会存在<strong>年轻代、老年代和方法区(永久代)</strong>。</p>
<p>​	1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p>
<p>​	2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</p>
<p>​	3）Perm代主要保存<strong>保存的类信息、静态变量、常量、编译后的代码</strong>，在java7中堆上方法区会受到GC的管理的。方法区【永久代】是有一个大小的限制的。如果大量的动态生成类，就会放入到方法区【永久代】，很容易造成OOM。</p>
<p>​	为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做<strong>元空间</strong>。那么现在就可以避免掉OOM的出现了。</p>
<blockquote>
<p>扩展：</p>
<h5 id="元空间metaspace介绍">元空间(MetaSpace)介绍
</h5><p>​	在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p>​	永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。</p>
<p>​	那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？</p>
<p>官网给出了解释：http://openjdk.java.net/jeps/122</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。
</span></span></code></pre></td></tr></table>
</div>
</div><p>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</p>
<p>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p>
<p>​	准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java/lang/Object 类元信息、静态属性 System.out、整型常量等。</p>
<p>​	元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</blockquote>
<h3 id="15-能不能解释一下方法区">1.5 能不能解释一下方法区？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>方法区类似于传统语言的编译代码的存储区，它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化和接口初始化中使用 的特殊方法</p>
<p>方法区是在虚拟机启动时创建的。尽管方法区在逻辑上是堆的一部分，但简单的实现可能会选择不进行垃圾收集或压缩它。本规范不要求方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小，也可以根据计算需要扩大，如果不需要更大的方法区域，可以缩小。方法区的内存不需要是连续的。</p>
<p>Java 虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，以及在方法区域大小可变的情况下，对最大和最小方法区域大小的控制。</p>
<p>以下异常情况与方法区相关：</p>
<ul>
<li>如果方法区域中的内存无法满足分配请求，Java 虚拟机将抛出一个<code>OutOfMemoryError</code>.</li>
</ul>
<h3 id="16-你听过直接内存吗">1.6 你听过直接内存吗？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理</p>
<p>举例：</p>
<p>需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘</p>
<p>代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 演示 ByteBuffer 作用
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Demo1_9</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;E:\\编程资料\\第三方教学视频\\youtube\\Getting Started with Spring Boot-sbPSjI4tt10.mp4&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">TO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;E:\\a.mp4&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_1Mb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">1024</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">io</span><span class="p">();</span><span class="w"> </span><span class="c1">// io 用时：1535.586957 1766.963399 1359.240226</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">directBuffer</span><span class="p">();</span><span class="w"> </span><span class="c1">// directBuffer 用时：479.295165 702.291454 562.56592</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">directBuffer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">nanoTime</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">(</span><span class="n">FileChannel</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileInputStream</span><span class="p">(</span><span class="n">FROM</span><span class="p">).</span><span class="na">getChannel</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="n">FileChannel</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileOutputStream</span><span class="p">(</span><span class="n">TO</span><span class="p">).</span><span class="na">getChannel</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ByteBuffer</span><span class="w"> </span><span class="n">bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ByteBuffer</span><span class="p">.</span><span class="na">allocateDirect</span><span class="p">(</span><span class="n">_1Mb</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="na">read</span><span class="p">(</span><span class="n">bb</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">bb</span><span class="p">.</span><span class="na">flip</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">to</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">bb</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">bb</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IOException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">nanoTime</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;directBuffer 用时：&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">1000_000</span><span class="p">.</span><span class="na">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">io</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">nanoTime</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">(</span><span class="n">FileInputStream</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileInputStream</span><span class="p">(</span><span class="n">FROM</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="n">FileOutputStream</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileOutputStream</span><span class="p">(</span><span class="n">TO</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">byte</span><span class="o">[]</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">byte</span><span class="o">[</span><span class="n">_1Mb</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">from</span><span class="p">.</span><span class="na">read</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">to</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IOException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">nanoTime</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;io 用时：&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">1000_000</span><span class="p">.</span><span class="na">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。</p>
<p>这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220907174151925.png"
	width="825"
	height="594"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220907174151925_hu4000586279237720933.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220907174151925_hu12322853207929336964.png 1024w"
	loading="lazy"
	
		alt="image-20220907174151925"
	
	
		class="gallery-image" 
		data-flex-grow="138"
		data-flex-basis="333px"
	
></p>
<p>下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220907174308262.png"
	width="809"
	height="591"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220907174308262_hu11023090600962366037.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220907174308262_hu17316853833250233280.png 1024w"
	loading="lazy"
	
		alt="image-20220907174308262"
	
	
		class="gallery-image" 
		data-flex-grow="136"
		data-flex-basis="328px"
	
></p>
<h3 id="17-什么是虚拟机栈">1.7 什么是虚拟机栈
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>​	描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p>
<h3 id="18-堆栈的区别是什么">1.8 堆栈的区别是什么？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p>
<p>2、栈内存是线程私有的，而堆内存是线程共有的。</p>
<p>3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p>
<p>栈空间不足：java.lang.StackOverFlowError。</p>
<p>堆空间不足：java.lang.OutOfMemoryError。</p>
<h2 id="2-类加载器">2 类加载器
</h2><h3 id="21-什么是类加载器类加载器有哪些">2.1 什么是类加载器，类加载器有哪些?
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903233627146.png"
	width="1113"
	height="522"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903233627146_hu471400069268057499.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903233627146_hu8490872863058708578.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="213"
		data-flex-basis="511px"
	
></p>
<ul>
<li>类加载器：用于装载字节码文件(.class文件)</li>
<li>运行时数据区：用于分配存储空间</li>
<li>执行引擎：执行字节码文件或本地方法</li>
<li>垃圾回收器：用于对JVM中的垃圾内容进行回收</li>
</ul>
<p><strong>类加载器</strong></p>
<p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源</p>
<p><strong>类加载器种类</strong></p>
<p>类加载器根据各自加载范围的不同，划分为四种类加载器：</p>
<ul>
<li>
<p><strong>启动类加载器(BootStrap ClassLoader)：</strong></p>
<p>该类并不继承ClassLoader类，其是由C++编写实现。用于加载<strong>JAVA_HOME/jre/lib</strong>目录下的类库。</p>
</li>
<li>
<p><strong>扩展类加载器(ExtClassLoader)：</strong></p>
<p>该类是ClassLoader的子类，主要加载<strong>JAVA_HOME/jre/lib/ext</strong>目录中的类库。</p>
</li>
<li>
<p><strong>应用类加载器(AppClassLoader)：</strong></p>
<p>该类是ClassLoader的子类，主要用于加载<strong>classPath</strong>下的类，也就是加载开发者自己编写的Java类。</p>
</li>
<li>
<p><strong>自定义类加载器：</strong></p>
<p>开发者自定义类继承ClassLoader，实现自定义类加载规则。</p>
</li>
</ul>
<p>上述三种类加载器的层次结构如下如下：</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904003215993.png"
	width="458"
	height="762"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904003215993_hu17553560900465832100.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904003215993_hu9261540229248691043.png 1024w"
	loading="lazy"
	
		alt="image-20220904003215993"
	
	
		class="gallery-image" 
		data-flex-grow="60"
		data-flex-basis="144px"
	
></p>
<p>类加载器的体系并不是“继承”体系，而是<strong>委派体系</strong>，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。</p>
<h3 id="22-说一下类装载的执行过程">2.2 说一下类装载的执行过程？
</h3><blockquote>
<p>难易程度：☆☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904003730785.png"
	width="955"
	height="390"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904003730785_hu14922210423059460295.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904003730785_hu14385389697415372549.png 1024w"
	loading="lazy"
	
		alt="image-20220904003730785"
	
	
		class="gallery-image" 
		data-flex-grow="244"
		data-flex-basis="587px"
	
></p>
<p><strong>类加载过程详解</strong></p>
<p>1.加载</p>
<p>查找和导入class文件</p>
<p>(1)获取类的二进制字节流 ,将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
(2)在Java堆中生成一个Class对象，作为方法区中这些数据的访问入口</p>
<p>2.验证</p>
<p>保证加载类的准确性</p>
<p>(1)文件格式验证:是否符合Class文件的规范
(2)元数据验证
这个类是否有父类（除了Object这个类之外，其余的类都应该有父类）
这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承）
类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）					
(3)字节码验证
主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。
(4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p>
<blockquote>
<p>比如：int i = 3;
字面量：3
符号引用：i</p>
</blockquote>
<p>3.准备</p>
<p>为类变量分配内存并设置类变量初始值</p>
<p>Java 中的变量有&quot;类变量&quot;和&quot;类成员变量&quot;两种类型
类变量:指的是被 静态（static） 修饰的变量
类成员变量:指的是非静态修饰的变量
在准备阶段，JVM 只会为&quot;类变量&quot;分配内存，而不会为&quot;类成员变量&quot;分配内存
&ldquo;类成员变量&rdquo;：内存分配需要等到 类加载的初始化 阶段才开始。</p>
<p>4.解析</p>
<p>把类中的符号引用转换为直接引用</p>
<p>比如方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p>
<p>5.初始化</p>
<p>对类的静态变量，静态代码块执行初始化操作</p>
<p>只对静态（static）修饰的变量或语句块进行初始化。如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<p>6.使用</p>
<p>JVM 开始从入口方法开始执行用户的程序代码</p>
<p>7.卸载</p>
<p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p>
<h3 id="23-什么是双亲委派模型">2.3 什么是双亲委派模型？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904004306359.png"
	width="947"
	height="711"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904004306359_hu8375340113160557691.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904004306359_hu11373771628220181631.png 1024w"
	loading="lazy"
	
		alt="image-20220904004306359"
	
	
		class="gallery-image" 
		data-flex-grow="133"
		data-flex-basis="319px"
	
></p>
<h3 id="24-jvm为什么采用双亲委派机制">2.4 JVM为什么采用双亲委派机制
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p>
<p>（2）为了安全，保证类库API不会被修改</p>
<p>在工程中新建java.lang包，接着在该包下新建String类，并定义main函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;demo info&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>​	此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903144547378.png"
	width="934"
	height="144"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903144547378_hu258715849314340661.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903144547378_hu13253271977043666323.png 1024w"
	loading="lazy"
	
		alt="image-20220903144547378"
	
	
		class="gallery-image" 
		data-flex-grow="648"
		data-flex-basis="1556px"
	
></p>
<p>​	出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。</p>
<h2 id="3-垃圾收回">3 垃圾收回
</h2><h3 id="31-简述java垃圾回收机制gc是什么为什么要gc">3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC）
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p>
<p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p>
<p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p>
<p>换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。</p>
<p>当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。</p>
<h3 id="32-强引用软引用弱引用虚引用的区别">3.2 强引用、软引用、弱引用、虚引用的区别？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="321-强引用">3.2.1 强引用
</h4><p>最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">User</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">User</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="322-软引用">3.2.2 软引用
</h4><p>表示一个对象处于<strong>有用且非必须</strong>状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">User</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">User</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">SoftReference</span><span class="w"> </span><span class="n">softReference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SoftReference</span><span class="p">(</span><span class="n">user</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="323-弱引用">3.2.3 弱引用
</h4><p>表示一个对象处于<strong>可能有用且非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">User</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">User</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">WeakReference</span><span class="w"> </span><span class="n">weakReference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">WeakReference</span><span class="p">(</span><span class="n">user</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>延伸话题：ThreadLocal内存泄漏问题</p>
</blockquote>
<p>ThreadLocal用的就是弱引用，看以下源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Entry</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">ThreadLocal</span><span class="o">&lt;?&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Entry</span><span class="p">(</span><span class="n">ThreadLocal</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="kd">super</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="c1">//强引用，不会被回收</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>Entry</code>的key是当前ThreadLocal，value值是我们要设置的数据。</p>
<p><code>WeakReference</code>表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是<code>value</code>是强引用，它不会被回收掉。</p>
<blockquote>
<p>ThreadLocal使用建议：使用完毕后注意调用清理方法。</p>
</blockquote>
<h4 id="324-虚引用">3.2.4 虚引用
</h4><ol>
<li>
<p>例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);</p>
</li>
<li>
<p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">com.itheima.basic</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.lang.ref.PhantomReference</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.lang.ref.ReferenceQueue</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.ArrayList</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.List</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestPhantomReference</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">queue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReferenceQueue</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">MyResourse</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MyResourse</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">),</span><span class="n">queue</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MyResourse</span><span class="p">(</span><span class="s">&#34;b&#34;</span><span class="p">,</span><span class="n">queue</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MyResourse</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">),</span><span class="n">queue</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">gc</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Object</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="n">queue</span><span class="p">.</span><span class="na">poll</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">ref</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">MyResourse</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">MyResourse</span><span class="p">.</span><span class="na">clean</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyResourse</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyResourse</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">referent</span><span class="p">,</span><span class="w"> </span><span class="n">ReferenceQueue</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">super</span><span class="w">  </span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">super</span><span class="p">(</span><span class="n">referent</span><span class="p">,</span><span class="n">q</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//释放外部资源的方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">clean</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;clean&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="33-对象什么时候可以被垃圾器回收">3.3 对象什么时候可以被垃圾器回收
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p>
<h4 id="331-引用计数法">3.3.1 引用计数法
</h4><p>​	一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="w"> </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904005802025.png"
	width="563"
	height="360"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904005802025_hu4695453624529905715.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904005802025_hu4643775362911274175.png 1024w"
	loading="lazy"
	
		alt="image-20220904005802025"
	
	
		class="gallery-image" 
		data-flex-grow="156"
		data-flex-basis="375px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="w"> </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010012624.png"
	width="559"
	height="359"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010012624_hu17004253884902951973.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010012624_hu12259658304254035683.png 1024w"
	loading="lazy"
	
		alt="image-20220904010012624"
	
	
		class="gallery-image" 
		data-flex-grow="155"
		data-flex-basis="373px"
	
></p>
<p>当对象间出现了循环引用的话，则引用计数法就会失效</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010201496.png"
	width="544"
	height="399"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010201496_hu12215200484790110668.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010201496_hu8094484597998279836.png 1024w"
	loading="lazy"
	
		alt="image-20220904010201496"
	
	
		class="gallery-image" 
		data-flex-grow="136"
		data-flex-basis="327px"
	
></p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903144622508.png"
	width="1038"
	height="307"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903144622508_hu15860450294891348260.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220903144622508_hu5921241159633819054.png 1024w"
	loading="lazy"
	
		alt="image-20220903144622508"
	
	
		class="gallery-image" 
		data-flex-grow="338"
		data-flex-basis="811px"
	
></p>
<p>虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。</p>
<p>优点：</p>
<ul>
<li>实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。</li>
<li>在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。</li>
<li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。</li>
</ul>
<p>缺点：</p>
<ul>
<li>每次对象被引用时，都需要去更新计数器，有一点时间开销。</li>
<li><strong>浪费CPU资源</strong>，即使内存够用，仍然在运行时进行计数器的统计。</li>
<li><strong>无法解决循环引用问题，会引发内存泄露</strong>。（最大的缺点）</li>
</ul>
<h4 id="331-可达性分析算法">3.3.1 可达性分析算法
</h4><p>​	现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。</p>
<p>​	会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。</p>
<blockquote>
<p>根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象</p>
<p>局部变量，静态方法，静态变量，类信息</p>
<p>核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收</p>
</blockquote>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010634153.png"
	width="436"
	height="593"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010634153_hu3764381488458764579.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904010634153_hu17478693232302430119.png 1024w"
	loading="lazy"
	
		alt="image-20220904010634153"
	
	
		class="gallery-image" 
		data-flex-grow="73"
		data-flex-basis="176px"
	
></p>
<p>​	X,Y这两个节点是可回收的，但是<strong>并不会马上的被回收！！</strong> 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先<strong>会判断这个对象是否执行了finalize方法</strong>，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。</p>
<p>​	finalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。</p>
<p><strong>GC ROOTS：</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Demo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    	</span><span class="n">Demo</span><span class="w"> </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    	</span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>方法区中类静态属性引用的对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 当栈帧中的本地变量 b = null 时，由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接，所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用，a在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活!
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Demo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Demo</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Demo</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="na">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>方法区中常量引用的对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Demo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Demo</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Demo</span><span class="w"> </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Demo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">demo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
</ul>
<h3 id="34-jvm-垃圾回收算法有哪些">3.4 JVM 垃圾回收算法有哪些？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="341-标记清除算法">3.4.1 标记清除算法
</h4><p>标记清除算法，是将垃圾回收分为2个阶段，分别是<strong>标记和清除</strong>。</p>
<p>1.根据可达性分析算法得出的垃圾进行标记</p>
<p>2.对这些标记为可回收的内容进行垃圾回收</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123228945.png"
	width="829"
	height="318"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123228945_hu12045542225829190304.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123228945_hu16564462800967935327.png 1024w"
	loading="lazy"
	
		alt="image-20200802123228945"
	
	
		class="gallery-image" 
		data-flex-grow="260"
		data-flex-basis="625px"
	
></p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123241536.png"
	width="813"
	height="326"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123241536_hu12368913952809115282.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123241536_hu5101128133235320117.png 1024w"
	loading="lazy"
	
		alt="image-20200802123241536"
	
	
		class="gallery-image" 
		data-flex-grow="249"
		data-flex-basis="598px"
	
></p>
<p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p>
<p>同样，标记清除算法也是有缺点的：</p>
<ul>
<li>效率较低，<strong>标记和清除两个动作都需要遍历所有的对象</strong>，并且在GC时，<strong>需要停止应用程序</strong>，对于交互性要求比较高的应用而言这个体验是非常差的。</li>
<li>（<strong>重要</strong>）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li>
</ul>
<h4 id="342-复制算法">3.4.2 复制算法
</h4><p>​	复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p>
<p>​	如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123304797.png"
	width="831"
	height="370"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123304797_hu3526249304905870937.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123304797_hu9209231639457811669.png 1024w"
	loading="lazy"
	
		alt="image-20200802123304797"
	
	
		class="gallery-image" 
		data-flex-grow="224"
		data-flex-basis="539px"
	
></p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123315514.png"
	width="810"
	height="241"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123315514_hu5836517905791757966.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802123315514_hu16953442273952169073.png 1024w"
	loading="lazy"
	
		alt="image-20200802123315514"
	
	
		class="gallery-image" 
		data-flex-grow="336"
		data-flex-basis="806px"
	
></p>
<p>1）将内存区域分成两部分，每次操作其中一个。</p>
<p>2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。</p>
<p>3）周而复始。</p>
<p>优点：</p>
<ul>
<li>在垃圾对象多的情况下，效率较高</li>
<li>清理后，内存无碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低</li>
</ul>
<h4 id="343-标记整理算法">3.4.3 标记整理算法
</h4><p>​	标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802124108240.png"
	width="815"
	height="379"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802124108240_hu4174324305278878600.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802124108240_hu17730246484435996795.png 1024w"
	loading="lazy"
	
		alt="image-20200802124108240"
	
	
		class="gallery-image" 
		data-flex-grow="215"
		data-flex-basis="516px"
	
></p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802124119931.png"
	width="810"
	height="411"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802124119931_hu11676845123714050458.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802124119931_hu1685819547622355597.png 1024w"
	loading="lazy"
	
		alt="image-20200802124119931"
	
	
		class="gallery-image" 
		data-flex-grow="197"
		data-flex-basis="472px"
	
></p>
<p>1）标记垃圾。</p>
<p>2）需要清除向右边走，不需要清除的向左边走。</p>
<p>3）清除边界以外的垃圾。</p>
<p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。</p>
<p>与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理</p>
<h4 id="344-分代收集算法">3.4.4 分代收集算法
</h4><p>在java8时，堆被分为了两份：<strong>新生代和老年代【1：2】</strong>，在java7时，还存在一个永久代。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200825231704058.png"
	width="738"
	height="316"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200825231704058_hu18074622252264459125.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200825231704058_hu13005918833785138037.png 1024w"
	loading="lazy"
	
		alt="image-20200825231704058"
	
	
		class="gallery-image" 
		data-flex-grow="233"
		data-flex-basis="560px"
	
></p>
<p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】</p>
<p>当对新生代产生GC：MinorGC【young GC】</p>
<p>当对老年代代产生GC：Major GC</p>
<p>当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
<h5 id="3441-工作机制">3.4.4.1 工作机制
</h5><p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p>
<p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p>
<p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p>
<p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p>
<h5 id="3442-对象何时晋升到老年代">3.4.4.2 对象何时晋升到老年代
</h5><p>1）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>  ），那么这个对象就会进入到老年代中。</p>
<p>2）大对象。</p>
<p>3）如果在Survivor区中相同年龄的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p>
<p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。</p>
<h3 id="35-讲一下新生代老年代永久代的区别">3.5 讲一下新生代、老年代、永久代的区别？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<p><strong>新生代</strong>主要用来存放新生的对象。一般占据堆空间的1/3。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行MinorGC，进行垃圾回收。新生代又细分为三个区：Eden区、SurvivorFrom、ServivorTo区，三个区的默认比例为：8：1：1</p>
<p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行MajorGC。而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间</p>
<p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。Classic在被加载的时候被放入永久区域，它和存放的实例的区域不同，在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，都是对JVM中规范中方法的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<h3 id="36-说一下-jvm-有哪些垃圾回收器">3.6 说一下 JVM 有哪些垃圾回收器？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器</p>
<h4 id="361-serial收集器">3.6.1 Serial收集器
</h4><p>​	<strong>串行垃圾收集器</strong>，作用于<strong>新生代</strong>。是指使用单线程进行垃圾回收，<strong>采用复制算法</strong>。垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。<strong>其应用在年轻代</strong></p>
<p>​	对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。因此一般在Javaweb应用中是不会采用该收集器的。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802214415076.png"
	width="718"
	height="525"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802214415076_hu5817478131401585325.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802214415076_hu6892518155445528777.png 1024w"
	loading="lazy"
	
		alt="image-20200802214415076"
	
	
		class="gallery-image" 
		data-flex-grow="136"
		data-flex-basis="328px"
	
></p>
<h4 id="362-parallelnew收集器">3.6.2 ParallelNew收集器
</h4><p>​	<strong>并行垃圾收集器</strong>在串行垃圾收集器的基础之上做了改进，<strong>采用复制算法</strong>。将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）。但是对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同Serial收集器一样。其也是应用在年轻代。<strong>JDK8默认使用此垃圾回收器</strong></p>
<p>​	当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802215543670.png"
	width="785"
	height="527"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802215543670_hu1064824265238432624.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802215543670_hu4570722109745406036.png 1024w"
	loading="lazy"
	
		alt="image-20200802215543670"
	
	
		class="gallery-image" 
		data-flex-grow="148"
		data-flex-basis="357px"
	
></p>
<h4 id="363-parallel-scavenge收集器">3.6.3 Parallel Scavenge收集器
</h4><p>​	其是一个应用于<strong>新生代</strong>的<strong>并行</strong>垃圾回收器，<strong>采用复制算法</strong>。它的目标是达到一个可控的吞吐量（吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间））即虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，吞吐量就是99%。这样可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p>
<ul>
<li>停顿时间越短对于需要与用户交互的程序来说越好，良好的响应速度能提升用户的体验。</li>
<li>高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不太需要太多交互的任务。</li>
</ul>
<h4 id="364-serial-old收集器">3.6.4 Serial Old收集器
</h4><p>​	其是运行于<strong>老年代的单线程</strong>Serial收集器，<strong>采用标记-整理算法</strong>，主要是给Client模式下的虚拟机使用。</p>
<h4 id="365-parallel-old收集器">3.6.5 Parallel Old收集器
</h4><p>​	其是一个应用于老年代的并行垃圾回收器，<strong>采用标记-整理算法</strong>。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器。</p>
<h4 id="366-cms垃圾收集器">3.6.6 CMS垃圾收集器
</h4><p>​	CMS全称 Concurrent Mark Sweep，是一款<strong>并发</strong>的、使用<strong>标记-清除</strong>算法的垃圾回收器，该回收器是<strong>针对老年代垃圾回收的</strong>，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。<strong>其最大特点是在进行垃圾回收时，应用仍然能正常运行。</strong></p>
<p>CMS垃圾回收器的执行过程如下：</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802222734870.png"
	width="592"
	height="367"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802222734870_hu419312911035212086.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20200802222734870_hu6431868400868235550.png 1024w"
	loading="lazy"
	
		alt="image-20200802222734870"
	
	
		class="gallery-image" 
		data-flex-grow="161"
		data-flex-basis="387px"
	
></p>
<p><strong>1)初始标记(Initial Mark)</strong>：仅仅标记GC Roots能直接关联到的对象，速度快，但是需要“Stop The World”</p>
<p><strong>2)并发标记(Concurrent Mark)</strong>：就是进行追踪引用链的过程，可以和用户线程并发执行。</p>
<p><strong>3)重新标记(Remark)</strong>：修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要“Stop The World”</p>
<p><strong>4)并发清除(Concurrent Sweep)</strong>：清除标记为可以回收对象，可以和用户线程并发执行</p>
<p>​	由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS收集器的内存回收过程和用户线程是并发执行的。</p>
<h4 id="367-g1垃圾收集器">3.6.7 G1垃圾收集器
</h4><h5 id="3671-概述">3.6.7.1 概述
</h5><p>​	对于垃圾回收器来说，前面的三种要么一次性回收年轻代，要么一次性回收老年代。而且现代服务器的堆空间已经可以很大了。为了更加优化GC操作，所以出现了G1。</p>
<p>​	它是一款**同时应用于新生代和老年代、采用标记-整理算法、软实时、低延迟、可设定目标(最大STW停顿时间)**的垃圾回收器，用于代替CMS，适用于较大的堆(&gt;4~6G)，<strong>在JDK9之后默认使用G1</strong>。</p>
<h5 id="3672-g1的内存布局">3.6.7.2 G1的内存布局
</h5><p>​	G1垃圾收集器相对比其他收集器而言，最大的区别在于它<strong>取消了年轻代、老年代的物理划分</strong>。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20161222153407_691.png"
	width="510"
	height="314"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20161222153407_691_hu11055803484760886240.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20161222153407_691_hu5551950474864354552.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="162"
		data-flex-basis="389px"
	
></p>
<p>​	取而代之的是将堆划分为<strong>若干个区域（Region）</strong>，这些区域中包含了有<strong>逻辑上的年轻代、老年代区域</strong>。这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p>
<p>​	此时可以看到，现在出现了一个<strong>新的区域Humongous</strong>，它本身属于老年代区。当现在出现了一个巨大的对象，超出了分区容量的一半，则这个对象会进入到该区域。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区 ，有时候不得不启动Full GC。</p>
<p>​	同时G1会估计每个Region中的垃圾比例，优先回收垃圾较多的区域。</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20161222153407_471.png"
	width="681"
	height="280"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20161222153407_471_hu2627771045477135861.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/20161222153407_471_hu14889648910458465310.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="243"
		data-flex-basis="583px"
	
></p>
<p>​	在G1划分的区域中，年轻代的垃圾收集依然采用<strong>暂停所有应用线程的方式</strong>，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将<strong>对象从一个区域复制到另外一个区域，完成了清理工作</strong>。</p>
<p>​	这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p>
<h5 id="3673-垃圾回收模式">3.6.7.3 垃圾回收模式
</h5><p>其提供了三种模式垃圾回收模式： <strong>young GC、Mixed GC、Full GC</strong>。在不同的条件下被触发。</p>
<p><strong>Young GC</strong></p>
<p>​	发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>
<p><strong>Mixed GC</strong></p>
<p>​	当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即<strong>mixed gc</strong>，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p>
<p>​	在CMS中，当老年代的使用率达到80%就会触发一次cms gc。在G1中，mixed gc也可以通过<code>-XX:InitiatingHeapOccupancyPercent</code>设置阈值，<strong>默认为45%</strong>。当老年代大小占整个堆大小百分比达到该阈值，则触发mixed gc。</p>
<p>其执行过程和cms类似：</p>
<ol>
<li>initial mark: 初始标记过程，整个过程STW，标记了从GC Root可达的对象。</li>
<li>concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息。</li>
<li>remark: 最终标记过程，整个过程STW，标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对象。</li>
<li>clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中。</li>
</ol>
<h5 id="full-gc"><strong>Full GC</strong>
</h5><p>​	如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</p>
<h3 id="37-minor-gcmajor-gcfull-gc是什么">3.7 Minor GC、Major GC、Full GC是什么
</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆</p>
</blockquote>
<ul>
<li>
<p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
</li>
<li>
<p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p>
</li>
<li>
<p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</li>
</ul>
<h2 id="4-jvm实践调优">4 JVM实践（调优）
</h2><h3 id="41-jvm-调优的参数可以在哪里设置参数值">4.1 JVM 调优的参数可以在哪里设置参数值？
</h3><blockquote>
<p>难易程度：☆☆</p>
<p>出现频率：☆☆☆</p>
</blockquote>
<h4 id="411-tomcat的设置vm参数">4.1.1 tomcat的设置vm参数
</h4><p>修改TOMCAT_HOME/bin/catalina.sh文件，如下图</p>
<p><code>JAVA_OPTS=&quot;-Xms512m -Xmx1024m&quot; </code></p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904151948778.png"
	width="1667"
	height="555"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904151948778_hu17235353610560091925.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904151948778_hu11778561851956804891.png 1024w"
	loading="lazy"
	
		alt="image-20220904151948778"
	
	
		class="gallery-image" 
		data-flex-grow="300"
		data-flex-basis="720px"
	
></p>
<h4 id="412-springboot项目jar文件启动">4.1.2 springboot项目jar文件启动
</h4><p>通常在linux系统下直接加参数启动springboot项目</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active<span class="o">=</span>prod <span class="p">&amp;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>nohup  :  用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p>
<p>参数 <strong>&amp;</strong>  ：让命令在后台执行，终端退出后命令仍旧执行。</p>
</blockquote>
<h3 id="42-用的-jvm-调优的参数都有哪些">4.2 用的 JVM 调优的参数都有哪些？
</h3><blockquote>
<p>难易程度：☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>​	对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。</p>
<p><a class="link" href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html"  target="_blank" rel="noopener"
    >https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</a></p>
<p>1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-Xms：设置堆的初始化大小
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-Xmx：设置堆的最大大小
</span></span></code></pre></td></tr></table>
</div>
</div><p>2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p>
<p>的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3
</span></span></code></pre></td></tr></table>
</div>
</div><p>3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:newSize   设置年轻代的初始大小
</span></span><span class="line"><span class="cl">-XX:MaxNewSize   设置年轻代的最大大小，  初始大小和最大大小两个值通常相同
</span></span></code></pre></td></tr></table>
</div>
</div><p>4）线程堆栈的设置：<strong>每个线程默认会开启1M的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-Xss   对每个线程stack大小的调整,-Xss128k
</span></span></code></pre></td></tr></table>
</div>
</div><p>5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小</p>
<p>6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。</p>
<p>7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold=1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。</p>
<p>8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">（1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">（2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。
</span></span></code></pre></td></tr></table>
</div>
</div><p>9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:+LargePageSizeInBytes 设置内存页的大小
</span></span></code></pre></td></tr></table>
</div>
</div><p>10）使用非占用的垃圾收集器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="43-说一下-jvm-调优的工具">4.3 说一下 JVM 调优的工具？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<h4 id="431-命令工具">4.3.1 命令工具
</h4><h5 id="4311-jpsjava-process-status">4.3.1.1 jps（Java Process Status）
</h5><p>输出JVM中运行的进程状态信息(现在一般使用jconsole)</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904104739581.png"
	width="278"
	height="133"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904104739581_hu148043871549956762.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904104739581_hu14756129728331186003.png 1024w"
	loading="lazy"
	
		alt="image-20220904104739581"
	
	
		class="gallery-image" 
		data-flex-grow="209"
		data-flex-basis="501px"
	
></p>
<h5 id="4312-jstack">4.3.1.2 jstack
</h5><p>查看java进程内<strong>线程的堆栈</strong>信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">jstack <span class="o">[</span>option<span class="o">]</span> &lt;pid&gt;  
</span></span></code></pre></td></tr></table>
</div>
</div><p>java案例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">com.heima.jvm</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Application</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1000</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;哈哈哈&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>使用jstack查看进行堆栈运行信息</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904111059602.png"
	width="1256"
	height="792"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904111059602_hu8822512273230902428.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904111059602_hu9362432397864055623.png 1024w"
	loading="lazy"
	
		alt="image-20220904111059602"
	
	
		class="gallery-image" 
		data-flex-grow="158"
		data-flex-basis="380px"
	
></p>
<h5 id="4313-jmap">4.3.1.3 jmap
</h5><p>用于生成堆转存快照</p>
<blockquote>
<p>jmap [options] pid  内存映像信息</p>
<p>jmap -heap pid   显示Java堆的信息</p>
<p>jmap -dump format=b,file=heap.hprof pid</p>
<p>​		format=b表示以hprof二进制格式转储Java堆的内存
​		file=<filename>用于指定快照dump文件的文件名。</p>
</blockquote>
<p>例1，显示了某一个java运行的堆信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nl">C</span><span class="p">:</span><span class="err">\</span><span class="n">Users</span><span class="err">\</span><span class="n">yuhon</span><span class="o">&gt;</span><span class="n">jmap</span><span class="w"> </span><span class="o">-</span><span class="n">heap</span><span class="w"> </span><span class="n">53280</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Attaching</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">53280</span><span class="p">,</span><span class="w"> </span><span class="n">please</span><span class="w"> </span><span class="n">wait</span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Debugger</span><span class="w"> </span><span class="n">attached</span><span class="w"> </span><span class="n">successfully</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Server</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">detected</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">JVM</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">25</span><span class="p">.</span><span class="na">321</span><span class="o">-</span><span class="n">b07</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">using</span><span class="w"> </span><span class="n">thread</span><span class="o">-</span><span class="n">local</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">allocation</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Parallel</span><span class="w"> </span><span class="n">GC</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">8</span><span class="w"> </span><span class="nf">thread</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">   </span><span class="c1">//并行的垃圾回收器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Heap</span><span class="w"> </span><span class="n">Configuration</span><span class="p">:</span><span class="w">  </span><span class="c1">//堆配置</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">MinHeapFreeRatio</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w">   </span><span class="c1">//空闲堆空间的最小百分比</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">MaxHeapFreeRatio</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">100</span><span class="w">  </span><span class="c1">//空闲堆空间的最大百分比</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">MaxHeapSize</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">8524922880</span><span class="w"> </span><span class="p">(</span><span class="n">8130</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w"> </span><span class="c1">//堆空间允许的最大值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">NewSize</span><span class="w">                  </span><span class="o">=</span><span class="w"> </span><span class="n">178257920</span><span class="w"> </span><span class="p">(</span><span class="n">170</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w"> </span><span class="c1">//新生代堆空间的默认值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">MaxNewSize</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="n">2841640960</span><span class="w"> </span><span class="p">(</span><span class="n">2710</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w"> </span><span class="c1">//新生代堆空间允许的最大值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">OldSize</span><span class="w">                  </span><span class="o">=</span><span class="w"> </span><span class="n">356515840</span><span class="w"> </span><span class="p">(</span><span class="n">340</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w"> </span><span class="c1">//老年代堆空间的默认值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">NewRatio</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="n">2</span><span class="w"> </span><span class="c1">//新生代与老年代的堆空间比值，表示新生代：老年代=1：2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">SurvivorRatio</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">8</span><span class="w"> </span><span class="c1">//两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">MetaspaceSize</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">21807104</span><span class="w"> </span><span class="p">(</span><span class="n">20</span><span class="p">.</span><span class="na">796875MB</span><span class="p">)</span><span class="w"> </span><span class="c1">//元空间的默认值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">CompressedClassSpaceSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1073741824</span><span class="w"> </span><span class="p">(</span><span class="n">1024</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w"> </span><span class="c1">//压缩类使用空间大小</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">MaxMetaspaceSize</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">17592186044415</span><span class="w"> </span><span class="n">MB</span><span class="w"> </span><span class="c1">//元空间允许的最大值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">G1HeapRegionSize</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">(</span><span class="n">0</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="c1">//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Heap</span><span class="w"> </span><span class="n">Usage</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">PS</span><span class="w"> </span><span class="n">Young</span><span class="w"> </span><span class="n">Generation</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Eden</span><span class="w"> </span><span class="n">Space</span><span class="p">:</span><span class="w"> </span><span class="c1">//Eden使用情况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">134217728</span><span class="w"> </span><span class="p">(</span><span class="n">128</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">used</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">10737496</span><span class="w"> </span><span class="p">(</span><span class="n">10</span><span class="p">.</span><span class="na">240074157714844MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">free</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">123480232</span><span class="w"> </span><span class="p">(</span><span class="n">117</span><span class="p">.</span><span class="na">75992584228516MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">8</span><span class="p">.</span><span class="na">000057935714722</span><span class="o">%</span><span class="w"> </span><span class="n">used</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">From</span><span class="w"> </span><span class="n">Space</span><span class="p">:</span><span class="w"> </span><span class="c1">//Survivor-From 使用情况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">22020096</span><span class="w"> </span><span class="p">(</span><span class="n">21</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">used</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">(</span><span class="n">0</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">free</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">22020096</span><span class="w"> </span><span class="p">(</span><span class="n">21</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">0</span><span class="p">.</span><span class="na">0</span><span class="o">%</span><span class="w"> </span><span class="n">used</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">To</span><span class="w"> </span><span class="n">Space</span><span class="p">:</span><span class="w"> </span><span class="c1">//Survivor-To 使用情况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">22020096</span><span class="w"> </span><span class="p">(</span><span class="n">21</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">used</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">(</span><span class="n">0</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">free</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">22020096</span><span class="w"> </span><span class="p">(</span><span class="n">21</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">0</span><span class="p">.</span><span class="na">0</span><span class="o">%</span><span class="w"> </span><span class="n">used</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">PS</span><span class="w"> </span><span class="n">Old</span><span class="w"> </span><span class="n">Generation</span><span class="w">  </span><span class="c1">//老年代 使用情况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">356515840</span><span class="w"> </span><span class="p">(</span><span class="n">340</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">used</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="p">(</span><span class="n">0</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">free</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">356515840</span><span class="w"> </span><span class="p">(</span><span class="n">340</span><span class="p">.</span><span class="na">0MB</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">0</span><span class="p">.</span><span class="na">0</span><span class="o">%</span><span class="w"> </span><span class="n">used</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">3185</span><span class="w"> </span><span class="n">interned</span><span class="w"> </span><span class="n">Strings</span><span class="w"> </span><span class="n">occupying</span><span class="w"> </span><span class="n">261264</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h5 id="4314-jhat">4.3.1.4 jhat
</h5><p>用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）</p>
<h5 id="4315-jstat">4.3.1.5 jstat
</h5><p>是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。</p>
<p><strong>常见参数</strong>：</p>
<p>①总结垃圾回收统计</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">jstat -gcutil pid
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904114511854.png"
	width="827"
	height="74"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904114511854_hu6269354257811570190.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904114511854_hu10163568702101554540.png 1024w"
	loading="lazy"
	
		alt="image-20220904114511854"
	
	
		class="gallery-image" 
		data-flex-grow="1117"
		data-flex-basis="2682px"
	
></p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>字段</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>S0</td>
          <td>幸存1区当前使用比例</td>
      </tr>
      <tr>
          <td>S1</td>
          <td>幸存2区当前使用比例</td>
      </tr>
      <tr>
          <td>E</td>
          <td>伊甸园区使用比例</td>
      </tr>
      <tr>
          <td>O</td>
          <td>老年代使用比例</td>
      </tr>
      <tr>
          <td>M</td>
          <td>元数据区使用比例</td>
      </tr>
      <tr>
          <td>CCS</td>
          <td>压缩使用比例</td>
      </tr>
      <tr>
          <td>YGC</td>
          <td>年轻代垃圾回收次数</td>
      </tr>
      <tr>
          <td>YGCT</td>
          <td>年轻代垃圾回收消耗时间</td>
      </tr>
      <tr>
          <td>FGC</td>
          <td>老年代垃圾回收次数</td>
      </tr>
      <tr>
          <td>FGCT</td>
          <td>老年代垃圾回收消耗时间</td>
      </tr>
      <tr>
          <td>GCT</td>
          <td>垃圾回收消耗总时间</td>
      </tr>
  </tbody>
</table></div>
<p>②垃圾回收统计</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">jstat -gc pid
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904115157363.png"
	width="1385"
	height="78"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904115157363_hu197455487302321022.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904115157363_hu16518530250394342066.png 1024w"
	loading="lazy"
	
		alt="image-20220904115157363"
	
	
		class="gallery-image" 
		data-flex-grow="1775"
		data-flex-basis="4261px"
	
></p>
<h4 id="432-可视化工具">4.3.2 可视化工具
</h4><h5 id="4321-jconsole">4.3.2.1 jconsole
</h5><p>用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904115936095.png"
	width="890"
	height="753"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904115936095_hu6642333735254886024.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904115936095_hu7968342978178439839.png 1024w"
	loading="lazy"
	
		alt="image-20220904115936095"
	
	
		class="gallery-image" 
		data-flex-grow="118"
		data-flex-basis="283px"
	
></p>
<p>可以内存、线程、类等信息</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904120057211.png"
	width="897"
	height="750"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904120057211_hu11574614898712742852.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904120057211_hu4344457567527843385.png 1024w"
	loading="lazy"
	
		alt="image-20220904120057211"
	
	
		class="gallery-image" 
		data-flex-grow="119"
		data-flex-basis="287px"
	
></p>
<h5 id="4322-visualvm故障处理工具">4.3.2.2 VisualVM：故障处理工具
</h5><p>能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈</p>
<p>打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904120356174.png"
	width="980"
	height="750"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904120356174_hu17842521489104890720.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904120356174_hu1820170407740282177.png 1024w"
	loading="lazy"
	
		alt="image-20220904120356174"
	
	
		class="gallery-image" 
		data-flex-grow="130"
		data-flex-basis="313px"
	
></p>
<p>监控程序运行情况</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132011289.png"
	width="1911"
	height="968"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132011289_hu11647631114533593433.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132011289_hu14150461917566665868.png 1024w"
	loading="lazy"
	
		alt="image-20220904132011289"
	
	
		class="gallery-image" 
		data-flex-grow="197"
		data-flex-basis="473px"
	
></p>
<p>查看运行中的dump</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132134095.png"
	width="1521"
	height="566"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132134095_hu1683408823750691797.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132134095_hu11198012518187640223.png 1024w"
	loading="lazy"
	
		alt="image-20220904132134095"
	
	
		class="gallery-image" 
		data-flex-grow="268"
		data-flex-basis="644px"
	
></p>
<p>查看堆中的信息</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132346495.png"
	width="1066"
	height="900"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132346495_hu13872948613203328710.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132346495_hu11817954910292059015.png 1024w"
	loading="lazy"
	
		alt="image-20220904132346495"
	
	
		class="gallery-image" 
		data-flex-grow="118"
		data-flex-basis="284px"
	
></p>
<h3 id="44-java内存泄露的排查思路">4.4 java内存泄露的排查思路？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>1、通过jmap指定打印他的内存快照 dump</p>
<blockquote>
<p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p>
<p>-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/home/app/dumps/      指定生成后文件的保存目录</p>
</blockquote>
<p>2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件</p>
<p>VisualVM可以加载离线的dump文件，如下图</p>
<p>文件&ndash;&gt;装入&mdash;&gt;选择dump文件即可查看堆快照信息</p>
<blockquote>
<p>如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化</p>
</blockquote>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132925812.png"
	width="430"
	height="435"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132925812_hu13583541672726810282.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904132925812_hu13030342047904265640.png 1024w"
	loading="lazy"
	
		alt="image-20220904132925812"
	
	
		class="gallery-image" 
		data-flex-grow="98"
		data-flex-basis="237px"
	
></p>
<p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904133722905.png"
	width="874"
	height="770"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904133722905_hu16584616344377275225.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904133722905_hu15818620757265147061.png 1024w"
	loading="lazy"
	
		alt="image-20220904133722905"
	
	
		class="gallery-image" 
		data-flex-grow="113"
		data-flex-basis="272px"
	
></p>
<p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<h3 id="45-cpu飙高排查方案与思路">4.5 CPU飙高排查方案与思路？
</h3><blockquote>
<p>难易程度：☆☆☆☆</p>
<p>出现频率：☆☆☆☆</p>
</blockquote>
<p>1.使用top命令查看占用cpu的情况</p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904161818255.png"
	width="963"
	height="378"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904161818255_hu7177102466871094397.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904161818255_hu4439763637189614672.png 1024w"
	loading="lazy"
	
		alt="image-20220904161818255"
	
	
		class="gallery-image" 
		data-flex-grow="254"
		data-flex-basis="611px"
	
></p>
<p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978</p>
<p>3.查看当前线程中的进程信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">ps H -eo pid,tid,%cpu <span class="p">|</span> grep <span class="m">30978</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>pid  进行id</p>
<p>tid   进程中的线程id</p>
<p>%  cpu使用率</p>
</blockquote>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162117022.png"
	width="631"
	height="339"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162117022_hu16858786872131165532.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162117022_hu13316636879651659357.png 1024w"
	loading="lazy"
	
		alt="image-20220904162117022"
	
	
		class="gallery-image" 
		data-flex-grow="186"
		data-flex-basis="446px"
	
></p>
<p>4.通过上图分析，在进程30978中的线程30979占用cpu较高</p>
<blockquote>
<p>注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称</p>
<p>转换方式：</p>
<p>在linux中执行命令</p>
<p><code>printf &quot;%x\n&quot; 30979</code></p>
<p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162654928.png"
	width="454"
	height="106"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162654928_hu11851779829336670613.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162654928_hu12337331514488442293.png 1024w"
	loading="lazy"
	
		alt="image-20220904162654928"
	
	
		class="gallery-image" 
		data-flex-grow="428"
		data-flex-basis="1027px"
	
></p>
</blockquote>
<p>5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号</p>
<p>执行命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">jstack <span class="m">30978</span>   此处是进程id
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162941977.png"
	width="1056"
	height="577"
	srcset="/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162941977_hu251831166255625837.png 480w, /p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/JVM%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220904162941977_hu17829236348136901240.png 1024w"
	loading="lazy"
	
		alt="image-20220904162941977"
	
	
		class="gallery-image" 
		data-flex-grow="183"
		data-flex-basis="439px"
	
></p>
<h2 id="5面试现场">5.面试现场
</h2><h3 id="51-jvm组成">5.1 JVM组成
</h3><blockquote>
<p><strong>面试官</strong>：JVM由那些部分组成，运行流程是什么？</p>
<p><strong>候选人:</strong></p>
<p>嗯，好的~~</p>
<p>在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）</p>
<p>它们的运行流程是：</p>
<p>第一，类加载器（ClassLoader）把Java代码转换为字节码</p>
<p>第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行</p>
<p>第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。</p>
<p><strong>面试官</strong>：好的，你能详细说一下 JVM 运行时数据区吗？</p>
<p><strong>候选人:</strong></p>
<p>嗯，好~</p>
<p>运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。</p>
<ul>
<li>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</li>
<li>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</li>
<li>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</li>
<li>本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</li>
<li>程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</li>
</ul>
<p><strong>面试官</strong>：好的，你再详细介绍一下程序计数器的作用？</p>
<p><strong>候选人:</strong></p>
<p>嗯，是这样~~</p>
<p>java虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。</p>
<p><strong>面试官</strong>：你能给我详细的介绍Java堆吗?</p>
<p><strong>候选人:</strong></p>
<p>好的~</p>
<p>Java中的堆术语线程共享的区域。主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p>
<p>​	在JAVA8中堆内会存在年轻代、老年代</p>
<p>​	1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。</p>
<p>​	2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。</p>
<p><strong>面试官</strong>：能不能解释一下方法区？</p>
<p><strong>候选人:</strong></p>
<p>好的~</p>
<p>与虚拟机栈类似。本地方法栈是为虚拟机<strong>执行本地方法时提供服务的</strong>。不需要进行GC。本地方法一般是由其他语言编写。</p>
<p><strong>面试官</strong>：你听过直接内存吗？</p>
<p><strong>候选人:</strong></p>
<p>嗯~~</p>
<p>它又叫做<strong>堆外内存</strong>，<strong>线程共享的区域</strong>，在 Java 8 之前有个<strong>永久代</strong>的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，<strong>主要存储类的信息，常量，静态变量</strong>，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。</p>
<p>​	所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。</p>
<p><strong>面试官</strong>：什么是虚拟机栈</p>
<p><strong>候选人:</strong></p>
<p>虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建<strong>栈桢</strong>。保存执行方法时的<strong>局部变量、动态连接信息、方法返回地址信息</strong>等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域<strong>不需要进行 GC</strong>。</p>
<p><strong>面试官</strong>：能说一下堆栈的区别是什么吗？</p>
<p><strong>候选人:</strong></p>
<p>嗯，好的，有这几个区别</p>
<p>第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。</p>
<p>第二、栈内存是线程私有的，而堆内存是线程共有的。</p>
<p>第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。</p>
<p>栈空间不足：java.lang.StackOverFlowError。</p>
<p>堆空间不足：java.lang.OutOfMemoryError。</p>
</blockquote>
<h3 id="52-类加载器">5.2 类加载器
</h3><blockquote>
<p><strong>面试官</strong>：什么是类加载器，类加载器有哪些?</p>
<p><strong>候选人:</strong></p>
<p>嗯，是这样的</p>
<p>JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p>
<p>常见的类加载器有4个</p>
<p>第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。</p>
<p>第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。</p>
<p>第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。</p>
<p>第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。</p>
<p><strong>面试官</strong>：说一下类装载的执行过程？</p>
<p><strong>候选人:</strong></p>
<p>嗯，这个过程还是挺多的。</p>
<p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p>
<p>1.加载：查找和导入class文件</p>
<p>2.验证：保证加载类的准确性</p>
<p>3.准备：为类变量分配内存并设置类变量初始值</p>
<p>4.解析：把类中的符号引用转换为直接引用</p>
<p>5.初始化：对类的静态变量，静态代码块执行初始化操作</p>
<p>6.使用：JVM 开始从入口方法开始执行用户的程序代码</p>
<p>7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存</p>
<p><strong>面试官</strong>：什么是双亲委派模型？</p>
<p><strong>候选人:</strong></p>
<p>嗯，它是是这样的。</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载</p>
<p><strong>面试官</strong>：JVM为什么采用双亲委派机制</p>
<p><strong>候选人:</strong></p>
<p>主要有两个原因。</p>
<p>第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p>
<p>第二、为了安全，保证类库API不会被修改</p>
</blockquote>
<h3 id="53-垃圾回收">5.3 垃圾回收
</h3><blockquote>
<p><strong>面试官</strong>：简述Java垃圾回收机制？（GC是什么？为什么要GC）</p>
<p><strong>候选人:</strong></p>
<p>嗯，是这样~~</p>
<p>为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。</p>
<p>有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。</p>
<p>在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机</p>
<p><strong>面试官</strong>：强引用、软引用、弱引用、虚引用的区别？</p>
<p><strong>候选人:</strong></p>
<p>嗯嗯~</p>
<p>强引用最为普通的引用方式，表示一个对象处于<strong>有用且必须</strong>的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收</p>
<p>软引用表示一个对象处于<strong>有用且非必须</strong>状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。</p>
<p>弱引用表示一个对象处于<strong>可能有用且非必须</strong>的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。</p>
<p>虚引用表示一个对象处于<strong>无用</strong>的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用</p>
<p><strong>面试官</strong>：对象什么时候可以被垃圾器回收</p>
<p><strong>候选人:</strong></p>
<p>思考一会~~</p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p>如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法</p>
<p>通常都使用可达性分析算法来确定是不是垃圾</p>
<p><strong>面试官</strong>： JVM 垃圾回收算法有哪些？</p>
<p><strong>候选人:</strong></p>
<p>我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收</p>
<p><strong>面试官</strong>： 你能详细聊一下分代回收吗？</p>
<p><strong>候选人:</strong></p>
<p>关于分代回收是这样的</p>
<p>在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2</p>
<p>对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1</p>
<p>具体的工作机制是有些情况：</p>
<p>1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。</p>
<p>2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且<strong>当前对象的年龄会加1</strong>，清空Eden区。</p>
<p>3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。</p>
<p>4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。</p>
<p>5）对象的年龄达到了某一个限定的值（<strong>默认15岁</strong>  ），那么这个对象就会进入到老年代中。</p>
<p>当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代</p>
<p>当老年代满了之后，<strong>触发FullGC</strong>。<strong>FullGC同时回收新生代和老年代</strong>，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。  我们在程序中要尽量避免FullGC的出现。</p>
<p><strong>面试官</strong>：讲一下新生代、老年代、永久代的区别？</p>
<p><strong>候选人:</strong></p>
<p>嗯！是这样的，简单说就是</p>
<p><strong>新生代</strong>主要用来存放新生的对象。</p>
<p><strong>老年代</strong>主要存放应用中生命周期长的内存对象。</p>
<p><strong>永久代</strong>指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<strong>元空间</strong>）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。</p>
<p><strong>面试官</strong>：说一下 JVM 有哪些垃圾回收器？</p>
<p><strong>候选人:</strong></p>
<p>在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）</p>
<p><strong>面试官</strong>：Minor GC、Major GC、Full GC是什么</p>
<p><strong>候选人:</strong></p>
<p>嗯，其实它们指的是不同代之间的垃圾回收</p>
<p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
<p>Major GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长</p>
<p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</blockquote>
<h3 id="54-jvm实践调优">5.4 JVM实践（调优）
</h3><blockquote>
<p><strong>面试官</strong>：JVM 调优的参数可以在哪里设置参数值？</p>
<p><strong>候选人:</strong></p>
<p>我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了</p>
<p><strong>面试官</strong>：用的 JVM 调优的参数都有哪些？</p>
<p><strong>候选人:</strong></p>
<p>嗯，这些参数是比较多的</p>
<p>我记得当时我们设置过堆的大小，像-Xms和-Xmx</p>
<p>还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例</p>
<p>还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。</p>
<p><strong>面试官</strong>：嗯，好的，你们平时调试 JVM都用了哪些工具呢？</p>
<p><strong>候选人:</strong></p>
<p>嗯，我们一般都是使用jdk自带的一些工具，比如</p>
<p>jps 输出JVM中运行的进程状态信息</p>
<p>jstack查看java进程内<strong>线程的堆栈</strong>信息。</p>
<p>jmap 用于生成堆转存快照</p>
<p>jstat用于JVM统计监测工具</p>
<p>还有一些可视化工具，像jconsole和VisualVM等</p>
<p><strong>面试官</strong>：假如项目中产生了java内存泄露，你说一下你的排查思路？</p>
<p><strong>候选人:</strong></p>
<p>嗯，这个我在之前项目排查过</p>
<p>第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件</p>
<p>第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析</p>
<p>第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p>
<p>第四，找到对应的代码，通过阅读上下文的情况，进行修复即可</p>
<p><strong>面试官</strong>：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？</p>
<p><strong>候选人:</strong></p>
<p>嗯，我思考一下~~</p>
<p>可以这么做~~</p>
<p>第一可以使用使用top命令查看占用cpu的情况</p>
<p>第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id</p>
<p>第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高</p>
<p>第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/">JVM相关面试题</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="gajzj/gajzj.github.io"
    data-repo-id="R_kgDOMnkDwQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOMnkDwc4Ch6ca"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector("iframe.giscus-frame");
        if (giscus) {
            giscus.contentWindow.postMessage(
                {
                    giscus: {
                        setConfig: {
                            theme: theme,
                        },
                    },
                },
                "https://giscus.app"
            );
        }
    }

    (function () {
        addEventListener("message", (e) => {
            if (event.origin !== "https://giscus.app") return;
            handler();
        });
        window.addEventListener("onColorSchemeChange", handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light');
            } else {
                setGiscusTheme('dark_dimmed');
            }
        }
    })();
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 gajzj
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
</body>
</html>
    </body>
</html>
