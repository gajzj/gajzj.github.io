[{"content":"云岚到家 项目介绍 项目背景 互联网+家政\n运营模式 B2B2C与C2B2C的区别是：B2B2C中服务提供者是家政服务中介公司，在C2B2C中是服务提供者是拥有服务技能的服务人员（散户）。\n业务流程 核心流程就是：平台发布服务项目\u0026gt;用户端选择项目并下单、支付\u0026gt;散户、机构抢单\u0026gt;实施服务\u0026gt;完成服务、评价\n开发区域服务模块 查询区域服务 接口设计 分页查询接口设计\n基础参数：pageNum、pageSize、orderBy、isAsc 业务参数：动态查询的条件 添加接口设计\n分析目标数据表中每个字段的数据来源，决定传入参数 修改接口设计\n通过页面原型分析有哪些数据可以修改，然后找到表中的数据源以及和它们有关联的数据 修改接口需要针对具体的某一条数据，所以肯定有id、除此之外还有各种需要更改的字段 客户管理 登录验证码如何区分业务类型 用的String做key，存到redis，过期时间是5分钟\n短信发送 开通短信服务\u0026gt;导入阿里的sdk\u0026gt;提供电话号码、短信签名、模板编号（有流控）\n机构端登录、注册实现 机构端限定账号密码登录\n前端输入账号密码，发送请求 后端校验数据完整性、正确性、是否禁用 密码匹配 生成token返回 后续请求携带token（header中） 注册时需要提供手机号和验证码\n校验验证码 手机号、业务类型 校验当前手机号是否已经被注册 密码加密方式BCrypt（B、C、rypt） 机构账号密码找回\n入参 手机号、业务验证码、新密码 校验手机号账号是否存在 验证码是否正确 密码加密（BCrypt） 用户端定位交互流程 小程序端调用微信方法获取经纬度返回给后端\n后端调用高德地图接口返回详细信息\nregion表的city_code是提前从高德地图上下载的全国区域信息，转为json交由前端保存\n在添加区域时直接从json中展示所有的区域列表\n地址簿 新增地址簿\n前端调用手机定位获取当前位置 然后提交经纬度获取地址的详细信息 将地理位置的信息、联系人的信息一起传给新增地址接口 后端执行新增地址逻辑 查询、编辑、删除、设置默认地址\n略 我的账户设置 跳过\n小程序门户-缓存 门户的要求\n动态更新 加载速度快、访问频率高 Web门户\n将门户页面生成静态页面发布到CDN服务器 将静态资源也都放到CDN html的动态数据通过异步请求后端缓存服务器（reids） 负载均衡，多个nginx共同提供服务（高可用、高性能） 前端也做缓存 LocalStorage SessionStorage Cookie 移动应用门户\n缓存技术方案 有哪些信息需要缓存\n首页的各种列表和列表中的不同项目 热门的列表 类型列表 服务详细信息 Spring Cache 集成Lettuce客户端与Redis服务器通信，基于AOP\ncacheManager\n@CacheEvict、@CachePut、@EnableCaching\n缓存穿透、击穿、雪崩 穿透\n校验、缓存空值、布隆过滤器 击穿：热点数据失效后瞬间请求打到数据库\n使用锁 分布式锁控制只有一个线程与查询数据库 热点数据不过期 缓存预热 提前预热、定时预热 热点数据查询降级处理 雪崩\n过期时间+随机值 定时预热 缓存不一致 写数据库和写缓存不一致即双写一致（网络卡顿导致并发写的场景下写入旧值）\n使用分布式锁 延迟双删 先删除缓存再写数据库然后再次删除缓存 异步同步 Canal+MQ异步任务方式 服务搜索 服务搜索技术方案 分词关键字搜索\nElasticsearch是基于倒排索引的原理，正排索引是从文章中找词，倒排索引是根据词去找文章\n索引同步方案 方案1：添加服务信息维护索引\n在Service方法中添加维护ES索引的代码\n方案2：使用Canal+MQ\nMysql主从数据同步原理\nmaster、slave\n主从数据同步是一种数据库复制技术\n写数据先向主服务器写 写成功后同步到从服务器 主从数据库同步流程 Canal实现原理\n索引同步方案\n在这个过程中MQ必须保证可靠性\nMQ技术方案 保证生产消息可靠性 本地失败重试 失败消息入库（达到失败次数入库） 失败消息人工处理、失败消息自动处理任务调度 @Retryable注解实现执行失败进行重试\n1 2 3 4 5 @Retryable(value = MqException.class, // 抛出指定异常时重试 maxAttempts = 3, // 最大重试次数、默认三次 backoff = @Backoff(value = 3000, mutiplier = 1.5), // 重试等待策略（每次重试乘以系数） recover = \u0026#34;saveFailMag\u0026#34; // 设置回调方法名，重试耗尽时执行 ) ConfirmCallback：消息成功投递到交换机会返回ack，失败会返回nack\nReturn回调：消息成功到达交换机，但没到队列，调用回调方法\n保证消费信息可靠性 设置消息持久化，发送消息设置deliveryMode = 2\nnone模式下，消息投递是不可靠的，可能丢失 auto模式类似事务机制，出现异常时返回nack，消息回滚到mq；没有异常，返回ack manual：自己根据业务情况，判断什么时候该ack 自动ack模式，失败重试三次后投递到失败队列\n保证消息幂等性 幂等性是指不论执行多少次，其结果一致\n针对不同场景，不同解决方案\n查询操作：本身具有幂等性 添加操作：有可能会重复添加记录，通过设置唯一约束老保证 更新操作：更新操作应当只允许更新成功一次，使用token机制 发送消息前生成一个token写入redis，收到消息后解析出token，从redis查询token 查询到则说明没有消费，此时更新，更新成功后删除token缓存 当重复消费时，token会被删除，所以不会执行 删除操作：与更新类似 配置数据同步环境 索引同步 ","date":"2024-11-10T16:02:00+08:00","permalink":"https://example.com/p/%E4%BA%91%E5%B2%9A%E5%88%B0%E5%AE%B6/","title":"云岚到家"},{"content":"JVM相关面试题 1 JVM组成 1.1 JVM由那些部分组成，运行流程是什么？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n从图中可以看出 JVM 的主要组成部分\nClassLoader（类加载器） Runtime Data Area（运行时数据区，内存分区） Execution Engine（执行引擎） Native Method Library（本地库接口） 运行流程：\n（1）类加载器（ClassLoader）把Java代码转换为字节码\n（2）运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行\n（3）执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。\n1.2 说一下 JVM 运行时数据区 难易程度：☆☆☆\n出现频率：☆☆☆\n组成部分：堆、方法区、栈、本地方法栈、程序计数器\n1、堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。 2、方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。 3、栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。 4、本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。 5、程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。\n1.3 什么是程序计数器？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n线程私有的。内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。\njavap -verbose xx.class 打印堆栈大小，局部变量的数量和方法的参数。\n​\tjava虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。\n​\t那么现在有一个问题就是，当前处理器如何能够知道，对于这个被挂起的线程，它上一次执行到了哪里？那么这时就需要从程序计数器中来回去到当前的这个线程他上一次执行的行号，然后接着继续向下执行。\n​\t程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。\n1.4 你能给我详细的介绍Java堆吗? 难易程度：☆☆☆\n出现频率：☆☆☆☆\n线程共享的区域。主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。\n​\t在JAVA7中堆内会存在年轻代、老年代和方法区(永久代)。\n​\t1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。\n​\t2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。\n​\t3）Perm代主要保存保存的类信息、静态变量、常量、编译后的代码，在java7中堆上方法区会受到GC的管理的。方法区【永久代】是有一个大小的限制的。如果大量的动态生成类，就会放入到方法区【永久代】，很容易造成OOM。\n​\t为了避免方法区出现OOM，所以在java8中将堆上的方法区【永久代】给移动到了本地内存上，重新开辟了一块空间，叫做元空间。那么现在就可以避免掉OOM的出现了。\n扩展：\n元空间(MetaSpace)介绍 ​\t在 HotSpot JVM 中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。\n​\t永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。\n​\t那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？\n官网给出了解释：http://openjdk.java.net/jeps/122\n1 2 3 This is part of the JRockit and Hotspot convergence effort. JRockit customers do not need to configure the permanent generation (since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation. 移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。 1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。\n2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。\n​\t准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如类元信息、字段、静态属性、方法、常量等都移动到元空间区。比如 java/lang/Object 类元信息、静态属性 System.out、整型常量等。\n​\t元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\n1.5 能不能解释一下方法区？ 难易程度：☆☆☆\n出现频率：☆☆☆\n方法区类似于传统语言的编译代码的存储区，它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化和接口初始化中使用 的特殊方法\n方法区是在虚拟机启动时创建的。尽管方法区在逻辑上是堆的一部分，但简单的实现可能会选择不进行垃圾收集或压缩它。本规范不要求方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小，也可以根据计算需要扩大，如果不需要更大的方法区域，可以缩小。方法区的内存不需要是连续的。\nJava 虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，以及在方法区域大小可变的情况下，对最大和最小方法区域大小的控制。\n以下异常情况与方法区相关：\n如果方法区域中的内存无法满足分配请求，Java 虚拟机将抛出一个OutOfMemoryError. 1.6 你听过直接内存吗？ 难易程度：☆☆☆\n出现频率：☆☆☆\n不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理\n举例：\n需求，在本地电脑中的一个较大的文件（超过100m）从一个磁盘挪到另外一个磁盘\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /** * 演示 ByteBuffer 作用 */ public class Demo1_9 { static final String FROM = \u0026#34;E:\\\\编程资料\\\\第三方教学视频\\\\youtube\\\\Getting Started with Spring Boot-sbPSjI4tt10.mp4\u0026#34;; static final String TO = \u0026#34;E:\\\\a.mp4\u0026#34;; static final int _1Mb = 1024 * 1024; public static void main(String[] args) { io(); // io 用时：1535.586957 1766.963399 1359.240226 directBuffer(); // directBuffer 用时：479.295165 702.291454 562.56592 } private static void directBuffer() { long start = System.nanoTime(); try (FileChannel from = new FileInputStream(FROM).getChannel(); FileChannel to = new FileOutputStream(TO).getChannel(); ) { ByteBuffer bb = ByteBuffer.allocateDirect(_1Mb); while (true) { int len = from.read(bb); if (len == -1) { break; } bb.flip(); to.write(bb); bb.clear(); } } catch (IOException e) { e.printStackTrace(); } long end = System.nanoTime(); System.out.println(\u0026#34;directBuffer 用时：\u0026#34; + (end - start) / 1000_000.0); } private static void io() { long start = System.nanoTime(); try (FileInputStream from = new FileInputStream(FROM); FileOutputStream to = new FileOutputStream(TO); ) { byte[] buf = new byte[_1Mb]; while (true) { int len = from.read(buf); if (len == -1) { break; } to.write(buf, 0, len); } } catch (IOException e) { e.printStackTrace(); } long end = System.nanoTime(); System.out.println(\u0026#34;io 用时：\u0026#34; + (end - start) / 1000_000.0); } } 可以发现，使用传统的IO的时间要比NIO操作的时间长了很多了，也就说NIO的读性能更好。\n这个是跟我们的JVM的直接内存是有一定关系，如下图，是传统阻塞IO的数据传输流程\n下图是NIO传输数据的流程，在这个里面主要使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。\n1.7 什么是虚拟机栈 难易程度：☆☆☆\n出现频率：☆☆☆☆\n​\t描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建栈桢。保存执行方法时的局部变量、动态连接信息、方法返回地址信息等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域不需要进行 GC。\n1.8 堆栈的区别是什么？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。\n2、栈内存是线程私有的，而堆内存是线程共有的。\n3,、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。\n栈空间不足：java.lang.StackOverFlowError。\n堆空间不足：java.lang.OutOfMemoryError。\n2 类加载器 2.1 什么是类加载器，类加载器有哪些? 难易程度：☆☆☆☆\n出现频率：☆☆☆\n要想理解类加载器的话，务必要先清楚对于一个Java文件，它从编译到执行的整个过程。\n类加载器：用于装载字节码文件(.class文件) 运行时数据区：用于分配存储空间 执行引擎：执行字节码文件或本地方法 垃圾回收器：用于对JVM中的垃圾内容进行回收 类加载器\nJVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源\n类加载器种类\n类加载器根据各自加载范围的不同，划分为四种类加载器：\n启动类加载器(BootStrap ClassLoader)：\n该类并不继承ClassLoader类，其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。\n扩展类加载器(ExtClassLoader)：\n该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。\n应用类加载器(AppClassLoader)：\n该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。\n自定义类加载器：\n开发者自定义类继承ClassLoader，实现自定义类加载规则。\n上述三种类加载器的层次结构如下如下：\n类加载器的体系并不是“继承”体系，而是委派体系，类加载器首先会到自己的parent中查找类或者资源，如果找不到才会到自己本地查找。类加载器的委托行为动机是为了避免相同的类被加载多次。\n2.2 说一下类装载的执行过程？ 难易程度：☆☆☆☆☆\n出现频率：☆☆☆\n类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。\n类加载过程详解\n1.加载\n查找和导入class文件\n(1)获取类的二进制字节流 ,将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 (2)在Java堆中生成一个Class对象，作为方法区中这些数据的访问入口\n2.验证\n保证加载类的准确性\n(1)文件格式验证:是否符合Class文件的规范 (2)元数据验证 这个类是否有父类（除了Object这个类之外，其余的类都应该有父类） 这个类是否继承（extends）了被final修饰过的类（被final修饰过的类表示类不能被继承） 类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能覆盖的）\t(3)字节码验证 主要的目的是通过对数据流和控制流的分析，确定程序语义是合法的、符合逻辑的。 (4)符号引用验证：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量\n比如：int i = 3; 字面量：3 符号引用：i\n3.准备\n为类变量分配内存并设置类变量初始值\nJava 中的变量有\u0026quot;类变量\u0026quot;和\u0026quot;类成员变量\u0026quot;两种类型 类变量:指的是被 静态（static） 修饰的变量 类成员变量:指的是非静态修饰的变量 在准备阶段，JVM 只会为\u0026quot;类变量\u0026quot;分配内存，而不会为\u0026quot;类成员变量\u0026quot;分配内存 \u0026ldquo;类成员变量\u0026rdquo;：内存分配需要等到 类加载的初始化 阶段才开始。\n4.解析\n把类中的符号引用转换为直接引用\n比如方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。\n5.初始化\n对类的静态变量，静态代码块执行初始化操作\n只对静态（static）修饰的变量或语句块进行初始化。如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。\n6.使用\nJVM 开始从入口方法开始执行用户的程序代码\n7.卸载\n当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存\n2.3 什么是双亲委派模型？ 难易程度：☆☆☆☆\n出现频率：☆☆☆☆\n如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。\n2.4 JVM为什么采用双亲委派机制 难易程度：☆☆☆\n出现频率：☆☆☆\n（1）通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。\n（2）为了安全，保证类库API不会被修改\n在工程中新建java.lang包，接着在该包下新建String类，并定义main函数\n1 2 3 4 5 6 7 public class String { public static void main(String[] args) { System.out.println(\u0026#34;demo info\u0026#34;); } } ​\t此时执行main函数，会出现异常，在类 java.lang.String 中找不到 main 方法\n​\t出现该信息是因为由双亲委派的机制，java.lang.String的在启动类加载器(Bootstrap classLoader)得到加载，因为在核心jre库中有其相同名字的类文件，但该类中并没有main方法。这样就能防止恶意篡改核心API库。\n3 垃圾收回 3.1 简述Java垃圾回收机制？（GC是什么？为什么要GC） 难易程度：☆☆☆\n出现频率：☆☆☆\n为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。\n有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。\n在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机\n换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。\n当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。\n3.2 强引用、软引用、弱引用、虚引用的区别？ 难易程度：☆☆☆☆\n出现频率：☆☆☆\n3.2.1 强引用 最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收\n1 User user = new User(); 3.2.2 软引用 表示一个对象处于有用且非必须状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。\n1 2 User user = new User(); SoftReference softReference = new SoftReference(user); 3.2.3 弱引用 表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。\n1 2 User user = new User(); WeakReference weakReference = new WeakReference(user); 延伸话题：ThreadLocal内存泄漏问题\nThreadLocal用的就是弱引用，看以下源码：\n1 2 3 4 5 6 7 8 static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; //强引用，不会被回收 } } Entry的key是当前ThreadLocal，value值是我们要设置的数据。\nWeakReference表示的是弱引用，当JVM进行GC时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。但是value是强引用，它不会被回收掉。\nThreadLocal使用建议：使用完毕后注意调用清理方法。\n3.2.4 虚引用 例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);\n必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.itheima.basic; import java.lang.ref.PhantomReference; import java.lang.ref.ReferenceQueue; import java.util.ArrayList; import java.util.List; public class TestPhantomReference { public static void main(String[] args) throws InterruptedException { ReferenceQueue\u0026lt;String\u0026gt; queue = new ReferenceQueue\u0026lt;\u0026gt;(); List\u0026lt;MyResourse\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new MyResourse(new String(\u0026#34;a\u0026#34;),queue)); list.add(new MyResourse(\u0026#34;b\u0026#34;,queue)); list.add(new MyResourse(new String(\u0026#34;c\u0026#34;),queue)); System.gc(); Thread.sleep(100); Object ref ; while ((ref =queue.poll()) != null){ if(ref instanceof MyResourse){ MyResourse.clean(); } } } static class MyResourse extends PhantomReference\u0026lt;String\u0026gt; { public MyResourse(String referent, ReferenceQueue\u0026lt;? super String\u0026gt; q){ super(referent,q); } //释放外部资源的方法 public static void clean(){ System.out.println(\u0026#34;clean\u0026#34;); } } } 3.3 对象什么时候可以被垃圾器回收 难易程度：☆☆☆☆\n出现频率：☆☆☆☆\n简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。\n如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法\n3.3.1 引用计数法 ​\t一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收\n1 String demo = new String(\u0026#34;123\u0026#34;); 1 String demo = null; 当对象间出现了循环引用的话，则引用计数法就会失效\n虽然a和b都为null，但是由于a和b存在循环引用，这样a和b永远都不会被回收。\n优点：\n实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。 缺点：\n每次对象被引用时，都需要去更新计数器，有一点时间开销。 浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。 无法解决循环引用问题，会引发内存泄露。（最大的缺点） 3.3.1 可达性分析算法 ​\t现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾。\n​\t会存在一个根节点【GC Roots】，引出它下面指向的下一个节点，再以下一个节点节点开始找出它下面的节点，依次往下类推。直到所有的节点全部遍历完毕。\n根对象是那些肯定不能当做垃圾回收的对象，就可以当做根对象\n局部变量，静态方法，静态变量，类信息\n核心是：判断某对象是否与根对象有直接或间接的引用，如果没有被引用，则可以当做垃圾回收\n​\tX,Y这两个节点是可回收的，但是并不会马上的被回收！！ 对象中存在一个方法【finalize】。当对象被标记为可回收后，当发生GC时，首先会判断这个对象是否执行了finalize方法，如果这个方法还没有被执行的话，那么就会先来执行这个方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。\n​\tfinalize方法对于每一个对象来说，只会执行一次。如果第一次执行这个方法的时候，设置了当前对象与RC ROOTS关联，那么这一次不会进行回收。 那么等到这个对象第二次被标记为可回收时，那么该对象的finalize方法就不会再次执行了。\nGC ROOTS：\n虚拟机栈（栈帧中的本地变量表）中引用的对象 1 2 3 4 5 6 7 8 9 /** * demo是栈帧中的本地变量，当 demo = null 时，由于此时 demo 充当了 GC Root 的作用，demo与原来指向的实例 new Demo() 断开了连接，对象被回收。 */ public class Demo { public static void main(String[] args) { Demo demo = new Demo(); demo = null; } } 方法区中类静态属性引用的对象 1 2 3 4 5 6 7 8 9 10 11 /** * 当栈帧中的本地变量 b = null 时，由于 b 原来指向的对象与 GC Root (变量 b) 断开了连接，所以 b 原来指向的对象会被回收，而由于我们给 a 赋值了变量的引用，a在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活! */ public class Demo { public static Demo a; public static void main(String[] args) { Demo b = new Demo(); b.a = new Demo(); b = null; } } 方法区中常量引用的对象 1 2 3 4 5 6 7 8 9 10 11 12 /** * 常量 a 指向的对象并不会因为 demo 指向的对象被回收而回收 */ public class Demo { public static final Demo a = new Demo(); public static void main(String[] args) { Demo demo = new Demo(); demo = null; } } 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 3.4 JVM 垃圾回收算法有哪些？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n3.4.1 标记清除算法 标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除。\n1.根据可达性分析算法得出的垃圾进行标记\n2.对这些标记为可回收的内容进行垃圾回收\n可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。\n同样，标记清除算法也是有缺点的：\n效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。 （重要）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。 3.4.2 复制算法 ​\t复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。\n​\t如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。\n1）将内存区域分成两部分，每次操作其中一个。\n2）当进行垃圾回收时，将正在使用的内存区域中的存活对象移动到未使用的内存区域。当移动完对这部分内存区域一次性清除。\n3）周而复始。\n优点：\n在垃圾对象多的情况下，效率较高 清理后，内存无碎片 缺点：\n分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低 3.4.3 标记整理算法 ​\t标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是将存活对象都向内存另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。\n1）标记垃圾。\n2）需要清除向右边走，不需要清除的向左边走。\n3）清除边界以外的垃圾。\n优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。\n与复制算法对比：复制算法标记完就复制，但标记整理算法得等把所有存活对象都标记完毕，再进行整理\n3.4.4 分代收集算法 在java8时，堆被分为了两份：新生代和老年代【1：2】，在java7时，还存在一个永久代。\n对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区【8：1：1】\n当对新生代产生GC：MinorGC【young GC】\n当对老年代代产生GC：Major GC\n当对新生代和老年代产生FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长，应尽力避免\n3.4.4.1 工作机制 1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。\n2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且当前对象的年龄会加1，清空Eden区。\n3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。\n4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。\n3.4.4.2 对象何时晋升到老年代 1）对象的年龄达到了某一个限定的值（默认15岁 ），那么这个对象就会进入到老年代中。\n2）大对象。\n3）如果在Survivor区中相同年龄的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。\n当老年代满了之后，触发FullGC。FullGC同时回收新生代和老年代，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。\n3.5 讲一下新生代、老年代、永久代的区别？ 难易程度：☆☆☆☆\n出现频率：☆☆☆\n新生代主要用来存放新生的对象。一般占据堆空间的1/3。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行MinorGC，进行垃圾回收。新生代又细分为三个区：Eden区、SurvivorFrom、ServivorTo区，三个区的默认比例为：8：1：1\n老年代主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行MajorGC。而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间\n永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。Classic在被加载的时候被放入永久区域，它和存放的实例的区域不同，在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。元空间和永久代类似，都是对JVM中规范中方法的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。\n3.6 说一下 JVM 有哪些垃圾回收器？ 难易程度：☆☆☆☆\n出现频率：☆☆☆☆\n在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器\n3.6.1 Serial收集器 ​\t串行垃圾收集器，作用于新生代。是指使用单线程进行垃圾回收，采用复制算法。垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停，等待垃圾回收的完成。这种现象称之为STW（Stop-The-World）。其应用在年轻代\n​\t对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。因此一般在Javaweb应用中是不会采用该收集器的。\n3.6.2 ParallelNew收集器 ​\t并行垃圾收集器在串行垃圾收集器的基础之上做了改进，采用复制算法。将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）。但是对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同Serial收集器一样。其也是应用在年轻代。JDK8默认使用此垃圾回收器\n​\t当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。\n3.6.3 Parallel Scavenge收集器 ​\t其是一个应用于新生代的并行垃圾回收器，采用复制算法。它的目标是达到一个可控的吞吐量（吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间））即虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，吞吐量就是99%。这样可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。\n停顿时间越短对于需要与用户交互的程序来说越好，良好的响应速度能提升用户的体验。 高吞吐量可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不太需要太多交互的任务。 3.6.4 Serial Old收集器 ​\t其是运行于老年代的单线程Serial收集器，采用标记-整理算法，主要是给Client模式下的虚拟机使用。\n3.6.5 Parallel Old收集器 ​\t其是一个应用于老年代的并行垃圾回收器，采用标记-整理算法。在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器。\n3.6.6 CMS垃圾收集器 ​\tCMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。\nCMS垃圾回收器的执行过程如下：\n1)初始标记(Initial Mark)：仅仅标记GC Roots能直接关联到的对象，速度快，但是需要“Stop The World”\n2)并发标记(Concurrent Mark)：就是进行追踪引用链的过程，可以和用户线程并发执行。\n3)重新标记(Remark)：修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要“Stop The World”\n4)并发清除(Concurrent Sweep)：清除标记为可以回收对象，可以和用户线程并发执行\n​\t由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS收集器的内存回收过程和用户线程是并发执行的。\n3.6.7 G1垃圾收集器 3.6.7.1 概述 ​\t对于垃圾回收器来说，前面的三种要么一次性回收年轻代，要么一次性回收老年代。而且现代服务器的堆空间已经可以很大了。为了更加优化GC操作，所以出现了G1。\n​\t它是一款**同时应用于新生代和老年代、采用标记-整理算法、软实时、低延迟、可设定目标(最大STW停顿时间)**的垃圾回收器，用于代替CMS，适用于较大的堆(\u0026gt;4~6G)，在JDK9之后默认使用G1。\n3.6.7.2 G1的内存布局 ​\tG1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分。\n​\t取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。\n​\t此时可以看到，现在出现了一个新的区域Humongous，它本身属于老年代区。当现在出现了一个巨大的对象，超出了分区容量的一半，则这个对象会进入到该区域。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区 ，有时候不得不启动Full GC。\n​\t同时G1会估计每个Region中的垃圾比例，优先回收垃圾较多的区域。\n​\t在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。\n​\t这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。\n3.6.7.3 垃圾回收模式 其提供了三种模式垃圾回收模式： young GC、Mixed GC、Full GC。在不同的条件下被触发。\nYoung GC\n​\t发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。\nMixed GC\n​\t当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。\n​\t在CMS中，当老年代的使用率达到80%就会触发一次cms gc。在G1中，mixed gc也可以通过-XX:InitiatingHeapOccupancyPercent设置阈值，默认为45%。当老年代大小占整个堆大小百分比达到该阈值，则触发mixed gc。\n其执行过程和cms类似：\ninitial mark: 初始标记过程，整个过程STW，标记了从GC Root可达的对象。 concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息。 remark: 最终标记过程，整个过程STW，标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对象。 clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中。 Full GC ​\t如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.\n3.7 Minor GC、Major GC、Full GC是什么 难易程度：☆☆\n出现频率：☆☆\nMinor GC 发生在新生代的垃圾回收，暂停时间短\nMajor GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长\nFull GC 新生代 + 老年代完整垃圾回收，暂停时间长，应尽力避免\n4 JVM实践（调优） 4.1 JVM 调优的参数可以在哪里设置参数值？ 难易程度：☆☆\n出现频率：☆☆☆\n4.1.1 tomcat的设置vm参数 修改TOMCAT_HOME/bin/catalina.sh文件，如下图\nJAVA_OPTS=\u0026quot;-Xms512m -Xmx1024m\u0026quot; 4.1.2 springboot项目jar文件启动 通常在linux系统下直接加参数启动springboot项目\n1 nohup java -Xms512m -Xmx1024m -jar xxxx.jar --spring.profiles.active=prod \u0026amp; nohup : 用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行\n参数 \u0026amp; ：让命令在后台执行，终端退出后命令仍旧执行。\n4.2 用的 JVM 调优的参数都有哪些？ 难易程度：☆☆☆\n出现频率：☆☆☆☆\n​\t对于JVM调优，主要就是调整年轻代、年老大、元空间的内存空间大小及使用的垃圾回收器类型。\nhttps://www.oracle.com/java/technologies/javase/vmoptions-jsp.html\n1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。\n1 2 3 -Xms：设置堆的初始化大小 -Xmx：设置堆的最大大小 2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满\n的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。\n1 -XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3 3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。\n1 2 -XX:newSize 设置年轻代的初始大小 -XX:MaxNewSize 设置年轻代的最大大小， 初始大小和最大大小两个值通常相同 4）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。\n1 -Xss 对每个线程stack大小的调整,-Xss128k 5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小\n6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。\n7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-XX:PetenureSizeThreshold=1000000，单位为B，标明对象大小超过1M时，在老年代(tenured)分配内存空间。\n8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。\n1 2 3 （1）-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。 （2）-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。 9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。\n1 -XX:+LargePageSizeInBytes 设置内存页的大小 10）使用非占用的垃圾收集器。\n1 -XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。 4.3 说一下 JVM 调优的工具？ 难易程度：☆☆☆☆\n出现频率：☆☆☆☆\n4.3.1 命令工具 4.3.1.1 jps（Java Process Status） 输出JVM中运行的进程状态信息(现在一般使用jconsole)\n4.3.1.2 jstack 查看java进程内线程的堆栈信息。\n1 jstack [option] \u0026lt;pid\u0026gt; java案例\n1 2 3 4 5 6 7 8 9 10 11 package com.heima.jvm; public class Application { public static void main(String[] args) throws InterruptedException { while (true){ Thread.sleep(1000); System.out.println(\u0026#34;哈哈哈\u0026#34;); } } } 使用jstack查看进行堆栈运行信息\n4.3.1.3 jmap 用于生成堆转存快照\njmap [options] pid 内存映像信息\njmap -heap pid 显示Java堆的信息\njmap -dump format=b,file=heap.hprof pid\n​\tformat=b表示以hprof二进制格式转储Java堆的内存 ​\tfile=用于指定快照dump文件的文件名。\n例1，显示了某一个java运行的堆信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 C:\\Users\\yuhon\u0026gt;jmap -heap 53280 Attaching to process ID 53280, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.321-b07 using thread-local object allocation. Parallel GC with 8 thread(s) //并行的垃圾回收器 Heap Configuration: //堆配置 MinHeapFreeRatio = 0 //空闲堆空间的最小百分比 MaxHeapFreeRatio = 100 //空闲堆空间的最大百分比 MaxHeapSize = 8524922880 (8130.0MB) //堆空间允许的最大值 NewSize = 178257920 (170.0MB) //新生代堆空间的默认值 MaxNewSize = 2841640960 (2710.0MB) //新生代堆空间允许的最大值 OldSize = 356515840 (340.0MB) //老年代堆空间的默认值 NewRatio = 2 //新生代与老年代的堆空间比值，表示新生代：老年代=1：2 SurvivorRatio = 8 //两个Survivor区和Eden区的堆空间比值为8,表示S0:S1:Eden=1:1:8 MetaspaceSize = 21807104 (20.796875MB) //元空间的默认值 CompressedClassSpaceSize = 1073741824 (1024.0MB) //压缩类使用空间大小 MaxMetaspaceSize = 17592186044415 MB //元空间允许的最大值 G1HeapRegionSize = 0 (0.0MB)//在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。 Heap Usage: PS Young Generation Eden Space: //Eden使用情况 capacity = 134217728 (128.0MB) used = 10737496 (10.240074157714844MB) free = 123480232 (117.75992584228516MB) 8.000057935714722% used From Space: //Survivor-From 使用情况 capacity = 22020096 (21.0MB) used = 0 (0.0MB) free = 22020096 (21.0MB) 0.0% used To Space: //Survivor-To 使用情况 capacity = 22020096 (21.0MB) used = 0 (0.0MB) free = 22020096 (21.0MB) 0.0% used PS Old Generation //老年代 使用情况 capacity = 356515840 (340.0MB) used = 0 (0.0MB) free = 356515840 (340.0MB) 0.0% used 3185 interned Strings occupying 261264 bytes. 4.3.1.4 jhat 用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）\n4.3.1.5 jstat 是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。\n常见参数：\n①总结垃圾回收统计\n1 jstat -gcutil pid 字段 含义 S0 幸存1区当前使用比例 S1 幸存2区当前使用比例 E 伊甸园区使用比例 O 老年代使用比例 M 元数据区使用比例 CCS 压缩使用比例 YGC 年轻代垃圾回收次数 YGCT 年轻代垃圾回收消耗时间 FGC 老年代垃圾回收次数 FGCT 老年代垃圾回收消耗时间 GCT 垃圾回收消耗总时间 ②垃圾回收统计\n1 jstat -gc pid 4.3.2 可视化工具 4.3.2.1 jconsole 用于对jvm的内存，线程，类 的监控，是一个基于 jmx 的 GUI 性能监控工具\n打开方式：java 安装目录 bin目录下 直接启动 jconsole.exe 就行\n可以内存、线程、类等信息\n4.3.2.2 VisualVM：故障处理工具 能够监控线程，内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈\n打开方式：java 安装目录 bin目录下 直接启动 jvisualvm.exe就行\n监控程序运行情况\n查看运行中的dump\n查看堆中的信息\n4.4 java内存泄露的排查思路？ 难易程度：☆☆☆☆\n出现频率：☆☆☆☆\n1、通过jmap指定打印他的内存快照 dump\n有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：\n-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/app/dumps/ 指定生成后文件的保存目录\n2、通过工具， VisualVM（Ecplise MAT）去分析 dump文件\nVisualVM可以加载离线的dump文件，如下图\n文件\u0026ndash;\u0026gt;装入\u0026mdash;\u0026gt;选择dump文件即可查看堆快照信息\n如果是linux系统中的程序，则需要把dump文件下载到本地（windows环境）下，打开VisualVM工具分析。VisualVM目前只支持在windows环境下运行可视化\n3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题\n4、找到对应的代码，通过阅读上下文的情况，进行修复即可\n4.5 CPU飙高排查方案与思路？ 难易程度：☆☆☆☆\n出现频率：☆☆☆☆\n1.使用top命令查看占用cpu的情况\n2.通过top命令查看后，可以查看是哪一个进程占用cpu较高，上图所示的进程为：30978\n3.查看当前线程中的进程信息\n1 ps H -eo pid,tid,%cpu | grep 30978 pid 进行id\ntid 进程中的线程id\n% cpu使用率\n4.通过上图分析，在进程30978中的线程30979占用cpu较高\n注意：上述的线程id是一个十进制，我们需要把这个线程id转换为16进制才行，因为通常在日志中展示的都是16进制的线程id名称\n转换方式：\n在linux中执行命令\nprintf \u0026quot;%x\\n\u0026quot; 30979\n5.可以根据线程 id 找到有问题的线程，进一步定位到问题代码的源码行号\n执行命令\n1 jstack 30978 此处是进程id 5.面试现场 5.1 JVM组成 面试官：JVM由那些部分组成，运行流程是什么？\n候选人:\n嗯，好的~~\n在JVM中共有四大部分，分别是ClassLoader（类加载器）、Runtime Data Area（运行时数据区，内存分区）、Execution Engine（执行引擎）、Native Method Library（本地库接口）\n它们的运行流程是：\n第一，类加载器（ClassLoader）把Java代码转换为字节码\n第二，运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行\n第三，执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。\n面试官：好的，你能详细说一下 JVM 运行时数据区吗？\n候选人:\n嗯，好~\n运行时数据区包含了堆、方法区、栈、本地方法栈、程序计数器这几部分，每个功能作用不一样。\n堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。 方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。 栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。 本地方法栈与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。 程序计数器（PC寄存器）程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。 面试官：好的，你再详细介绍一下程序计数器的作用？\n候选人:\n嗯，是这样~~\njava虚拟机对于多线程是通过线程轮流切换并且分配线程执行时间。在任何的一个时间点上，一个处理器只会处理执行一个线程，如果当前被执行的这个线程它所分配的执行时间用完了【挂起】。处理器会切换到另外的一个线程上来进行执行。并且这个线程的执行时间用完了，接着处理器就会又来执行被挂起的这个线程。这时候程序计数器就起到了关键作用，程序计数器在来回切换的线程中记录他上一次执行的行号，然后接着继续向下执行。\n面试官：你能给我详细的介绍Java堆吗?\n候选人:\n好的~\nJava中的堆术语线程共享的区域。主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。\n​\t在JAVA8中堆内会存在年轻代、老年代\n​\t1）Young区被划分为三部分，Eden区和两个大小严格相同的Survivor区，其中，Survivor区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用。在Eden区变满的时候， GC就会将存活的对象移到空闲的Survivor区间中，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到Tenured区间。\n​\t2）Tenured区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在Young复制转移一定的次数以后，对象就会被转移到Tenured区。\n面试官：能不能解释一下方法区？\n候选人:\n好的~\n与虚拟机栈类似。本地方法栈是为虚拟机执行本地方法时提供服务的。不需要进行GC。本地方法一般是由其他语言编写。\n面试官：你听过直接内存吗？\n候选人:\n嗯~~\n它又叫做堆外内存，线程共享的区域，在 Java 8 之前有个永久代的概念，实际上指的是 HotSpot 虚拟机上的永久代，它用永久代实现了 JVM 规范定义的方法区功能，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 -XX:MaxPermSize 的上限，所以如果大量动态生成类（将类信息放入永久代），很容易造成 OOM，有人说可以把永久代设置得足够大，但很难确定一个合适的大小，受类数量，常量数量的多少影响很大。\n​\t所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了,也就不会进行 GC，也因此提升了性能。\n面试官：什么是虚拟机栈\n候选人:\n虚拟机栈是描述的是方法执行时的内存模型,是线程私有的，生命周期与线程相同,每个方法被执行的同时会创建栈桢。保存执行方法时的局部变量、动态连接信息、方法返回地址信息等等。方法开始执行的时候会进栈，方法执行完会出栈【相当于清空了数据】，所以这块区域不需要进行 GC。\n面试官：能说一下堆栈的区别是什么吗？\n候选人:\n嗯，好的，有这几个区别\n第一，栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。\n第二、栈内存是线程私有的，而堆内存是线程共有的。\n第三、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。\n栈空间不足：java.lang.StackOverFlowError。\n堆空间不足：java.lang.OutOfMemoryError。\n5.2 类加载器 面试官：什么是类加载器，类加载器有哪些?\n候选人:\n嗯，是这样的\nJVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。\n常见的类加载器有4个\n第一个是启动类加载器(BootStrap ClassLoader)：其是由C++编写实现。用于加载JAVA_HOME/jre/lib目录下的类库。\n第二个是扩展类加载器(ExtClassLoader)：该类是ClassLoader的子类，主要加载JAVA_HOME/jre/lib/ext目录中的类库。\n第三个是应用类加载器(AppClassLoader)：该类是ClassLoader的子类，主要用于加载classPath下的类，也就是加载开发者自己编写的Java类。\n第四个是自定义类加载器：开发者自定义类继承ClassLoader，实现自定义类加载规则。\n面试官：说一下类装载的执行过程？\n候选人:\n嗯，这个过程还是挺多的。\n类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）\n1.加载：查找和导入class文件\n2.验证：保证加载类的准确性\n3.准备：为类变量分配内存并设置类变量初始值\n4.解析：把类中的符号引用转换为直接引用\n5.初始化：对类的静态变量，静态代码块执行初始化操作\n6.使用：JVM 开始从入口方法开始执行用户的程序代码\n7.卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存\n面试官：什么是双亲委派模型？\n候选人:\n嗯，它是是这样的。\n如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载\n面试官：JVM为什么采用双亲委派机制\n候选人:\n主要有两个原因。\n第一、通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。\n第二、为了安全，保证类库API不会被修改\n5.3 垃圾回收 面试官：简述Java垃圾回收机制？（GC是什么？为什么要GC）\n候选人:\n嗯，是这样~~\n为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC(Garbage Collection)。\n有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。\n在进行垃圾回收时，不同的对象引用类型，GC会采用不同的回收时机\n面试官：强引用、软引用、弱引用、虚引用的区别？\n候选人:\n嗯嗯~\n强引用最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收\n软引用表示一个对象处于有用且非必须状态，如果一个对象处于软引用，在内存空间足够的情况下，GC机制并不会回收它，而在内存空间不足时，则会在OOM异常出现之间对其进行回收。但值得注意的是，因为GC线程优先级较低，软引用并不会立即被回收。\n弱引用表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收。同样的，因为GC线程优先级较低，所以弱引用也并不是会被立刻回收。\n虚引用表示一个对象处于无用的状态。在任何时候都有可能被垃圾回收。虚引用的使用必须和引用队列Reference Queue联合使用\n面试官：对象什么时候可以被垃圾器回收\n候选人:\n思考一会~~\n如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。\n如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法\n通常都使用可达性分析算法来确定是不是垃圾\n面试官： JVM 垃圾回收算法有哪些？\n候选人:\n我记得一共有四种，分别是标记清除算法、复制算法、标记整理算法、分代回收\n面试官： 你能详细聊一下分代回收吗？\n候选人:\n关于分代回收是这样的\n在java8时，堆被分为了两份：新生代和老年代，它们默认空间占用比例是1:2\n对于新生代，内部又被分为了三个区域。Eden区，S0区，S1区默认空间占用比例是8:1:1\n具体的工作机制是有些情况：\n1）当创建一个对象的时候，那么这个对象会被分配在新生代的Eden区。当Eden区要满了时候，触发YoungGC。\n2）当进行YoungGC后，此时在Eden区存活的对象被移动到S0区，并且当前对象的年龄会加1，清空Eden区。\n3）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S0中的对象，移动到S1区中，这些对象的年龄会加1，清空Eden区和S0区。\n4）当再一次触发YoungGC的时候，会把Eden区中存活下来的对象和S1中的对象，移动到S0区中，这些对象的年龄会加1，清空Eden区和S1区。\n5）对象的年龄达到了某一个限定的值（默认15岁 ），那么这个对象就会进入到老年代中。\n当然也有特殊情况，如果进入Eden区的是一个大对象，在触发YoungGC的时候，会直接存放到老年代\n当老年代满了之后，触发FullGC。FullGC同时回收新生代和老年代，当前只会存在一个FullGC的线程进行执行，其他的线程全部会被挂起。 我们在程序中要尽量避免FullGC的出现。\n面试官：讲一下新生代、老年代、永久代的区别？\n候选人:\n嗯！是这样的，简单说就是\n新生代主要用来存放新生的对象。\n老年代主要存放应用中生命周期长的内存对象。\n永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。元空间和永久代类似，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。\n面试官：说一下 JVM 有哪些垃圾回收器？\n候选人:\n在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器（JDK8默认）、CMS（并发）垃圾收集器、G1垃圾收集器（JDK9默认）\n面试官：Minor GC、Major GC、Full GC是什么\n候选人:\n嗯，其实它们指的是不同代之间的垃圾回收\nMinor GC 发生在新生代的垃圾回收，暂停时间短\nMajor GC 老年代区域的垃圾回收，老年代空间不足时，会先尝试触发Minor GC。Minor GC之后空间还不足，则会触发Major GC，Major GC速度比较慢，暂停时间长\nFull GC 新生代 + 老年代完整垃圾回收，暂停时间长，应尽力避免\n5.4 JVM实践（调优） 面试官：JVM 调优的参数可以在哪里设置参数值？\n候选人:\n我们当时的项目是springboot项目，可以在项目启动的时候，java -jar中加入参数就行了\n面试官：用的 JVM 调优的参数都有哪些？\n候选人:\n嗯，这些参数是比较多的\n我记得当时我们设置过堆的大小，像-Xms和-Xmx\n还有就是可以设置年轻代中Eden区和两个Survivor区的大小比例\n还有就是可以设置使用哪种垃圾回收器等等。具体的指令还真记不太清楚。\n面试官：嗯，好的，你们平时调试 JVM都用了哪些工具呢？\n候选人:\n嗯，我们一般都是使用jdk自带的一些工具，比如\njps 输出JVM中运行的进程状态信息\njstack查看java进程内线程的堆栈信息。\njmap 用于生成堆转存快照\njstat用于JVM统计监测工具\n还有一些可视化工具，像jconsole和VisualVM等\n面试官：假如项目中产生了java内存泄露，你说一下你的排查思路？\n候选人:\n嗯，这个我在之前项目排查过\n第一呢可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置vm参数让程序自动生成dump文件\n第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析\n第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题\n第四，找到对应的代码，通过阅读上下文的情况，进行修复即可\n面试官：好的，那现在再来说一种情况，就是说服务器CPU持续飙高，你的排查方案与思路？\n候选人:\n嗯，我思考一下~~\n可以这么做~~\n第一可以使用使用top命令查看占用cpu的情况\n第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id\n第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高\n第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号\n","date":"2024-11-09T16:02:00+08:00","permalink":"https://example.com/p/jvm%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"JVM相关面试题"},{"content":"每日八股 本文档只记录答题思路，旨在当面试时遇到时能快速切入重点，然后灵活的组织语言回答问题。同时，为了回答的流畅性，应当尽可能的学会怎么读这些英文单词，用英文表达\nday1 Q1：微服务你用到了那些中间件 这张图的演变能非常好的描述我们单体结构向微服务转变过程\n如果可以，请从单体向微服务架构转变的思路来回答每个中间件对应的职责（跟面试官说你在公司经历过单体项目向微服务转型的过程，希望以此出发展开回答）\n单体的耦合度太高，同时无法很好的承载高并发，简单的水平拓展成本过高（也不治本），需要拆分服务 而服务与服务之间需要远程调用，需要统一的注册中心和配置中心（人工维护太繁琐） 服务于服务之间的调用，并不必须同步，可以采取引入消息队列完成异步调用 用户的请求需要统一的服务网关来路由（注意这里路由是个动词），以及负载均衡，拦截增强（比如鉴权） 服务集群的增长，带来了更多的数据，对我们的数据、缓存有更高的挑战，所以需要分布式缓存、分库分表、分布式搜索 集群规模增大带来，debug不局限于某一台服务，需要分布式日志服务和系统监控链路追踪 引入自动化部署（DevOps）来做到持续开发、持续交付，降低部署维护成本 有了演变过程，哪些中间件做哪些事情，自然就有了答案\n思考一个问题：假如一个交易平台对于订单需要严格的排序，需要一个定序系统来生产一个全局唯一的序列号，请问这种情况时候还能做水平拓展？如何容灾？设计定序系统 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)（看文末的**如何在定序器崩溃后自动恢复？**问题，拓展抢锁）\nQ2：Nacos注册中心的心跳机制 注册中心、心跳检测（ping pong）\n每个加入nacos的服务都会注册自己信息以及定时拉取服务列表（why？for rpc）\n注册到nacos的服务以及nacos本身都需要通过主动或者被动的方式维持自己的存活（主动上报或是主动询问）\n类似场景拓展：Websocket (kookapp.cn)（看连接流程、重连、连接流程示意图即可）\nQ3：常见的负载均衡算法 轮询、权重、响应时间\nQ4：ThreadLocal 看成一个全局Map\u0026lt;Thread, Object\u0026gt;\n线程池复用会带来污染\nSpring是否也需要考虑相关问题\n基本概念 实际上，可以把ThreadLocal看成一个全局Map\u0026lt;Thread, Object\u0026gt;：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：\n因此，ThreadLocal相当于给每个线程都开辟了一个独立的存储空间（上下文语境，学点高级词汇），各个线程的ThreadLocal关联的实例互不干扰。\n最后，特别注意ThreadLocal一定要在finally中remove！！！！\n拓展（问就是看过了SpringMVC源码） 清除非常重要，为什么？线程池复用会带来污染\n再想一个问题，我们有这样的问题需要使用ThreadLocal，Spring是否也需要？结合SpringMVC执行流程\nSpringMVC把每一个请求交给一个独立的线程处理，内部同样用到了线程池、ThreadLocal。\nDispatcherServlet和RequestContextHolder（注意context这个单词，就是内容或则说上下文的意思）\nRequestContextHolder会存储请求和响应的相关消息，也就是一个请求的上下文，所以毫无疑问SpringMVC同样有使用到ThreadLocal\nQ5：聚集索引和非聚集索引 数据和索引在一起存储\n数据和索引不在一起\n主动提及回表查询和覆盖查询、索引的维护有代价\nQ6：如何定位慢查询 注意慢查询和慢sql\n前端：静态资源丢失\n后端：\nredis缓存\nMQ积压\n数据库：\n慢日志 explain key key_length rows extra type 主动提及索引失效的场景\nQ7：Java的Map 基本\nHashMap的七七八八，你们懂的\n拓展\nHashMap/WeakHashMap优化枚举类预加载（弱引用、垃圾回收器）\n这里讲讲HashMap/WeakHashMap优化枚举类预加载\n首先，我们使用枚举类往往无法避免valueOf()操作，但这个操作是O(n)的，对这个操作非常常见的优化就是通过static静态代码块在类加载的时候把它们加载到一个Map中，也就是缓存，可以优化查找速度到O(1)。\n用WeakHashMap的原因，就是为了避免OOM（以及把面试官往JVM引导）\nday2 今天务必要去看一看JVM（看看，挑简单的记，复杂的记大纲），后面的时间可能很难沉下心来去理解，JVM重点关注内存模型和垃圾回收器\n设计模式 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)\n工厂方法设计模式 (refactoringguru.cn)\nQ1：GataWay实现原理 GataWay三大作用\n作用\n路由（网关就是看门老大爷）、负载（分清楚网关负载和服务调用负载的区别）、拦截（注意拦截范围和之前的拦截器更大） 实现原理\nSpring WebFlux、Netty（和传统Servlet有什么区别） 结合作用讲请求到网关到具体的服务的流程 Q2：你们项目中的远程调用用的什么技术 务必理解当前我们的远程调用就是http请求，那么对于一个http请求我们需要封装交给httpClient发送请求并接收响应\n这种调用往往是同步的，我们还会需要消息队列来达成一些异步调用的操作\nopenFeign、底层是http客户端、dubbo\nQ3：JVM的组成 主要组成部分（不会就硬背）\n组成部分\n类加载器\n运行时数据区\n方法区\n用于存储已被加载的类的信息\n堆\nJVM 管理的最大的一块内存区域，被所有线程共享。用于存储对象实例和数组，几乎所有的对象实例和数组都是在堆中分配内存的。（和垃圾回收器有关）\n程序计数器\n当前线程所执行的字节码的行号指示器（学过计组的话会有类似概念）\n虚拟机栈\n执行引擎\n两种执行方式\n解释执行：一条一条地读取字节码指令并执行 即时编译：将热点代码编译成机器码，提高执行效率 示例：在一个简单的 Java 循环语句中，刚开始执行时可能是通过解释执行，当循环执行次数足够多，被判定为热点代码后，执行引擎就会对这个循环部分进行即时编译，之后再执行这个循环时就会以更快的机器码形式执行。\n本地库接口\n使得Java能调用Native Method Library（java源码中如果见到native往往指的就是c相关的东西）中的函数\n该文章在字节码的层面分析了异常处理，可以看看，作为了解JVM的一个开头\nJava异常处理和最佳实践（含案例分析）-阿里云开发者社区 (aliyun.com)\nQ4：类加载机制(AI来的，详情大家自己ai) 五个过程、三种类加载器（简称五过三类），不行就背小标题\n五个过程\n加载（loading）\n查找并读取类的字节码文件\n三个加载器\n双亲委派模型（避免用户自定义的类覆盖Java核心类库的类）\n类加载器收到类加载请求时先找它的父类加载器，再找子加载器 验证（verification）\n确保符合 Java 虚拟机规范\n准备（preparation）\n为类的静态变量分配内存并设置初始值\n解析（resolution）\n将类、方法、字段等的符号引用转换为直接引用（便于快速访问）\n初始化（initialization）\n主要是执行类的初始化代码\n三种类加载器\n启动类加载器（JVM的启动）\nJVM内置，负责加载Java核心类库\n拓展类加载器\n负责加载拓展类库\n应用程序类加载器\n负责加载classpath下的类\nQ5：垃圾回收器有哪些，你们项目用的是什么 G1、CMS，我们用的G1\n1.9开始默认是G1\n先了解GC相关的概念如：FullGC、YoungGC、分代收集、STW\n要了解相关配置参数如：\n-XX:G1HeapRegionSize=n指定分区大小 -XX:G1NewSizePercent设置年轻代在堆中占比 -XX:MaxGCPauseMillis指定回收时最大暂停时间（G1和CMS不同的点很大程度在于G1是规定时间内尽力完成回收：软实时性）这是最重要的参数之一（只记一个那就记这个） 。。。 分代收集算法（见3.4.4 分代收集算法，先了解，明天背）\nQ6：JVM内存模型（JMM） JUC（8）JMM-阿里云开发者社区 (aliyun.com)\n俩内存、三关键字\n主内存\n线程共享\n工作内存\n线程独有，存储对共享变量的副本（注意是副本）\n指令重排序导致数据不一致\n使用volatile修饰变量，确保变量的修改立即对其他线程可见\nday3 看设计模式，有时间看看springMVC源码\nMVC高级开发 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)\nredis面试题选自航哥面试专题\nQ1：Docker部署和常用指令 部署：dockerfile和dockercompose\n镜像、容器、数据卷、dockerfile、dockercompose\n镜像pull、push，docker images，还有docker rmi；还有容器相关的docker run，docker start、docker stop，进入容器的docker exec -it 容器名称 bash，查看日志的docker logs。\nQ2：linux指令 chmod、cat info.log | grep \u0026lsquo;关键字\u0026rsquo;\nQ3：都有哪些设计模式，用过哪些，具体场景？ 经典的面向对象设计模式：三大类型、23种\n还有领域驱动模型（DDD）：先当成思想和沟通语言去理解（通用语言和限界上下文）\nDDD基础教程：一文带你读懂DDD分层架构-阿里云开发者社区 (aliyun.com)\n创建型模式\n工厂模式 原型 单例 结构型模式\n适配器 代理 行为型模式\n责任链（filter）\n责任链模式是一种把多个处理器组合在一起，依次处理请求的模式\n命令\n把请求封装成一个命令，然后执行该命令。\n解释器\n给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n中介\n目的是把多方会谈变成双方会谈，从而实现多方的松耦合。\n观察者模式（发布订阅模式）\n状态\n模板方法（template）\nDDD\n了解的不多，但可以在开发和沟通的时候带着领域驱动思想去帮助我思考问题，比如 通用语言：规定整个项目组（包括开发和产品）当前项目的名词（比如zzyl的PRD的前几页有对护理等级的定义和解释），帮助项目组提高沟通效率（但学习成本相应地提高） 限界上下文：限界上下文是一个显式的语义和语境上的边界，领域模型便存在于边界之内。 聚合、聚合根： 充血模型、贫血模型 总的来说DDD不是我们现阶段需要重点关注的，但是能够带着它的思想去开发、分析需求绝对是能体现出个人开发经验的\nQ4：Redis数据类型 结合自己业务说，如：云岚面试第八章抢券业务的Redis数据结构用的什么？具体说说\nQ5：Redis三剑客以及如何解决 击穿、穿透、雪崩\n不用背八股文！一文搞懂redis缓存击穿、穿透、雪崩！-腾讯云开发者社区-腾讯云 (tencent.com)\n击穿：（热点数据过期导致大量请求直接打到数据库） 热点数据即将过期时，提前异步更新缓存 设置热点数据永不过期（谨慎使用） 穿透：（查询一个数据库不存在的值导致每次都要查询数据库，恶意请求） 缓存空值 布隆过滤器，底层是bitmap（查询数据时，先通过布隆过滤器判断键是否可能存在，如果不存在就直接返回空值） 雪崩：短时间大量的key同时失效 key：固定+随机时间 缓存预热 redis架构升级 Q6：Redis数据持久化 RDB和AOF\nRDB\n对redis生成快照（二进制文件），非常快，但有数据丢失风险\nAOF\n将每个写命令追加到AOF文件末尾，恢复时重新执行这些命令 同步策略 always everysec（默认这个） no Q7：redis集群方案 主从复制、哨兵模式、分片\n主从：降低读写压力\n哨兵模式：故障恢复（这里有个哨兵选举流程需要展开）\n分片：提高存储上限（hash插槽分配原理）\nQ8：springmvc执行流程和常用注解 结合d1q4的拓展点\nday4 看MQ、云岚秒杀、优惠卷\nQ1：什么场景下你们用MQ 其实就是是否理解异步和同步，以及有它的优点\n扯到异步调用的时候可以去带过一下其他的消息中间件\n同步\n异步\n异步通信优点\n耦合度低 吞吐量提升 故障隔离 流量削峰 缺点\n依赖于Broker（消息服务器）的可靠性、安全性、吞吐能力 架构复杂了，业务没有明显的流程线，不好追踪管理 Q2：你们项目为什么用MQ Q3：MQ有哪几种交换机模式，你们用的哪种 FanoutExchanage DirectExchanage TopicExchanage Q4：MQ如何保证消息不丢失 分为三种情况，发送端、MQ自己、消费端\n6-MQ篇 (yuque.com)\n发布者确认机制 发布者回执机制 MQ持久化 消费者确认机制，消费者失败重试机制 进一步的放丢失方案\nQ5：消息积压如何解决 提高消费能力 增加消费者 扩大队列容积（LazyQueue） Q6：RabbitMQ如何保证消费的顺序性 ? Q7：SpringIOC IOC的俩种实现\n相关问题：Bean的生命周期\nBeanFactory ApplicationContext Q8：SpringAOP CGLIB和JDK的动态代理\n相关问题：AOP相关注解\nQ9：三级缓存（循环依赖） Spring三级缓存主要是为了优雅的解决循环依赖的问题，同时也能通过缓存提高性能\n一级缓存\n存储完全初始化好的单例bean（已经注入所有的属性，完成初始化方法的操作） 是一个ConcurrentHashMap\u0026lt;String, Object\u0026gt;，Key是Bean名称，Value是Bean实例 二级缓存\n存储早期创建的单例bean，还没有完成所有的初始化，但已经可以被其他bean引用。 数据结构同一级缓存 三级缓存\n存储的是创建Bean的工厂对象 数据结构是一个ConcurrentHashMap\u0026lt;String, Object\u0026gt;，键是 Bean 的名称，值是ObjectFactory对象 以一个例子来说明三级缓存的执行流程：Bean A、Bean B存在A依赖B，B依赖A的情况，此时\nA的创建过程 Spring开始创建A的时候，会先检查一级缓存，发现没有A，然后开始实例化A（调用A的构造函数） 实例化A后，发现A存在循环依赖的问题，于是把A的工厂对象放入三级缓存中 然后Spring给A注入属性，发现需要注入B（且三级缓存中没有B的工厂对象），就暂停A的创建，开始创建B B的创建 创建B时，先看一级缓存，没有，调用构造函数实例化 返现B循环依赖，把B的工厂对象放入三级缓存 当给B注入属性时，发现需要A，就去一级缓存找，没有就找二级缓存，也没有就找到三级缓存中A的工厂对象，通过这个工厂对象获取A的早期实例，然后将A放入二级缓存 此时B完成创建，放入一级缓存 回到A，A从一级缓存中拿到B，完成创建，放入一级缓存 简单来说，就是B拿了个A的套壳，完成了创建放入一级缓存，然后A就能顺利创建，此时B拿的A也完成了创建\nQ10：设计模式 Q11：事务失效场景 Q12：MQ消息可靠性 Q13：消息幂等性 参照本博客云岚到家的\n+++\nq1：服务保护\nSentinel、GateWay、MQ削峰填谷\nq2：用什么做单元测试\nJunit、MockITO\nday5 MQ+点赞\nQ1：怎么保证MQ消息不丢失 三个点\n额外的保证，失败消息落库，定时任务重投，超过重投次数转人工\n生产者确认机制（每个消息指定为一ID）\npublish-confirm：消息是否到交换机 publish-return：消息是否到队列 MQ消息持久化防止MQ宕机\nMQ自身做了队列持久化、消息持久化、交换机持久化 消费者确认机制\n消费者获取消息并处理消息后发送ACK回执 一般auto ack，spring根据是否有异常帮我们决定是ack还是nack Q2：了解过MQ的延迟消息吗 延迟消息通过官方插件可以实现\n过去我们做过一些取消超时订单的业务场景有实施过这个方案\nQ3：那你讲讲取消超时订单的方案 RabbitMQ延迟消息、redis过期时间、定时任务（xxljob）\n关于RabbitMQ延迟消息\n创建订单时，发送一个带有延迟时间的消息到mq的延迟队列，当延迟时间结束，就会把消息投到对应的目标队列 关于redis过期时间的方案\nredis的键可以设置过期时间。当订单创建的时候，以订单ID为键存到redis。 当键过期时，通过redis的过期回调机制、或者定时扫描过期键的方式来触发取消订单的操作 xxljob定时任务操订单表，查是否超时，触发取消逻辑\n还可以懒加载的形式触发取消\nQ4：如何解决消息积压 提高消费速度，增加更多消费者 扩容（最终方案） Q5：redis的set和zset 通过这个问题去了解set和zset的数据结构如何\nreidis的set：\n以商品id为key，也是就是说，一个商品id对应一个set\nvalue存的是点赞用户的id，set里面包含多个userid表示给这个商品点赞的用户，这样就是实现了不重复。\nredis的zset：以点赞为例子，\n有给文章点赞的，有给评论点赞的，一个点赞类型对应一个zset，key就是：like:wz(业务也是就点赞+类型也就是文章) 以文章的点赞为例，有多个文章，那么zset的member就存的是文章id，score就是它的点赞数 Q6：点赞服务设计 先介绍总体设计，然后是消息发送和订阅的交换机队列模型，最后是流程（介绍redis的缓存set点赞，zset点赞数）\n思考问题：同时点赞怎么办，同时一个点赞一个取消怎么办\n总体设计：\n点赞是一个通用服务，不同的系统都需要点赞数，比如我们的商品需要点赞数，评论需要点赞数 为了满足点赞的高频写入特点，点赞系统只记录点赞本身的行为数据，对于业务的统计，都交给业务方存储 为了满足点赞的通用性，我们通过异步的方式，用MQ发布点赞消息（direct、topic交换机），点赞消息包含业务id和点赞数量 然后是MQ模型的设计（交换机，bingkey）\n最后是整个流程（redis的set、zset设计在上一题）\n用户点赞触发流程开始，前端提交点赞信息给我们后端， 查询redis缓存看当前这个key（假设是一个文章id）下的member（用户id）是否存在，不存在就新增（俩个线程同时触发点赞，开始都没查到member存在，但写入的时候因为set去重只会有一个写入，所以这里已经实现了幂等） 统计点赞数量，写到zset里面，通过定时读取缓存的任务发送到mq交给下流业务费统计 Q7：定时任务这里为什么要删除bizid和点赞总数 为了每次推送的都是变化量，同时可以防止内存溢出\nQ8：同时点赞怎么办 首先点赞被触发两次其实问题不大，只要记录数对了，就可以，set既然已经完成去重\nQ9：同时点赞和取消点赞怎么办 明确这个问题的后果是什么：可能是先执行点赞后取消也可能先取消后点赞，那么对应同一个操作（把这个操作看作（点赞，取消点赞，时间）为一个操作）会对应俩种结果\nRedis pipelining\n这里做了合并写的处理 分布式锁\n用业务id（文章id、商品id）作为键，生成一个锁标识（比如UUID）。可以使用SETNX命令，如果返回1表示成功获取锁，返回0表示锁被占用 Q10：每次点赞成功都会触发查询点赞统计总数，如何优化 Redis pipelining通过批处理redis命令来优化往返时间\nRedis pipelining通过一次发出多个命令而无需等待对每个单独命令的响应来提高性能的技术\n这里还可能涉及到的问题：\nredis容量的问题 redis持久化频率的问题 redis相关命令 day6 redis、mysql相关问题再来一遍\n优惠卷\nQ1：缓存一致性 ","date":"2024-11-09T16:02:00+08:00","permalink":"https://example.com/p/%E6%AF%8F%E6%97%A5%E5%85%AB%E8%82%A1/","title":"每日八股"},{"content":"MQ 发送者的可靠性 MQ可靠性 数据持久化 交换机持久化 Durable 持久化模式 Transient 临时模式 队列持久化 Durable 持久化模式 Transient 临时模式 消息持久化 在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。\n不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。\nLazyQueue（解决消息积压） 导致消息积压\n消费者宕机或网络故障 发送量激增 消费者处理业务发送阻塞 为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：\n接收到消息后直接存入磁盘而非内存 消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载） 支持数百万条的消息存储 消费者的可靠性 消费者确认：告知RabbitMQ自己消息处理状态。回执有三种可选值：\nack：成功处理消息，RabbitMQ从队列中删除该消息 nack：消息处理失败，RabbitMQ需要再次投递消息 reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消 ACK的处理方式：\nnone：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用 manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活 auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack. 当业务出现异常时，根据异常判断返回不同结果： 如果是业务异常，会自动返回nack； 如果是消息处理或校验异常，自动返回reject; 失败重试机制\n当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。\n极端情况会出现一直requeue\nspring支持在消费者出现异常时利用本地重试\n失败处理策略\nSpring允许我们自定义重试次数耗尽后的消息处理策略\n业务幂等性\n业务重复执行结果仍然不变\n","date":"2024-11-08T20:02:00+08:00","permalink":"https://example.com/p/rabbitmq/","title":"RabbitMQ"},{"content":"G1垃圾回收器详解 G1和CMS要求的内存模型不同\nG1具有软实时性，即用户可以指定垃圾回收的限时，G1会努力在这个时限内完成gc。通常设定一个合理的目标让90%的垃圾回收时间都在这个时限内。\nG1的内存模型 分区概念 分区Region G1采用分区的类似，将堆空间分为若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。可以通过-XX:G1HeapRegionSize=n指定分区大小(1MB~32MB，且必须是2的幂)，默认分为2048个分区。\n卡片Card 分区内部又会分为若干个大小为512 Byte 的卡片，全局卡片表记录了所有分区的卡片信息。每个卡片在全局卡片表中都有一个对应的条目。\n堆Heap 通过-Xms/-Xmx指定堆大小。当发送ygc或者mixgc，通过计算gc与应用的耗时比，自动调整对空间大小。gc频率过高则增加堆尺寸来减少gc频率。\n-XX:GCTimeRatio即为GC与应用的耗时比。\n空间不足时，g1会首先尝试增加堆空间，如果扩容失败则发起fullgc。\n分代模型 分代 Young代和Old代，Young代又包括Eden空间和Survivor空间。\n整个Young代内存占用初始空间-XX:G1NewSizePercent（默认整堆5%）与最大空间（默认60%）\nLocal alloction buffer （Lab） 应用线程占用TLAB来创建对象，而大部分都会落入Eden；\n每次gc时，每个gc线程同样可以独占一个GCLAB用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；\n对于Eden/Survivor空间晋升（Promption）到Survivor/老年代空间的对象，同样有GC独占PLAB\n这些缓冲区就是每个线程认领的内存分配，可以减少同步时间，提升GC效率\n分区模型 ","date":"2024-10-31T10:02:00+08:00","permalink":"https://example.com/p/g1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","title":"G1垃圾回收器"},{"content":"微信登录 小程序调用 wx.login 获得 jscode，然后交给服务器后端程序，然后后端调用 code2session 换取会话密钥\n","date":"2024-10-23T16:02:00+08:00","permalink":"https://example.com/p/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E5%AF%B9%E6%8E%A5/","title":"微信登录对接"},{"content":"远程调用的过程中，需要解决几个问题：\n1、业务健壮性：服务本身没有问题但受到下游服务影响导致异常\n2、级联失败：单个服务的故障会进而影响上游的所有服务\n微服务保护 服务保护方案 请求限流：降低了并发上线 线程隔离：降低了可用资源数量 服务熔断：降低了服务的完整度 这些方案都会导致体验上略有下降，属于降级方案。\n1.1.1请求限流 用于解决并发太高或者说突高的问题，避免服务因流量激增而出现故障\n1.1.2线程隔离 限定每个接口可用使用的资源范围，避免某个接口故障或压力过大导致整个服务不可用\n1.1.3服务熔断 线程隔离避免了雪崩，但故障服务依然会拖慢上游服务的响应速度\n1、服务调用失败后，做降级处理，如抛出异常或者是友好提示或者是默认数据\n2、统计服务提供方的异常比例，比例过高表示该接口会影响到其他服务，应该拒绝继续调用该接口，直接降级处理\nSentinel 配置Sentinel把请求方式+请求路径作为簇点源名\n1、请求限流\nhttps://b11et3un53m.feishu.cn/wiki/QfVrw3sZvihmnPkmALYcUHIDnff#share-DgvJdKYf1ot2R1xdlV8cQ1sknTd\n流控效果：\n快速失败 warm up 排队等待 2、线程隔离\n隔离故障服务的调用，避免雪崩\n因为我们是用 OpenFeign 作远程调用的，所以在 OpenFeign整合Sentinel\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 SpringBoot项目的tomcat最大线程数是200，运行的最大连接数是8192\n限制并发线程数，即五个线程数和qps无直接关系，实际的qps跟接口响应速度有关\n3、服务熔断\n先编写降级逻辑，然后做服务熔断\n降级逻辑 给FeignClien编写失败后的降级逻辑\n方式一：FallbackClass，无法对远程调用的异常做处理 方式二：FallbackFactory，可以对远程调用的异常做处理，一般选择这种 step1:在hm-api模块中给itemclient定义降级处理类，实现FallbackFactory\nstep2:在hm-api模块中的DefaultFeignConfig类中将ItemClientFallback注册为一个Bean\nstep3:在hm-api模块中的ItemClient接口中使用ItemClientFallbackFactory\n服务熔断 Sentinel的断路器可以统计慢请求比例和异常请求比例，超出阈值时，就会熔断该接口，即拦截该接口的一切请求，降级处理；当该接口回复正常时，再放行对于该接口的请求。\n这个断路器的用状态机来描述\nclosed open half-open 分布式事务 本地事务\n分支事务\n全局事务\n业务跨多个服务实现，跨多个数据源实现，就会产生分布式事务问题\n","date":"2024-10-22T16:02:00+08:00","permalink":"https://example.com/p/%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","title":"服务保护和分布式事务"},{"content":"Spring Cloud Config Spring Cloud Config 读取配置文件的步骤\n1、启动 XxxApplication 时，读取自身的 application.yml，获得 name 和 Config Server 地址；\n2、根据 name、profile 和 Config Server 地址，获取一个或多个由优先级的配置文件；\n3、按优先级合并配置项；\n4、如果配置项中存在环境变量，则使用 Xxx 应用本身的环境变量去替换占位符。\n网关 创建网关微服务 引入 SpringCloudGateway、NacosDiscovery 依赖 编写启动类 配置网关路由 网关路由配置 1 2 3 4 5 6 7 8 spring: cloud: gateway: routes: - id: item # 路由规则id，自定义，唯一 uri: lb://item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表 predicates: # 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务 - Path=/items/**,/search/** # 这里是以请求路径作为判断规则 GatewayProperties 读取配置，通过一个 List 来保存， 每个 RouteDefinition 就是具体的路由规则定义。 包含四个常见属性：\nid：路由唯一标识 predicates：路由断言，就是匹配条件 filters：路由过滤条件 uri：路由目标地址，lb://代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。 网关是所有微服务的入口，将登录校验的工作放到网关。在网关和用户服务保存密钥。\n网关过滤器\nGatewayFilter：路由过滤器 GlobalFilter：全局过滤器 微服务获取用户 网关通过请求头获取用户身份信息，继续通过http请求发送到微服务，这样就可以把用户信息传递到下游微服务。\n通过微服务的拦截器，存放到 ThreadLocal 中来提供服务内部用户信息的上下文\n微服务之间通过OpenFeign传递用户\nFeign提供一个拦截器接口 feign.RequestInterceptor\n在com.hmall.api.config.DefaultFeignConfig中添加一个Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Bean public RequestInterceptor userInfoRequestInterceptor(){ return new RequestInterceptor() { @Override public void apply(RequestTemplate template) { // 获取登录用户 Long userId = UserContext.getUser(); if(userId == null) { // 如果为空则直接跳过 return; } // 如果不为空则放入请求头中，传递给下游微服务 template.header(\u0026#34;user-info\u0026#34;, userId.toString()); } }; } 配置管理 配置共享 共享的配置抽取到Nacos统一管理\n在nacos添加共享配置 微服务拉取配置 3.1.2.拉取共享配置 接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的application.yaml配置合并，完成项目上下文的初始化。\n不过，需要注意的是，读取Nacos配置是SpringCloud上下文（ApplicationContext）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取application.yaml。\n也就是说引导阶段，application.yaml文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？\nSpringCloud在初始化上下文的时候会先读取一个名为bootstrap.yaml(或者bootstrap.properties)的文件，如果我们将nacos地址配置到bootstrap.yaml中，那么在项目引导阶段就可以读取nacos中的配置了。\n3.2.配置热更新 3.3.动态路由 路由配置是在项目启动时由org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator加载，一经加载就缓存到内存中的路由表中。\n3.3.1.监听nacos配置变更 创建ConfigService，目的是连接到nacos 添加配置监听器，编写配置变更的通知和处理逻辑 通过自动装配，实际上ConfigService已经创建好了，我们只需要通过NacosConfigManager去getConfigservice就可以了\n项目第一次启动时不仅仅要添加监听器，也要读取配置，所以我们用\n1 2 3 4 5 6 String getConfigAndSignListener( String dataId, // 配置文件id String group, // 配置组，走默认 long timeoutMs, // 读取配置的超时时间 Listener listener // 监听器 ) throws NacosException; 这个api，既可以配置监听器，也可以根据dataId和group读取配置并返回。\n3.3.2.更新路由 监听了配置，就需要用到org.springframework.cloud.gateway.route.RouteDefinitionWriter这个接口来更新路由也就是RouteDefinition\n3.3.3.实现动态路由 ","date":"2024-09-26T16:02:00+08:00","permalink":"https://example.com/p/spring-cloud/","title":"Spring Cloud"},{"content":"Q1 json 传输的过程中，如果想要限制一个属性只能写或者只能读\n1 2 @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) @JsonProperty(access = JsonProperty.Access.READ_ONLY) 加在字段和加在方法上有区别\n加在字段上直接控制字段的序列化和反序列化行为\n加载方法上控制方法的调用来影响序列化和反序列化，通常用在有自定义逻辑时\nQ2 Interceptor 和 Filter 的作用范围\nInterceptor 的拦截范围其实就是 Controller 方法，它实际上就相当于基于 AOP 的方法拦截。 因为 Interceptor 只拦截 Controller 方法，所以返回 ModelAndView 并渲染后，后续处理就脱离了 Interceptor 的拦截范围（虚线框）\nFilter 的拦截范围\n好处 使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的@Order指定顺序。\nSpring作为老牌全能型框架，要想拦截请求进行一些统一的处理，我们有Filter、Interceptor、ControllerAdvice、AOP这么多种截面可供选择： Filter——作用在最外层，在请求进入Spring之前就触发，可以用于处理一些网络通信层面的东西； Interceptor——作用在Controller的外层，数据进入Controller层之前，或离开Controller的前后触发； ControllerAdvice——作用在Interceptor之内，数据进入Controller层但还没处理之前触发，用于预处理Controller层的RequestBody和ResponseBody，以及统一异常处理； AOP——作用于自己写的方法。 使用的时候遵循“最小作用域”原理，在保证能统一抽象出来的前提下，选择最近最小的那个截面。\nT1 DelegatingFilterProxy 是 spring 框架提供的用来让 Servlet 容器实例化的 Filter，间接引用 spring 容器实例化的 Filter\n比如我们在 spring 中声明一个 Component\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class AuthFilter implements Filter { @Autowired UserService userService; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; // 获取Authorization头: String authHeader = req.getHeader(\u0026#34;Authorization\u0026#34;); if (authHeader != null \u0026amp;\u0026amp; authHeader.startsWith(\u0026#34;Basic \u0026#34;)) { // 从Header中提取email和password: String email = prefixFrom(authHeader); String password = suffixFrom(authHeader); // 登录: User user = userService.signin(email, password); // 放入Session: req.getSession().setAttribute(UserController.KEY_USER, user); } // 继续处理请求: chain.doFilter(request, response); } } 因为 AuthFilter 只是一个普通的 Bean，Servlet 容器并不知道，所以它不会起作用。\n如果我们直接在web.xml中声明这个AuthFilter，注意到AuthFilter的实例将由Servlet容器而不是Spring容器初始化，因此，@Autowire根本不生效，用于登录的UserService成员变量永远是null。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;web-app\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;authFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.DelegatingFilterProxy\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;authFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; ... \u0026lt;/web-app\u0026gt; 实现原理：\nServlet容器从web.xml中读取配置，实例化DelegatingFilterProxy，注意命名是authFilter； Spring容器通过扫描@Component实例化AuthFilter。 当DelegatingFilterProxy生效后，它会自动查找注册在ServletContext上的Spring容器，再试图从容器中查找名为authFilter的Bean，也就是我们用@Component声明的AuthFilter。\n","date":"2024-09-21T16:02:00+08:00","permalink":"https://example.com/p/springmvc/","title":"springMVC"},{"content":"Q1 Spring 容器由谁来创建 Web 程序总是由 Servlet 容器创建，那么在一个 Web 程序中，那么，Spring 容器应该由谁创建？在什么时候创建？Spring 容器中的 Controller 又是如何通过 Servlet 调用的？\n在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种最简单的启动Spring容器的方式。\n第一步，我们在web.xml中配置Spring MVC提供的DispatcherServlet：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextClass\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;com.itranswarp.learnjava.AppConfig\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;0\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 初始化参数contextClass指定使用注解配置的AnnotationConfigWebApplicationContext，配置文件的位置参数contextConfigLocation指向AppConfig的完整类名，最后，把这个Servlet映射到/*，即处理所有URL。\n上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的DispatcherServlet，在DispatcherServlet启动时，它根据配置AppConfig创建了一个类型是WebApplicationContext的IoC容器，完成所有Bean的初始化，并将容器绑到ServletContext上。\n因为DispatcherServlet持有IoC容器，能从IoC容器中获取所有@Controller的Bean，因此，DispatcherServlet接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的ModelAndView决定如何渲染页面。\nQ2 Spring Bean 的生命周期 Spring Bean 的生命周期\n下图源自框架篇-05-Spring-bean的生命周期_哔哩哔哩_bilibili\n1、首先是 BeanDefinition，见名字知意，Bean 的定义：\n通过 xml 配置一个 Bean（现在基本不用了）对应需要创建的 ApplictionContext（顶层接口）为 ClassPathXmlApplicationContext（实现类） 通过注解配置一个 Bean（主流，更简洁），使用 @Bean 标注方法，一般叫做 createXxx（比如要创建数据库连接池的就叫 createDataSource），这种方法是用来告诉 IoC 容器如何创建一个组件，然后对应需要创建 AnnotionApplicationContext Spring 容器\nApplicationContext 就是 Spring 容器，它有很多实现类，并且 Spring 还提供了另一种 IoC 容器叫 BeanFactory\n二者的区别主要在于 ApplicationContext 会一次性创建所有的 Bean，而 BeanFactory 是按需创建的（很少使用）。ApplicationContext 还有一些额外的功能这里暂不展开\n2、然后是依赖注入\n注入当前这个组件需要注入的依赖（例如 @AutoWired @Value 标注的属性）\n3、XxxAware接口和Xxx接口（加分点，按照 Aware 接口的设计来说，实际上做事的都是 Xxx，我们直接注入并 Xxx 也可以，但视频中既然体现了这一点，那就展开讲讲）\n该视频从引出了一个不太常见的 Aware 接口的概念，这是一种将功能实现和使用分离的设计：\nXxx 接口：Xxx 接口提供了一组功能定义 定义接口 直接使用 XxxAware 接口：XxxAware 接口允许 Spring 容器向实现该接口的类注入特定的上下文或资源。 提供上下文 获取上下文 这种设计体现的优势：\n解耦\nAware 接口的实现类不需要直接依赖于特定的上下文，而是通过接口获取所需要的资源\n灵活\n实现 XxxAware 接口的类可以在不同的上下文中灵活使用，而无需修改其代码。这使得类的重用性更强。\n关注点分离\n通过将功能定义（Xxx 接口）与上下文访问（XxxAware 接口）分离，开发者可以更清晰地关注各自的职责，使代码更加清晰和易读。（笔者注：我们想使用某个东西的时候肯定更希望直接知道怎么用，而不关心它内部是如何实现的）\n易于拓展\n当需要增加新的功能或上下文支持时，只需实现新的 XxxAware 接口，而不需要对现有的业务逻辑做大量修改。\n明白了吗，实际上这里的 Aware 就是要使用 Xxx，我们在这一步通过 Aware 接口把我们需要的上下文注入到这里，就这么简单\n4、before\n不知道具体要干什么，管他呢反正你知道它是在初始化之前执行的就完事了\n5、初始化方法\n我们在这一阶段会去执行组件的 Init 方法（InitializingBean @PostConstruct），完成类的静态资源的加载\n6、after\n初始化之后，增强这个 Bean\n7、destory\n1 ((ConfigurableApplicationContext) context).close(); close 之后就会触发 Bean 的销毁\ntips：本题的内容可能需要观看 day17 的 Bean 管理内容辅以理解\n","date":"2024-09-15T16:02:00+08:00","permalink":"https://example.com/p/spring/","title":"spring"},{"content":"Q1 mapper\nMapper 就是用来执行 SQL 语句的\nQ2 ORM 框架是如何跟踪 Java Bean 的修改，以便在 update() 操作中更新必要的属性\n使用 Proxy 模式，从 ORM 框架读取的 User 示例实际上并不是 User 类，而是代理类，代理类继承自 User 类，但对每个 setter 方法都做了覆写\nQ3 ORM 分为全自动和半自动框架，有什么区别\nQ4 Spring 提供的 JdbcTemplate 相对于全自动的 ORM 框架有什么差别，有什么优势\n区别： 查询后需要手动提供 Mapper 实例一边把 ResultSet 的每一行变为 Java 对象 增删改操作所需的参数列表，需要手动传入，即把 User 实例变为 [user.id, user.name, user.email] 这样的列表，比较麻烦 优势：确定性 每次读取操作一定是数据库操作而不是缓存，即每次读取操作一定是数据库操作而不是缓存， 而 ORM 框架有一级二级缓存机制 缺点：繁琐、复杂 解决方案： 使用半自动的 ORM 框架 MyBatis，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。 Q5 sql 注入是什么，怎么解决\nStatement\nPrepareStatement\n#{}\n${} 用在动态表名\nQ6 给一个场景：\n现在 UserService 中有一个 updateUser(Long id, String name) 方法，而 UserMapper 中 update 操作只有一个 update(User user) 方法（get、delete、insert都有）\n在这里你是会给接口新加一个方法用于更新 user 的 name；还是用 UserMapper 提供的 getById 获取一个 User 实例，更改 name 后再调用 update(user) 把这个实例传入。\n注：User 继承自 AbstractEntity，里面有多个字段如 id，createdTime，updatedTime\nQ7 如果使用 PageHelper 处理分页查询，会不会有线程安全问题\nPageHelper的使用\nPageHelper 只会对紧跟在其后的第一条 SQL 语句进行分页处理，如：\n1 2 3 4 5 6 7 8 9 @Override public PageBean page(Integer page, Integer pageSize) { PageHelper.startPage(page, pageSize); List\u0026lt;Emp\u0026gt; empList = empMapper.list(); Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; return new PageBean(p.getTotal(), p.getResult()); } 只要可以保证在 PageHelper 方法调用后紧跟着查询方法，就是安全的。\n线程安全问题的产生原因\nPageHelper 使用了静态的 ThreadLocal 参数，这意味着分页设置是与当前啊线程相关联的。\n1 2 3 4 5 6 7 8 9 //使用PageHelper分页助手插件进行分页操作 PageHelper.startPage(0, 10); List\u0026lt;Country\u0026gt; list; if(param1 != null){ list = countryMapper.selectIf(param1); } else { list = new ArrayList\u0026lt;Country\u0026gt;(); } Page\u0026lt;CheckItem\u0026gt; page = checkItemDao.selectByCondition(queryString); 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。\nQ8 对于一个请求参数\n1 2 3 4 5 6 7 8 9 10 11 12 @Data public class EmpQueryParam { // 对于请求中的参数，只有映射到 String 类型时会把空字符串映射，对于其他的类型遇到 \u0026#34;\u0026#34; 会映射为 null private Integer page = 1; // 页码，默认值1 private Integer pageSize = 10; // 每页展示记录数，默认值10 private String name; // 姓名 private Integer gender; // 性别 @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate begin; // 入职开始时间， @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate end; // 入职结束时间 } 编写动态 SQL 语句如下\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.gaj.pojo.Emp\u0026#34;\u0026gt; select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;param.name != null and param.name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; e.name like concat(\u0026#39;%\u0026#39;, #{param.name}, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;param.gender != null\u0026#34;\u0026gt; and e.gender = #{param.gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;param.begin != null and param.end != null\u0026#34;\u0026gt; and e.entry_date between #{param.begin} and #{param.end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by e.update_time desc \u0026lt;/select\u0026gt; 前端的请求\nhttp://localhost:90/api/emps?begin=\u0026amp;end=\u0026amp;gender=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=5 这里的 begin end gender 都是空字符串，为什么对它们不用判空字符串（只用判空），对 name 要判\n很显然Integer 和 LocalDate 只会为 null，不会为空字符串， 简单来说这里只有 String 需要判断是否为 \u0026quot;\u0026quot; 因为编译器已经确保了 \u0026quot;\u0026quot; 空字符串不会映射到其他引用类型\nQ9 spring 开启一个事务是怎么样的，底层是通过操作什么来开启\n答题思路\n简述 spring 框架中事务如何启用 @EnableTransaction PlatformTransactionManager 数据库底层 显式事务和隐式事务 JDBC 开启事务的关键代码是 conn.setAutoCommit(false) 表示关闭提交 spring 启用声明式事务 spring 中启用声明式事务和和开启一个声明式事务没什么好说的，前者需要在启动类上加上@EnableTransaction注解；后者只要在开启一个事务的类上（或者方法上）加上@Transactional注解，然后在需要回滚的地方抛出RunTimeException（默认情况下，也可以在Transactional注解声明rollbackFor属性），spring 的事务管理类（PlatformTransactionManager）会自动rollback。\nspring 启用编程式事务 spring 中使用编程式事务主要是PlatformTransactionManager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 TransactionStatus tx = null; try { // 开启事务: tx = txManager.getTransaction(new DefaultTransactionDefinition()); // 相关JDBC操作: jdbcTemplate.update(\u0026#34;...\u0026#34;); jdbcTemplate.update(\u0026#34;...\u0026#34;); // 提交事务: txManager.commit(tx); } catch (RuntimeException e) { // 回滚事务: txManager.rollback(tx); throw e; } 比较繁琐\n底层启用事务的原理 若是从数据库层面来说的话，开启一个事务是用BEGIN，COMMIT提交一个事务，ROLLBACK回滚事务。事务有隔离级别，但不是本题的讨论范围这里不做讲解。\n主要的答题点应为 JDBC 层面的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Connection conn = openConnection(); try { // 关闭自动提交: conn.setAutoCommit(false); // 执行多条SQL语句: insert(); update(); delete(); // 提交事务: conn.commit(); } catch (SQLException e) { // 回滚事务: conn.rollback(); } finally { conn.setAutoCommit(true); conn.close(); } 开启事务的关键代码是 conn.setAutoCommit(false) 表示关闭提交。\n因为事务分为显示事务和隐式事务，对于单条 SQL 语句，数据库系统自动将其作为一个事务执行，这就是隐式事务。\n关闭自动提交就代表开启了显示事务，然后在执行多条sql语句的过程中如果 catch 到了异常，就可以选择回滚事务，如果程序正常执行就将 commit\n自动提交更改后必须要改回原来的值\n所以 spring 框架在开启事务的时候其实就是对自动提交的操作。\nQ10 使用@Transactional注解可以开启一个事务，在什么时候会回滚？\n默认抛出RuntimeException异常时会回滚，非RuntimeException（包括IOException、ReflectiveOperationException等等）不会回滚。\n为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作。\nQ11 Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？\nQ12 事务失效场景\n事务方法非 public 修饰\n非事务方法调用事务方法\n事务方法的异常被捕获了\n事务异常类型不对\n事务传播行为不对\n没有被 Spring 管理\nQ13 数据库事务具有 ACID 特性\nAtomicity 原子性 Consistency 一致性 Isolation 隔离性 Durability 持久性 Q14 SQL 标准定义了哪四种隔离级别\nIsolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - Q15 你实现过文件上传功能吗，说一下你项目中的方案\nOSS\n有什么好处\nQ16 mybatis 新增操作怎么获取新增记录的主键，怎么确保它的正确映射\n@Options(useGeneratedKeys = true, keyProperty = \u0026quot;id\u0026quot;, keyColumn = \u0026quot;id\u0026quot;)\nproperty 和 column\nQ17 跨表操作在我们查询的时候非常常见，你怎么决定是在 mapper 层通过表连接 SQL JOIN 来处理跨表，还是在 service 层做跨表，都有什么优劣\n思路\n性能 灵活、拓展性 跨表操作在 mapper 层\n优点 性能更优，数据库引擎的优化 事务的一致性 缺点 复杂的 sql 维护困难 耦合性高 跨表操作在 service 层\n优点 可读性、可维护性 灵活性 可拓展性 缺点 性能 事务管理复杂 我更偏向将复杂的跨表操作放在 service 层，项目的稳健性是非常重要的，非常简单的跨表操作才考虑放在mapper 层。放在 mapper 层虽然提高了性能且减少了事务管理的麻烦，但是带来的弊端是在项目未来继续扩张时一定会碰到的。\n避免过早优化\nmapper 层的跨表操作通常遵循低复杂性和高效率的原则。因此，通常建议 mapper 层的跨表操作仅限于必要且简单的场景。\n复杂查询的最佳实践\n在开发中，遇到需要跨表操作的场景时，建议采取以下策略：\n拆分查询：尽量避免过度依赖 JOIN，可以通过多次查询分别获取数据，再通过 service 层合并处理。 视图或存储过程：如果有较为复杂的跨表查询需求，可以考虑在数据库中创建视图或者存储过程，将复杂的逻辑封装在数据库中，以便简化 mapper 层的操作。 DTO 或 VO 封装：将查询结果封装到 DTO 或 VO，而不是直接在 mapper 层进行业务逻辑处理。例如，查询班级与班主任的名字，可以在 service 层执行两次查询，将数据封装成一个完整的 DTO 返回给前端。 ","date":"2024-09-14T20:02:00+08:00","permalink":"https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"数据库"},{"content":"","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/mysql%E7%B4%A2%E5%BC%95/","title":"mysql索引"},{"content":"Spring IoC ","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/spring-ioc/","title":"Spring IoC"},{"content":"Q1 private final Logger logger = LoggerFactory.getLogger(getClass());\n还是\nprivate statci final Logger logger = LoggerFactory.getLogger(ClassName.class);\n两种写法各有优缺点，选择哪一种取决于你的需求和项目风格。\nprivate final Logger logger = LoggerFactory.getLogger(getClass());\n优点：\n通用性高：可以用于任何类，无需手动更新类名（适合复制粘贴代码到其他类中时无需修改）。 适应继承：如果这个类被继承，getClass() 会返回子类的类型，日志会正确显示子类的类名。 缺点：\n运行时开销：getClass() 是在运行时确定的，虽然开销不大，但比静态方法稍微慢一些。 private static final Logger logger = LoggerFactory.getLogger(ClassName.class);\n优点：\n效率稍高：因为 ClassName.class 是在编译时确定的，性能上稍微优于 getClass()。 符合静态常量的惯例：logger 是静态的，通常被定义为 static final，符合惯例。 日志清晰：明确指定类名，在日志中始终使用这个类的名字，不管它是否被继承。 缺点：\n继承问题：如果类被继承，日志依然显示的是父类的类名，而不是子类的名字，这在需要记录子类日志时可能不是理想的选择。 类名需要手动更新：如果你复制这个类或重命名它，你需要手动更新 ClassName，否则会导致日志记录混乱。 推荐用法： 使用 static final 和类名 的方式更为常见，尤其在不涉及继承的情况下。这种方式在性能上更高效，且更符合静态常量的使用习惯。 1 private static final Logger logger = LoggerFactory.getLogger(ClassName.class); 如果你的类可能会被继承并且你希望日志记录子类的类名，则可以考虑使用 getClass()： 1 private final Logger logger = LoggerFactory.getLogger(getClass()); 总结：对于一般类，建议使用 static final Logger 和类名；如果有继承需求，使用 getClass() 更灵活。\n单体项目平滑发布 蓝绿发布\n单机多双结点\nk8s和docker\n广告投放定时任务 从半小时到秒级-京东定时任务优化实战_哔哩哔哩_bilibili\n限制堆外内存 深分页 limit 5000000, 100 和 where id \u0026gt; 5000000 limit 100\n","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/%E9%9A%8F%E8%AE%B0/","title":"随记"},{"content":"Q1 private final Logger logger = LoggerFactory.getLogger(getClass());\n还是\nprivate statci final Logger logger = LoggerFactory.getLogger(ClassName.class);\n两种写法各有优缺点，选择哪一种取决于你的需求和项目风格。\nprivate final Logger logger = LoggerFactory.getLogger(getClass());\n优点：\n通用性高：可以用于任何类，无需手动更新类名（适合复制粘贴代码到其他类中时无需修改）。 适应继承：如果这个类被继承，getClass() 会返回子类的类型，日志会正确显示子类的类名。 缺点：\n运行时开销：getClass() 是在运行时确定的，虽然开销不大，但比静态方法稍微慢一些。 private static final Logger logger = LoggerFactory.getLogger(ClassName.class);\n优点：\n效率稍高：因为 ClassName.class 是在编译时确定的，性能上稍微优于 getClass()。 符合静态常量的惯例：logger 是静态的，通常被定义为 static final，符合惯例。 日志清晰：明确指定类名，在日志中始终使用这个类的名字，不管它是否被继承。 缺点：\n继承问题：如果类被继承，日志依然显示的是父类的类名，而不是子类的名字，这在需要记录子类日志时可能不是理想的选择。 类名需要手动更新：如果你复制这个类或重命名它，你需要手动更新 ClassName，否则会导致日志记录混乱。 推荐用法： 使用 static final 和类名 的方式更为常见，尤其在不涉及继承的情况下。这种方式在性能上更高效，且更符合静态常量的使用习惯。 1 private static final Logger logger = LoggerFactory.getLogger(ClassName.class); 如果你的类可能会被继承并且你希望日志记录子类的类名，则可以考虑使用 getClass()： 1 private final Logger logger = LoggerFactory.getLogger(getClass()); 总结：对于一般类，建议使用 static final Logger 和类名；如果有继承需求，使用 getClass() 更灵活\n单体项目平滑发布 蓝绿发布\n单机多双结点\nk8s和docker\n广告投放定时任务 从半小时到秒级-京东定时任务优化实战_哔哩哔哩_bilibili\n限制堆外内存 深分页 limit 5000000, 100 和 where id \u0026gt; 5000000 limit 100\n服务器情况 ","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/%E9%9A%8F%E8%AE%B0/","title":"随记"},{"content":"1. main 分支 用途: main（或 master）是项目的主要分支，通常代表的是当前稳定和可发布的版本。它是用户和生产环境直接使用的分支。 说明: 代码合并到 main 分支时，通常已经经过充分的测试，并且功能已经完全实现。 2. build 分支 用途: 用于存储构建脚本、构建配置文件或持续集成和部署的代码。 说明: 该分支可能包含自动化构建系统所需的工具或配置文件，比如 Jenkinsfile、Dockerfile 或者 CI/CD 的脚本。 3. exp 分支 用途: exp 是实验（experimental）的缩写。用于进行实验性的开发。 说明: 该分支可能包含尚未确定的功能或新技术的尝试，通常不保证稳定性，并且可能会在未来被删除或合并到其他分支。 4. feat 分支 用途: feat 是 feature 的缩写。用于开发新功能。 说明: 通常每个功能都会有一个单独的分支（如 feat/feature-name），开发完成并通过测试后再合并到 dev 或 main。 5. fix 分支 用途: fix 分支专门用于修复 bug。 说明: 修复特定问题或 bug 的代码会先提交到 fix 分支，然后再合并到 dev 或 main，以确保问题修复后能立即进入下一步发布流程。 6. issues 分支 用途: 与项目的 issue 管理工具（如 GitHub Issues）相结合，专门用于处理特定的 issues（问题/任务）。 说明: 该分支通常用于实现特定问题的修复或功能改进，分支名称通常会包括 issue 的编号（如 issues/#123）。 7. perf 分支 用途: perf 是 performance 的缩写。用于进行性能优化。 说明: 该分支会涉及到代码的性能改进，例如减少内存使用、优化算法等，然后这些改动会被测试和验证后合并回主分支。 8. refactor 分支 用途: 用于重构代码。 说明: 该分支上的改动通常不影响功能，但会改善代码质量、结构和可维护性。这些改动通常需要经过充分的测试，以确保没有引入新的 bug。 9. rework 分支 用途: 专门用于重新开发或重写某部分代码。 说明: 当某个功能或模块需要大规模重写而不破坏现有版本时，rework 分支会被创建。在完成后，这些改动可以被合并到 dev 或其他相应的分支。 10. dev 分支 用途: dev 是开发分支，通常是用于日常开发的主要分支。 说明: 这个分支包含尚在开发中的功能和改进，在合并到 main 之前通常会在这个分支进行测试和 bug 修复。 11. 0.17_LTS 分支 用途: 该分支代表一个长期支持（Long Term Support, LTS）的版本。 说明: 此版本通常比最新版本更稳定，且会定期接收安全更新和重要的 bug 修复。它可能用于需要长期支持的客户或产品环境。 12. litecommand 分支 用途: 可能用于开发一个名为 litecommand 的特定功能或模块。 说明: 该分支上可能包含与 litecommand 功能相关的代码，开发完成后再合并回主分支。 ","date":"2024-09-11T20:02:00+08:00","permalink":"https://example.com/p/git%E5%88%86%E6%94%AF/","title":"Git分支"},{"content":"多线程 线程 创建线程 继承 Thread 类，重写 run 方法，然后创建子类对象调用 start() 方法 实现 Runnable 接口，重写 run 方法，然后创建实现类对象并传递给一个 Thread，调用 start() 实现 Callable 接口，重写 call 方法，然后创建实现类对象并传递给一个 FutureTask 类对象，最后传递给一个 Thread 对象调用 start() 线程的六种状态 NEW 新建状态 RUNNABLE 可运行状态，线程调用 start() 方法后即处于这个状态 BLOCKED 锁阻塞状态，没有获取到锁即处于这个状态 WAITING 无线等待状态，线程执行时被调用了 wait() 方法处于这个状态 TIMED_WAITING 计时等待状态，线程执行时被调用了 sleep(ms) 或 wait(ms) 方法即处于这个状态 TERMINATED 终止状态，线程执行完毕或遇到异常即处于这个状态 线程池 ThreadPoolExcutor 线程池内部使用 AtomicTnteger 来维护 runState(运行状态) 和 workerCount(线程数量) 用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。\n顶层接口是 Excutor\n线程池的五种运行状态 RUNNING 能接受新提交的任务，并且也能处理阻塞队列中的任务 SHUTDOWN 关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中保存的任务 STOP 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程 TIDYING 所有的任务都终止了，workerCount(有效线程数)为0 TERMINATED 在 terminated() 方法执行完后加入该状态 Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)\nQ 乐观锁 乐观锁的基本原理： 乐观锁的思想是假设并发情况下不会有冲突，只有在提交数据时才会检测是否存在冲突。\n","date":"2024-09-01T21:52:54+08:00","permalink":"https://example.com/p/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"多线程"},{"content":" Spring 简化了数据库访问：\n提供简化的访问 JDBC 的模板类，不必手动释放 提供一个统一的 DAO 类以实现 Data Access Object模式 把 SQLException 封装为 DataAccessException，这是一个 RuntimeException 能方便地继承 Hibernate、JPA 和 MyBatis 这些数据库访问框架 使用 JDBC 引入以下依赖：\norg.springframework:spring-context:6.0.0 org.springframework:spring-jdbc:6.0.0 jakarta.annotation:jakarta.annotation-api:2.1.1 com.zaxxer:HikariCP:5.0.1 org.hsqldb:hsqldb:2.7.1 在 AppConfig 中，创建以下几个必须的 Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) // 读取数据库配置文件 public class AppConfig { @Value(\u0026#34;${jdbc:url}\u0026#34;) // 注入配置文件的相关配置 String jdbcUrl; @Value(\u0026#34;${jdbc.username}\u0026#34;) String jdbcUsername; @Value(\u0026#34;${jdbc.password}\u0026#34;) String jdbcPassword; @Bean DataSource createDataSource() { // 创建需要用到注入的配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(jdbcUrl); config.setUsername(jdbcUsername); config.setPassword(jdbcPassword); config.addDataSourceProperty(\u0026#34;autoCommit\u0026#34;, \u0026#34;true\u0026#34;); config.addDataSourceProperty(\u0026#34;connectionTimeout\u0026#34;, \u0026#34;5\u0026#34;); config.addDataSourceProperty(\u0026#34;idleTimeout\u0026#34;, \u0026#34;60\u0026#34;); // 创建 DataSource 实例，实际类型为 HikariDataSource return new HikariDataSource(config); } @Bean JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) { return new JdbcTemplate(dataSource); } } 在需要访问数据库的 Bean 中，注入 JdbcTemplate：\n1 2 3 4 @Component public class UserService { @Autowired JdbcTemplate jdbcTemplate; 使用 JdbcTemplate T execute(ConnectionCallback action) 方法，提供了 Connection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public User getUserById(long id) { // 传入 ConnectionCallback return jdbcTemplate.execute((Connection conn) -\u0026gt; { // 可以直接使用 conn 实例，不用释放，回调结束后 jdbcTemplate 自动释放 // 在内部手动创建的 PreparedStatement、ResultSet 必须用 try(...) 释放 try (var ps = conn.prepareStatement(\u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;)) { ps.setLong(1, id); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by id:\u0026#34; + id); } } }); } T execute(String sql, PreparedStatementCallback action)，PreparedStatement 实例已经由JdbcTemplate 创建，并在回调后自动释放: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public User getUserByName(String name) { return jdbcTemplate.execute(\u0026#34;SELECT * FROM users WHERE name = ?\u0026#34;, (PreparedStatement ps) -\u0026gt; { // PreparedStatement 实例已经由 JDBCTemplate 创建，并在回调后自动释放 ps.setString(1, name); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by name: \u0026#34; + name); } }); } T queryForObject(String sql, RowMapper rowMapper, Object\u0026hellip; args)，传入 SQL 以及 SQL 参数后，JdbcTemplate 会自动创建 PreparedStatement，自动执行查询并返回 ResultSet，我们提供的RowMapper 需要做的事情就是把 ResultSet 的当前行映射成一个 JavaBean 并返回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public User getUserByEmail(String email) { // 传入 SQL，参数和 RowMapper 实例 return jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM users WHERE email = ?\u0026#34;, (ResultSet rs, int rowNum) -\u0026gt; { // 将 ResultSet 的当前行映射为一个 JavaBean return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } ); } JdbcTemplate 设计的目的就是为了避免繁琐的 try\u0026hellip;catch 语句\nquery() 方法返回多行记录，传入 SQL 语句，SQL 参数以及 RowMapper 实例\nSpring 提供了 BeanPropertyRowMapper\n1 2 3 4 5 6 7 8 public List\u0026lt;User\u0026gt; getUsers(int pageIndex) { int limit = 2; int offset = limit * (pageIndex - 1); return jdbcTemplate.query(\u0026#34;SELECT * FROM users LIMIT ? OFFSET ?\u0026#34;, new BeanPropertyRowMapper\u0026lt;\u0026gt;(User.class), limit, offset ); } 插入、更新、删除使用 update() 1 2 3 4 5 6 7 public void updateUser(User user) { // 传入 SQL、SQL 参数、返回更新的行数 if (1 != jdbcTemplate.update(\u0026#34;UPDATE users SET name = ? WHERE id = ?\u0026#34;, user.getName(), user.getId())) { throw new RuntimeException(\u0026#34;User not found by id\u0026#34;); } } 使用 KeyHolder 获取插入后的自增值\nupdate() 时传入 PreparedStatementCreator 和 KeyHolder 两个参数\nholder.getKey() 可以获取返回自增值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public User register(String email, String password, String name) { KeyHolder holder = new GeneratedKeyHolder(); if (1 != jdbcTemplate.update( // 参数 PreparedStatementCreator (conn) -\u0026gt; { PreparedStatement ps = conn.prepareStatement(\u0026#34;INSERT INTO users(email, password, name) VALUES (?,?,?)\u0026#34;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, email); ps.setString(2, password); ps.setString(3, name); return ps; }, // 参数 KeyHolder holder )) { throw new RuntimeException(\u0026#34;Insert failed.\u0026#34;); } return new User(holder.getKey().longValue(), email, password, name); } JdbcTemplate 用法总结 简单查询使用 query()，只需要提供 SQL 语句、参数和 RowMapper 更新操作使用 update()，只需要提供 SQL 语句和参数 任何复杂的操作使用 execute(ConnectionCallback)，拿到了 Connection 就可以做任何 JDBC 操作 设计表结构的时候要和 JavaBean 的属性一一对应，这样就可以方便的使用 Spring 提供的 BeanPropertyRowMapper。\n如果表结构和 JavaBean 不一致，则需要稍微改写查询使得结果集和 JavaBean 保持一致\n数据库列名与 JavaBean 属性名不一致\n在 SQL 查询中使用别名将列名与 JavaBean 属性名对齐。\n1 SELECT user_id AS id, user_name AS name FROM users LIMIT ? OFFSET ? 数据库表包含 JavaBean 中没有的字段\n在查询中只选择 JavaBean 中定义的字段.\nJavaBean 中包含数据库表没有的字段\nJavaBean 中的字段需要进行转换\n1 SELECT user_id AS id, user_name AS name, CASE WHEN is_active = 1 THEN TRUE ELSE FALSE END AS active FROM users LIMIT ? OFFSET ? 需要使用自定义的行映射器 1 2 3 4 5 6 7 8 9 10 11 class UserRowMapper implements RowMapper\u0026lt;User\u0026gt; { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setId(rs.getLong(\u0026#34;user_id\u0026#34;)); user.setName(rs.getString(\u0026#34;user_name\u0026#34;)); user.setActive(rs.getInt(\u0026#34;is_active\u0026#34;) == 1); // 其他属性的映射 return user; } } 使用声明式事务 Spring 中提供了一个 PlatformTransactionManager 来表示事务管理器。事务由 TransactionStatus 表示。\n手写事务代码的话，一般在 try{\u0026hellip;..} 中执行数据操作，然后 catch{\u0026hellip;..} 中捕获错误然后 rollback 事务，没有捕获到错误的话就 commit() 提交事务。\n启用声明式事务 在 AppConfig 中追加一个 PlatformTransactionManager 对应的 Bean，然后再加一个 @EnableTransactionManagement 注解\nPlatformTransactionManager 对应的 Bean：\n1 2 3 4 5 @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) { // 实际类型是 DataSourceTransactionManager return new DataSourceTransactionManager(dataSource); } @EnableTransactionManagement 注解\n1 2 3 4 5 6 7 8 9 10 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) @EnableTransactionManagement // 启用声明式事务 public class AppConfig { @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } } 这样就启用了声明式事务，然后对需要事务支持的方法或者在 Bean 上加（表示对所有 public 方法都具有事务支持），加上一个 @Transactional 注解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Transactional public User register(String email, String password, String name) { KeyHolder holder = new GeneratedKeyHolder(); if (1 == jdbcTemplate.update( // 将会抛出异常 // 参数 PreparedStatementCreator (conn) -\u0026gt; { PreparedStatement ps = conn.prepareStatement(\u0026#34;INSERT INTO users(email, password, name) VALUES (?,?,?)\u0026#34;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, email); ps.setObject(2, password); ps.setString(3, name); return ps; }, // 参数 KeyHolder holder )) { throw new RuntimeException(\u0026#34;Insert failed, will roll back.\u0026#34;); // 将会 rollback } return new User(holder.getKey().longValue(), email, password, name); } Spring 会通过 AOP 代理实现事务的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... PlatformTransactionManager txManager = ... public User register(String email, String password, String name) { TransactionStatus tx = null; try { tx = txManager.getTransaction(new DefaultTransactionDefinition()); target.register(email, password, name); txManager.commit(tx); } catch (RuntimeException e) { // 默认情况下只有 RuntimeException 触发回滚 txManager.rollback(tx); throw e; } } ... } 针对异常类型决定是否回滚 1 @Transactional(rollbackFor = {RuntimeException.class, IOException.class}) 强烈建议业务异常体系从 RuntimeException 派生\n事务边界 一般来说一个事务的开始就是方法的开始，事务的结束就是方法的结束。\n新用户注册的事务：\n1 2 3 4 5 6 7 @Component public class UserService { @Transactional public User register(String email, String password, String name) { // 事务开始 .... } // 事务结束 } 发表博客的事务：\n1 2 3 4 5 6 7 @Componet public class BlogService { @Transaction public Blog addBlog(User user, String content) { // 事务开始 ... } // 事务结束 } 如果我们想要这样的效果：新用户注册后自动发表一个打招呼的博客：\n1 2 3 4 5 6 7 8 9 10 11 12 @Component public class UserService { @Autowired BlogService blogService; @Transactional public User register(String email, String password, String name) { .... User user = jdbcTemplate.insert(\u0026#34;....\u0026#34;); blogService.addBlog(user.id, \u0026#34;Hello Blog!\u0026#34;); } } 如果 addBlog() 抛出异常， register() 是否也需要回滚？\n事务传播 Spring 为事务传播定义的几个级别\nREQUIRED\n默认的事务传播级别，表示如果当前没有事务，就创建一个事务，如果当前有事务，就加入到当前事务中执行\nSUPPORTS\n表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行\nMANDATORY\n表示必须要存在当前事务并加入执行，否则将抛出异常\nREQUIRES_NEW\n表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已有事务，将当前事务挂起，等新事务完成后，再恢复执行\nNOT_SUPPORTED\n表示不支持事务，如果当前有事务，将当前事务挂起，等这个方法执行完成后，再恢复执行\nNEVER\n和 NOT_SUPPORTED 相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行\nNESTED\n表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务\n默认的 REQUIRED 已经满足绝大部分需求，SUPPORTS 和 REQUIRES_NEW 在少数情况下会用到，其他基本不会用到\n定义事务的传播级别\n1 2 3 4 @Transactional(propagation = Propagation.REQUIRES_NEW) public Product createProduct() { ... } Spring 使用 ThreadLocal 来传播事务，如果一个事务方法从 ThreadLocal 未取到事务，那么它会打开一个新的 JDBC 连接，同时开启一个新的事务，否则，它就直接使用从 ThreadLocal 获取的 JDBC 连接以及 TransactionStatus。因此事务能正确传播的前提是，方法调用是再一个线程内才行。\n使用 DAO 集成 Hibernate 集成 JPA 集成 MyBatis ","date":"2024-08-28T20:40:00+08:00","permalink":"https://example.com/p/spring%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Spring访问数据库"},{"content":"1 数据结构 1.1 算法复杂度 时间复杂度和空间复杂度\n大 O 复杂度表示法\n舍去低阶、常量、系数\n2 常见数据结构 2.2.1 数组： 存储方式：\n内存中连续的空间，存储相同的数据类型；\n增删改查：\n遍历：\n2.2.2 链表： 存储方式：\n内存中离散的结点，data（数据）和 next（下一个元素的地址）；\n增删改查：\n遍历：\n2.2.3 栈： 存储方式：\n满足先进后出的存储结构；\n入栈和出栈操作：\n2.2.4 队列： 满足先进先出的存储结构；\n入队和出队操作；\n2.2.5 散列表 理想的哈希表是不会产生冲突，即每一个元素的键（Key）都不相同的数组，但显然这种数据结构在计算机有限的空间下无法实现，注定产生哈希冲突；\n哈希冲突的解决方案决定了哈希表的具体数据结构：\n链地址\nJava 中采用的方案，将冲突的值将通过链表存储，并根据一定的规则将链表转换为红黑树（红黑树相对链表能显著优化查找速度）\n开放定址、再哈希法、公共溢出区\u0026hellip;\n衡量一个哈希算法的好坏主要参考该算法能否将数据均匀的映射到Key的取值范围中\n2.2.6 二叉树： data 域和 左右儿子的指针\n","date":"2024-08-28T20:02:00+08:00","permalink":"https://example.com/p/%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/","title":"集合八股文"},{"content":"AOP Aspect Oriented Programming，即面向切面编程\n何谓面向切面？我们对一个在 OOP 中的 BookService 的业务组件来考察，它应该会有几个业务方法：\ncreateBook updateBook deleteBook 那么，对于每个方法，我们都会需要设置安全检查、记录日志等等的公共逻辑，它们会重复的出现在各个业务方法中。在这些方法的某些代码段中就会出现重复的代码，加入把他们当作火腿肠一般并在一排，用刀切开就能够去考察这些切面了。\n对将这些切面如何正确的组装进火腿肠来说，有三种方法：\n在准备原料的时候就将它们按照顺序排列好，然后一次性注入进肠衣； 在将原料注入到肠衣的时候，按照需要的顺序先注入一种然后再切换到另外的； 业务逻辑这种原料先全部注入，然后按照需要切开再组装。 上述所言是在太过抽象，也或许并不贴且，但我们可以先有较为具体的例子，再去看对应到 Java 中 AOP 将切片织入到 BookService 的具体方案：\n编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ 就扩展了 Java 编译器，使用关键字 aspect 来实现织入； 类加载器：在目标类被装载到 JVM 时，通过一个特殊的类加载器，对目标类的字节码重新“增强”； 运行期：目标对象和切面都是普通 Java 类，通过 JVM 的动态代理功能或者第三方库实现运行期动态织入。 Spring 的 AOP 实现就是基于 JVM 的动态代理。\n由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。\n装配 AOP Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点 Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行 Pointcut：切入点，即一组连接点的集合 Advice：增强，指特定连接点上执行的动作 Introduction：引介，指为一个已有的Java对象动态的增加新的接口 Weaving：织入，指将切面整合到程序的执行流程中 Interceptor：拦截器，是一种实现增强的方式 Target Object：目标对象，即真正执行业务的核心逻辑对象 AOP Proxy：AOP 代理，是客户端持有的增强后的对象引用 要实现 AOP，我们先要引入 Spring 对 AOP 的支持：\norg.springframework:spring-aspects:6.0.0\n然后定义一个 Aspect：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Aspect @Component public class LoggingAspect { // 在执行 UserService 的每个方法前执行 @Before(\u0026#34;execution(public * com.gaj.demo01aop.service.UserService.*(..))\u0026#34;) public void doAccessCheck() { System.err.println(\u0026#34;[Before] do access check...\u0026#34;); } // 在执行 MailService 的每个方法前后执行 @Around(\u0026#34;execution(public * com.gaj.demo01aop.service.MailService.*(..))\u0026#34;) public Object doLogging(ProceedingJoinPoint pjp) throws Throwable { System.err.println(\u0026#34;[Around] start \u0026#34; + pjp.getSignature()); Object retval = pjp.proceed(); System.err.println(\u0026#34;[Around] done \u0026#34; + pjp.getSignature()); return retval; } } @Before 注解后面的字符串是告诉 AspectJ应该在何处执行该方法，这里写的意思是：执行 UserService 的每个 public 方法前执行 doAccessCheck() 代码。\n@Around 注解可以决定是否执行目标方法。\n同时还要给 @Configuration 类加上 @EnableAspectJAutoProxy 注解，这样 Spring 的 IoC容器就会自动查找带有 @Aspect 的 Bean，然后根据每个方法的 @Before、@Around 等注解把 AOP 注入到特定的 Bean 中。\n所以使用 AOP 的步骤如下：\n定义执行方法，并在方法上通过 AspectJ 的注解告诉 Spring 应该在何处调用此方法； 标记 @Component 和 @Aspect； 在 @Configuration 类上标注 @EnableAspectJAutoProxy。 拦截器类型：\n@Before\n先拦截代码，再执行目标代码。如果拦截器抛出异常，目标代码就不执行；\n@After\n先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；\n@AfterReturning\n和 @After 不同的是，只有当目标代码正常返回时，才执行拦截器代码；\n@AfterThrowing\n和 @After 不同的是，只有当目标代码正常抛出了异常时，才执行拦截器代码；\n@Around\n能完全控制目标代码是否执行，并且可以在执行前后、抛异常后执行任意拦截代码。\n使用注解装配 AOP 自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。\n以监控应用程序性能为例，先定义一个性能监控的注解：\n1 2 3 4 5 @Target(METHOD) @Retention(RUNTIME) public @interface MetricTime { String value(); } 在需要被监控的关键方法上标注该注解\n1 2 3 4 5 6 7 8 9 @Component public class UserService { // 监控register()方法性能: @MetricTime(\u0026#34;register\u0026#34;) public User register(String email, String password, String name) { ... } ... } 然后定义切片 MetricAspect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class MetricAspect { @Around(\u0026#34;@annotation(metricTime)\u0026#34;) public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable { String name = metricTime.value(); long start = System.currentTimeMillis(); try { return joinPoint.proceed(); } finally { long t = System.currentTimeMillis() - start; // 写入日志或发送至JMX: System.err.println(\u0026#34;[Metrics] \u0026#34; + name + \u0026#34;: \u0026#34; + t + \u0026#34;ms\u0026#34;); } } } @Around(\u0026quot;@annotation(metricTime)\u0026quot;) 表示符合条件的目标方法时带有 @MetricTime 注解的方法\nAOP 避坑 Spring 通过 CGLIB 动态创建的代理类生成的构造方法中，并未调用 super()，因此从成员变量并未初始化。Java 编译器虽然会默认在构造方法的第一行自动加 super()，但是， CGLIB 构造的代理类，是通过直接生成字节码，没有源码-编译-字节码的这个步骤，因此：\nSpring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！\n如何解决这个问题，需要在访问字段的代码，改成通过方法访问（用 getter 访问而不用 对象.字段直接访问字段），在代理实例中，因为代理类会覆写 getter 方法，并且将其委托给原始实例：\n1 2 3 4 5 6 7 8 public UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... // 原始实例 ... public ZoneId getZoneId() { return target.getZoneId(); // 委托给原始实例 } } 如果有方法是用 public + final 修饰的方法，\n1 2 3 4 5 6 7 @Component public class UserService { ... public final ZoneId getFinalZoneId() { return zoneId; } } 如果在MailService中，调用的不是getZoneId()，而是getFinalZoneId()，又会出现NullPointerException，这是因为，代理类无法覆写final方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的zoneId字段，即null。\n因此，正确使用AOP，我们需要一个避坑指南：\n访问被注入的Bean时，总是调用方法而非直接访问字段； 编写Bean时，如果可能会被代理，就不要编写public final方法。 这样才能保证有没有AOP，代码都能正常工作。\n","date":"2024-08-26T09:52:54+08:00","permalink":"https://example.com/p/aop/","title":"AOP"},{"content":"Cookie Cookie是另一种在Web应用中保持状态的机制，但与session不同的是，cookie存储在客户端，而不是服务器端。以下是cookie的详细介绍：\n1. Cookie的工作原理 存储位置: cookie存储在客户端的浏览器中，由浏览器管理。 传递机制: 每次客户端发送HTTP请求时，浏览器会自动将相关的cookie信息添加到请求头中发送给服务器。这些cookie可以包含各种数据，如用户ID、偏好设置等。 2. Cookie的创建和使用 设置Cookie:\n服务器通过HTTP响应头中的Set-Cookie指令来设置cookie。\n例如：\n1 2 3 Cookie cookie = new Cookie(\u0026#34;username\u0026#34;, \u0026#34;Alice\u0026#34;); cookie.setMaxAge(60 * 60); // 设置cookie的生命周期为1小时 response.addCookie(cookie); 这段代码在服务器响应时，告诉客户端保存一个名为\u0026quot;username\u0026quot;、值为\u0026quot;Alice\u0026quot;的cookie，并设定这个cookie的有效期为1小时。\n读取Cookie:\n服务器可以通过HttpServletRequest对象读取客户端发送的cookie。\n例如：\n1 2 3 4 5 6 7 8 9 Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie c : cookies) { if (\u0026#34;username\u0026#34;.equals(c.getName())) { String username = c.getValue(); // 使用username进行后续操作 } } } 这段代码获取客户端发送的所有cookie，并从中找到名为\u0026quot;username\u0026quot;的cookie，然后提取其值。\n3. Cookie与Session的区别 存储位置: Session存储在服务器端（内存、数据库、文件等）。 Cookie存储在客户端（浏览器）。 生命周期: Session的生命周期通常与客户端会话相关联，且可以配置为持久化或基于时间过期。 Cookie的生命周期由服务器通过Max-Age或Expires属性指定。如果不设置，cookie会在浏览器关闭后失效。 安全性: Session数据在服务器端保存，客户端无法直接访问或篡改，安全性较高。 Cookie数据保存在客户端，虽然可以设置为HttpOnly（仅供服务器读取）或Secure（仅在HTTPS下传输），但仍然容易受到客户端篡改或窃取的风险。 典型用途: Session通常用于存储用户的会话数据（如登录状态），在多个请求之间保持状态。 Cookie可以用于在客户端存储小型数据，如用户偏好、会话ID等。 4. Session与Cookie的关系 通常，session和cookie是一起使用的。为了在多个请求之间识别用户的session，服务器会创建一个session ID，并通过cookie发送给客户端。 每次客户端发送请求时，浏览器会将session ID的cookie返回给服务器，服务器通过这个session ID找到对应的session，从而维持会话状态。 总结 Cookie: 存储在客户端，由服务器通过Set-Cookie设置。每次请求时，浏览器会自动发送相关cookie。 Session: 存储在服务器端，用于管理与特定用户的会话状态。通常通过session ID来关联客户端和服务端的会话。 Cookie和session各有其用途，通常根据应用需求选择最适合的方式来管理用户状态。\n","date":"2024-08-25T08:52:54+08:00","image":"https://example.com/p/cookie/cookie_hu8143540753659831620.jpg","permalink":"https://example.com/p/cookie/","title":"Cookie"},{"content":"Filter \u0026amp; DispatcherServlet \u0026amp; Interceptor Filter 过滤器，它是 JavaEE 的 Servlet 规范提供的一种组件\n作用\n在 Http 请求到达 Servlet 之前，可以被一个或多个 Filter 预处理，主要是做的一些代码的公共逻辑。\n调用链\n多个 Filter 是具有调用链的存在的，每个请求都会被链上的 Filter 依次处理，需要在 web.xml 中配置它们的顺序。\nFilter 可以有针对性地拦截或者放行 HTTP 请求，如果在 Filter 内部直接发送重定向，且没有调用 chain.doFilter() ，后续的 Filter 就不会在处理这个请求了\nDispatcherServlet 它是 MVC 框架中用来接收所有请求的 Servlet，总是映射到 /\nDispatcherServlet 在接收到一个 Request 之后，会根据 Controller 的注解来决定调用哪个方法（需要先通过反射获取 Controller 的实例、get 或 post 方法、方法的参数类型、方法的参数名称），并获得方法返回的 ModelAndView ，或方法内部已经自行处理完毕，返回的就是 null\nView 使用来给模板引擎指定渲染的模板的，而 Model 是一个 Map\u0026lt;String, Object\u0026gt;，model 会由渲染引擎（如 Pebble 这类引擎）在生成模板的时候通过反射来获取数据\nInterceptor 拦截器，它是 Spring MVC 框架用于拦截 HTTP 请求的逻辑\n作用于请求到 controller 之前、controller 处理请求之后\n作用范围比 Filter 更小，更加精细\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/filter-dispatcherservlet-interceptor/","title":"Filter \u0026 DispatcherServlet \u0026 Interceptor"},{"content":"Session session用于指代服务器将数据存储在当前用户的会话中，这个session是由服务端保存的，具体来说，它是一个HttpSession类，我们在获取的时候是由HttpServletRequest.getSession()这样获取到当前用户的session，通过唯一表示符JSESSIONID在服务端区分。\n客户端只会保存JSESSIONID，服务端通过这个id查找到对应的session。\n服务端通过setAttribute()和getAttribute()来读或写session存储的属性及其值\n但是，HttpServletRequest在响应完请求后就会销毁，说明这个Session不是由HttpServletRequest，而是由tomcat的相关组件来处理的：\norg.apache.catalina.session.StandardSession:\nStandardSession是Tomcat中表示会话的类。每个会话对象都由这个类的一个实例表示，StandardSession对象包含了会话的所有数据，包括会话ID、会话属性（如user、name）、创建时间、最后访问时间等。 org.apache.catalina.session.StandardManager:\nStandardManager是Tomcat的默认会话管理器，它负责创建、查找、删除和持久化StandardSession对象。 当你通过HttpServletRequest.getSession()获取会话时，Tomcat实际上是通过StandardManager查找或创建一个StandardSession对象。 org.apache.catalina.Context:\nContext对象代表一个Web应用的上下文。在每个Context对象中，有一个Manager（即StandardManager）实例来管理该上下文的所有会话。 工作流程概述 创建会话: 当客户端第一次请求并调用HttpServletRequest.getSession()时，如果没有现有的会话，Tomcat会通过StandardManager创建一个新的StandardSession对象并返回。 这个新创建的会话对象会被StandardManager保存，以便在后续请求中使用。 管理会话生命周期: StandardManager会定期检查会话是否过期，并销毁过期的会话。 如果应用程序或服务器设置了持久化配置，StandardManager还可以将会话数据序列化到文件系统中，以便在服务器重启后恢复。 会话存储: 默认情况下，session数据存储在Tomcat服务器的内存中。StandardManager会持有所有活动会话的引用，并在Tomcat运行期间负责管理它们。 会话在Tomcat中的持有者 因此，在Tomcat中，HttpSession对象是由StandardSession类表示的，而这些会话对象由StandardManager持有和管理。即使HttpServletRequest对象被销毁，StandardSession对象依然存在于StandardManager中，直到会话超时或被显式销毁。\n如果Tomcat重启，默认情况下，保存在内存中的session会消失。这意味着如果没有特殊配置，当Tomcat重新启动时，所有活跃的session数据都会丢失，用户会话将被中断，用户需要重新登录或重新建立会话。\n持久化会话数据的方法 为了在Tomcat重启后保留session数据，可以使用以下方法：\n启用session持久化:\nTomcat提供了会话持久化的功能，可以将session数据序列化到磁盘上，并在服务器重启时重新加载。 这通过StandardManager的持久化机制来实现。你可以在\u0026lt;Context\u0026gt;配置中启用session持久化。 示例配置（在conf/context.xml或Web应用的META-INF/context.xml中）：\n1 \u0026lt;Manager pathname=\u0026#34;session.ser\u0026#34;/\u0026gt; 这里的pathname属性指定了会话数据文件的路径。如果不指定路径，Tomcat将默认保存会话数据到work目录下的session.ser文件中。 使用外部持久化存储:\n可以将session数据存储在外部数据库、Redis、Memcached等持久化存储中。通过这种方式，即使Tomcat重启，会话数据也能持久存在。 这需要自定义Manager类或者使用第三方的解决方案，例如使用RedisSessionManager来将session数据保存在Redis中。 总结 默认情况下，Tomcat重启后，session数据会丢失，因为它们存储在内存中。\n启用持久化 或 使用 外部存储 是保留session数据的两种常见方法。如果需要在重启后保持会话，建议配置持久化或者使用外部存储机制。\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/session/","title":"Session"},{"content":"测试文章 测试内容\n测试 toc 自动生成目录1 测试 toc 自动生成多级目录（二级目录） 测试 toc 自动生成多级目录（三级目录） 多级目录最多三层\n测试 toc 自动生成目录2 下面是图片↓↓↓↓↓↓↓↓↓↓↓↓\n上面是图片↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n图片中间不能有空格\n测试图片上传方案 测试代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* 读取配置文件 使用 @PropertySource(\u0026#34;app.properties\u0026#34;) 自动读取配置文件，Spring 容器看到这个注解后，自动读取这个配置文件 */ @Configuration @ComponentScan @PropertySource(\u0026#34;app.properties\u0026#34;) // 表示读取 classpath 的 app.properties @PropertySource(\u0026#34;smtp.properties\u0026#34;) public class AppConfig { @SuppressWarnings(\u0026#34;resource\u0026#34;) public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); UserService userService = context.getBean(UserService.class); userService.login(\u0026#34;bob@example.com\u0026#34;, \u0026#34;password\u0026#34;); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;ada\u0026#34;, 2); map.put(\u0026#34;awui\u0026#34;, 1); map.put(\u0026#34;dawcf\u0026#34;, 3); map.put(\u0026#34;afafds\u0026#34;, 4); for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + entry.getValue()); } } /* 注入的字符串语法 1.\u0026#34;${app.zone}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，启动将报错 2.\u0026#34;${app.zone:Z}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，就用使用默认值 */ @Bean ZoneId createZoneId(@Value(\u0026#34;${app.zone:Z}\u0026#34;) String zoneId) { return ZoneId.of(zoneId); } } ","date":"2023-08-24T09:52:54+08:00","image":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87_hu6886787404485992962.png","permalink":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","title":"测试文章"}]