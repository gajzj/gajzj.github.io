[{"content":"G1垃圾回收器详解 G1和CMS要求的内存模型不同\nG1具有软实时性，即用户可以指定垃圾回收的限时，G1会努力在这个时限内完成gc。通常设定一个合理的目标让90%的垃圾回收时间都在这个时限内。\nG1的内存模型 分区概念 分区Region G1采用分区的类似，将堆空间分为若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。可以通过-XX:G1HeapRegionSize=n指定分区大小(1MB~32MB，且必须是2的幂)，默认分为2048个分区。\n卡片Card 分区内部又会分为若干个大小为512 Byte 的卡片，全局卡片表记录了所有分区的卡片信息。每个卡片在全局卡片表中都有一个对应的条目。\n堆Heap 通过-Xms/-Xmx指定堆大小。当发送ygc或者mixgc，通过计算gc与应用的耗时比，自动调整对空间大小。gc频率过高则增加堆尺寸来减少gc频率。\n-XX:GCTimeRatio即为GC与应用的耗时比。\n空间不足时，g1会首先尝试增加堆空间，如果扩容失败则发起fullgc。\n分代模型 分代 Young代和Old代，Young代又包括Eden空间和Survivor空间。\n整个Young代内存占用初始空间-XX:G1NewSizePercent（默认整堆5%）与最大空间（默认60%）\nLocal alloction buffer （Lab） 应用线程占用TLAB来创建对象，而大部分都会落入Eden；\n每次gc时，每个gc线程同样可以独占一个GCLAB用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；\n对于Eden/Survivor空间晋升（Promption）到Survivor/老年代空间的对象，同样有GC独占PLAB\n这些缓冲区就是每个线程认领的内存分配，可以减少同步时间，提升GC效率\n分区模型 ","date":"2024-10-31T10:02:00+08:00","permalink":"https://example.com/p/g1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","title":"G1垃圾回收器"},{"content":"微信登录 小程序调用 wx.login 获得 jscode，然后交给服务器后端程序，然后后端调用 code2session 换取会话密钥\n","date":"2024-10-23T16:02:00+08:00","permalink":"https://example.com/p/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E5%AF%B9%E6%8E%A5/","title":"微信登录对接"},{"content":"远程调用的过程中，需要解决几个问题：\n1、业务健壮性：服务本身没有问题但受到下游服务影响导致异常\n2、级联失败：单个服务的故障会进而影响上游的所有服务\n微服务保护 服务保护方案 请求限流：降低了并发上线 线程隔离：降低了可用资源数量 服务熔断：降低了服务的完整度 这些方案都会导致体验上略有下降，属于降级方案。\n1.1.1请求限流 用于解决并发太高或者说突高的问题，避免服务因流量激增而出现故障\n1.1.2线程隔离 限定每个接口可用使用的资源范围，避免某个接口故障或压力过大导致整个服务不可用\n1.1.3服务熔断 线程隔离避免了雪崩，但故障服务依然会拖慢上游服务的响应速度\n1、服务调用失败后，做降级处理，如抛出异常或者是友好提示或者是默认数据\n2、统计服务提供方的异常比例，比例过高表示该接口会影响到其他服务，应该拒绝继续调用该接口，直接降级处理\nSentinel 配置Sentinel把请求方式+请求路径作为簇点源名\n1、请求限流\nhttps://b11et3un53m.feishu.cn/wiki/QfVrw3sZvihmnPkmALYcUHIDnff#share-DgvJdKYf1ot2R1xdlV8cQ1sknTd\n流控效果：\n快速失败 warm up 排队等待 2、线程隔离\n隔离故障服务的调用，避免雪崩\n因为我们是用 OpenFeign 作远程调用的，所以在 OpenFeign整合Sentinel\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 SpringBoot项目的tomcat最大线程数是200，运行的最大连接数是8192\n限制并发线程数，即五个线程数和qps无直接关系，实际的qps跟接口响应速度有关\n3、服务熔断\n先编写降级逻辑，然后做服务熔断\n降级逻辑 给FeignClien编写失败后的降级逻辑\n方式一：FallbackClass，无法对远程调用的异常做处理 方式二：FallbackFactory，可以对远程调用的异常做处理，一般选择这种 step1:在hm-api模块中给itemclient定义降级处理类，实现FallbackFactory\nstep2:在hm-api模块中的DefaultFeignConfig类中将ItemClientFallback注册为一个Bean\nstep3:在hm-api模块中的ItemClient接口中使用ItemClientFallbackFactory\n服务熔断 Sentinel的断路器可以统计慢请求比例和异常请求比例，超出阈值时，就会熔断该接口，即拦截该接口的一切请求，降级处理；当该接口回复正常时，再放行对于该接口的请求。\n这个断路器的用状态机来描述\nclosed open half-open 分布式事务 本地事务\n分支事务\n全局事务\n业务跨多个服务实现，跨多个数据源实现，就会产生分布式事务问题\n","date":"2024-10-22T16:02:00+08:00","permalink":"https://example.com/p/%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","title":"服务保护和分布式事务"},{"content":"Spring Cloud Config Spring Cloud Config 读取配置文件的步骤\n1、启动 XxxApplication 时，读取自身的 application.yml，获得 name 和 Config Server 地址；\n2、根据 name、profile 和 Config Server 地址，获取一个或多个由优先级的配置文件；\n3、按优先级合并配置项；\n4、如果配置项中存在环境变量，则使用 Xxx 应用本身的环境变量去替换占位符。\n网关 创建网关微服务 引入 SpringCloudGateway、NacosDiscovery 依赖 编写启动类 配置网关路由 网关路由配置 1 2 3 4 5 6 7 8 spring: cloud: gateway: routes: - id: item # 路由规则id，自定义，唯一 uri: lb://item-service # 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表 predicates: # 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务 - Path=/items/**,/search/** # 这里是以请求路径作为判断规则 GatewayProperties 读取配置，通过一个 List 来保存， 每个 RouteDefinition 就是具体的路由规则定义。 包含四个常见属性：\nid：路由唯一标识 predicates：路由断言，就是匹配条件 filters：路由过滤条件 uri：路由目标地址，lb://代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。 网关是所有微服务的入口，将登录校验的工作放到网关。在网关和用户服务保存密钥。\n网关过滤器\nGatewayFilter：路由过滤器 GlobalFilter：全局过滤器 微服务获取用户 网关通过请求头获取用户身份信息，继续通过http请求发送到微服务，这样就可以把用户信息传递到下游微服务。\n通过微服务的拦截器，存放到 ThreadLocal 中来提供服务内部用户信息的上下文\n微服务之间通过OpenFeign传递用户\nFeign提供一个拦截器接口 feign.RequestInterceptor\n在com.hmall.api.config.DefaultFeignConfig中添加一个Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Bean public RequestInterceptor userInfoRequestInterceptor(){ return new RequestInterceptor() { @Override public void apply(RequestTemplate template) { // 获取登录用户 Long userId = UserContext.getUser(); if(userId == null) { // 如果为空则直接跳过 return; } // 如果不为空则放入请求头中，传递给下游微服务 template.header(\u0026#34;user-info\u0026#34;, userId.toString()); } }; } 配置管理 配置共享 共享的配置抽取到Nacos统一管理\n在nacos添加共享配置 微服务拉取配置 3.1.2.拉取共享配置 接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的application.yaml配置合并，完成项目上下文的初始化。\n不过，需要注意的是，读取Nacos配置是SpringCloud上下文（ApplicationContext）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取application.yaml。\n也就是说引导阶段，application.yaml文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？\nSpringCloud在初始化上下文的时候会先读取一个名为bootstrap.yaml(或者bootstrap.properties)的文件，如果我们将nacos地址配置到bootstrap.yaml中，那么在项目引导阶段就可以读取nacos中的配置了。\n3.2.配置热更新 3.3.动态路由 路由配置是在项目启动时由org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator加载，一经加载就缓存到内存中的路由表中。\n3.3.1.监听nacos配置变更 创建ConfigService，目的是连接到nacos 添加配置监听器，编写配置变更的通知和处理逻辑 通过自动装配，实际上ConfigService已经创建好了，我们只需要通过NacosConfigManager去getConfigservice就可以了\n项目第一次启动时不仅仅要添加监听器，也要读取配置，所以我们用\n1 2 3 4 5 6 String getConfigAndSignListener( String dataId, // 配置文件id String group, // 配置组，走默认 long timeoutMs, // 读取配置的超时时间 Listener listener // 监听器 ) throws NacosException; 这个api，既可以配置监听器，也可以根据dataId和group读取配置并返回。\n3.3.2.更新路由 监听了配置，就需要用到org.springframework.cloud.gateway.route.RouteDefinitionWriter这个接口来更新路由也就是RouteDefinition\n3.3.3.实现动态路由 ","date":"2024-09-26T16:02:00+08:00","permalink":"https://example.com/p/spring-cloud/","title":"Spring Cloud"},{"content":"代码规范 很零散，暂时不做整理，先将就着看\n注意对每个规范要求的力度如：\n务必 应当 可以 对于集合，务必注释表明集合元素对应的具体语境 如：\n1 2 3 4 5 // 跟踪所有活动订单: Order ID =\u0026gt; OrderEntity final ConcurrentHashMap\u0026lt;Long, OrderEntity\u0026gt; activeOrders = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 跟踪用户活动订单: User ID =\u0026gt; Map(Order ID =\u0026gt; OrderEntity) final ConcurrentHashMap\u0026lt;Long, ConcurrentHashMap\u0026lt;Long, OrderEntity\u0026gt;\u0026gt; userOrders = new ConcurrentHashMap\u0026lt;\u0026gt;(); 对于复杂数据类型的返回值，应当在注释中给出返回示例 如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 统计信息 * * @return 返回的数据结构类似 * \u0026lt;pre\u0026gt; {@code * [ * {\u0026#34;pos\u0026#34;: \u0026#34;班主任\u0026#34;, \u0026#34;total\u0026#34;: 5}, * {\u0026#34;pos\u0026#34;: \u0026#34;学工主管\u0026#34;, \u0026#34;total\u0026#34;: 2}, * {\u0026#34;pos\u0026#34;: \u0026#34;咨询师\u0026#34;, \u0026#34;total\u0026#34;: 3} * ] * } \u0026lt;pre\u0026gt; */ @MapKey(\u0026#34;pos\u0026#34;) List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; countEmpJobData(); 对于写在 XxxMapper.xml，务必在每个 sql 操作前写注释隔开，xml 的可读性很差，不要雪上加霜 如:\n是不是非常的清爽\n","date":"2024-09-26T16:02:00+08:00","permalink":"https://example.com/p/spring-ioc/","title":"Spring IoC"},{"content":"Q1 json 传输的过程中，如果想要限制一个属性只能写或者只能读\n1 2 @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) @JsonProperty(access = JsonProperty.Access.READ_ONLY) 加在字段和加在方法上有区别\n加在字段上直接控制字段的序列化和反序列化行为\n加载方法上控制方法的调用来影响序列化和反序列化，通常用在有自定义逻辑时\nQ2 Interceptor 和 Filter 的作用范围\nInterceptor 的拦截范围其实就是 Controller 方法，它实际上就相当于基于 AOP 的方法拦截。 因为 Interceptor 只拦截 Controller 方法，所以返回 ModelAndView 并渲染后，后续处理就脱离了 Interceptor 的拦截范围（虚线框）\nFilter 的拦截范围\n好处 使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的@Order指定顺序。\nSpring作为老牌全能型框架，要想拦截请求进行一些统一的处理，我们有Filter、Interceptor、ControllerAdvice、AOP这么多种截面可供选择： Filter——作用在最外层，在请求进入Spring之前就触发，可以用于处理一些网络通信层面的东西； Interceptor——作用在Controller的外层，数据进入Controller层之前，或离开Controller的前后触发； ControllerAdvice——作用在Interceptor之内，数据进入Controller层但还没处理之前触发，用于预处理Controller层的RequestBody和ResponseBody，以及统一异常处理； AOP——作用于自己写的方法。 使用的时候遵循“最小作用域”原理，在保证能统一抽象出来的前提下，选择最近最小的那个截面。\nT1 DelegatingFilterProxy 是 spring 框架提供的用来让 Servlet 容器实例化的 Filter，间接引用 spring 容器实例化的 Filter\n比如我们在 spring 中声明一个 Component\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Component public class AuthFilter implements Filter { @Autowired UserService userService; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; // 获取Authorization头: String authHeader = req.getHeader(\u0026#34;Authorization\u0026#34;); if (authHeader != null \u0026amp;\u0026amp; authHeader.startsWith(\u0026#34;Basic \u0026#34;)) { // 从Header中提取email和password: String email = prefixFrom(authHeader); String password = suffixFrom(authHeader); // 登录: User user = userService.signin(email, password); // 放入Session: req.getSession().setAttribute(UserController.KEY_USER, user); } // 继续处理请求: chain.doFilter(request, response); } } 因为 AuthFilter 只是一个普通的 Bean，Servlet 容器并不知道，所以它不会起作用。\n如果我们直接在web.xml中声明这个AuthFilter，注意到AuthFilter的实例将由Servlet容器而不是Spring容器初始化，因此，@Autowire根本不生效，用于登录的UserService成员变量永远是null。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;web-app\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;authFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.DelegatingFilterProxy\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;authFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; ... \u0026lt;/web-app\u0026gt; 实现原理：\nServlet容器从web.xml中读取配置，实例化DelegatingFilterProxy，注意命名是authFilter； Spring容器通过扫描@Component实例化AuthFilter。 当DelegatingFilterProxy生效后，它会自动查找注册在ServletContext上的Spring容器，再试图从容器中查找名为authFilter的Bean，也就是我们用@Component声明的AuthFilter。\n","date":"2024-09-21T16:02:00+08:00","permalink":"https://example.com/p/springmvc/","title":"springMVC"},{"content":"Q1 Spring 容器由谁来创建 Web 程序总是由 Servlet 容器创建，那么在一个 Web 程序中，那么，Spring 容器应该由谁创建？在什么时候创建？Spring 容器中的 Controller 又是如何通过 Servlet 调用的？\n在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种最简单的启动Spring容器的方式。\n第一步，我们在web.xml中配置Spring MVC提供的DispatcherServlet：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextClass\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;com.itranswarp.learnjava.AppConfig\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;0\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 初始化参数contextClass指定使用注解配置的AnnotationConfigWebApplicationContext，配置文件的位置参数contextConfigLocation指向AppConfig的完整类名，最后，把这个Servlet映射到/*，即处理所有URL。\n上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的DispatcherServlet，在DispatcherServlet启动时，它根据配置AppConfig创建了一个类型是WebApplicationContext的IoC容器，完成所有Bean的初始化，并将容器绑到ServletContext上。\n因为DispatcherServlet持有IoC容器，能从IoC容器中获取所有@Controller的Bean，因此，DispatcherServlet接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的ModelAndView决定如何渲染页面。\nQ2 Spring Bean 的生命周期 Spring Bean 的生命周期\n下图源自框架篇-05-Spring-bean的生命周期_哔哩哔哩_bilibili\n1、首先是 BeanDefinition，见名字知意，Bean 的定义：\n通过 xml 配置一个 Bean（现在基本不用了）对应需要创建的 ApplictionContext（顶层接口）为 ClassPathXmlApplicationContext（实现类） 通过注解配置一个 Bean（主流，更简洁），使用 @Bean 标注方法，一般叫做 createXxx（比如要创建数据库连接池的就叫 createDataSource），这种方法是用来告诉 IoC 容器如何创建一个组件，然后对应需要创建 AnnotionApplicationContext Spring 容器\nApplicationContext 就是 Spring 容器，它有很多实现类，并且 Spring 还提供了另一种 IoC 容器叫 BeanFactory\n二者的区别主要在于 ApplicationContext 会一次性创建所有的 Bean，而 BeanFactory 是按需创建的（很少使用）。ApplicationContext 还有一些额外的功能这里暂不展开\n2、然后是依赖注入\n注入当前这个组件需要注入的依赖（例如 @AutoWired @Value 标注的属性）\n3、XxxAware接口和Xxx接口（加分点，按照 Aware 接口的设计来说，实际上做事的都是 Xxx，我们直接注入并 Xxx 也可以，但视频中既然体现了这一点，那就展开讲讲）\n该视频从引出了一个不太常见的 Aware 接口的概念，这是一种将功能实现和使用分离的设计：\nXxx 接口：Xxx 接口提供了一组功能定义 定义接口 直接使用 XxxAware 接口：XxxAware 接口允许 Spring 容器向实现该接口的类注入特定的上下文或资源。 提供上下文 获取上下文 这种设计体现的优势：\n解耦\nAware 接口的实现类不需要直接依赖于特定的上下文，而是通过接口获取所需要的资源\n灵活\n实现 XxxAware 接口的类可以在不同的上下文中灵活使用，而无需修改其代码。这使得类的重用性更强。\n关注点分离\n通过将功能定义（Xxx 接口）与上下文访问（XxxAware 接口）分离，开发者可以更清晰地关注各自的职责，使代码更加清晰和易读。（笔者注：我们想使用某个东西的时候肯定更希望直接知道怎么用，而不关心它内部是如何实现的）\n易于拓展\n当需要增加新的功能或上下文支持时，只需实现新的 XxxAware 接口，而不需要对现有的业务逻辑做大量修改。\n明白了吗，实际上这里的 Aware 就是要使用 Xxx，我们在这一步通过 Aware 接口把我们需要的上下文注入到这里，就这么简单\n4、before\n不知道具体要干什么，管他呢反正你知道它是在初始化之前执行的就完事了\n5、初始化方法\n我们在这一阶段会去执行组件的 Init 方法（InitializingBean @PostConstruct），完成类的静态资源的加载\n6、after\n初始化之后，增强这个 Bean\n7、destory\n1 ((ConfigurableApplicationContext) context).close(); close 之后就会触发 Bean 的销毁\ntips：本题的内容可能需要观看 day17 的 Bean 管理内容辅以理解\n","date":"2024-09-15T16:02:00+08:00","permalink":"https://example.com/p/spring/","title":"spring"},{"content":"Q1 mapper\nMapper 就是用来执行 SQL 语句的\nQ2 ORM 框架是如何跟踪 Java Bean 的修改，以便在 update() 操作中更新必要的属性\n使用 Proxy 模式，从 ORM 框架读取的 User 示例实际上并不是 User 类，而是代理类，代理类继承自 User 类，但对每个 setter 方法都做了覆写\nQ3 ORM 分为全自动和半自动框架，有什么区别\nQ4 Spring 提供的 JdbcTemplate 相对于全自动的 ORM 框架有什么差别，有什么优势\n区别： 查询后需要手动提供 Mapper 实例一边把 ResultSet 的每一行变为 Java 对象 增删改操作所需的参数列表，需要手动传入，即把 User 实例变为 [user.id, user.name, user.email] 这样的列表，比较麻烦 优势：确定性 每次读取操作一定是数据库操作而不是缓存，即每次读取操作一定是数据库操作而不是缓存， 而 ORM 框架有一级二级缓存机制 缺点：繁琐、复杂 解决方案： 使用半自动的 ORM 框架 MyBatis，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。 Q5 sql 注入是什么，怎么解决\nStatement\nPrepareStatement\n#{}\n${} 用在动态表名\nQ6 给一个场景：\n现在 UserService 中有一个 updateUser(Long id, String name) 方法，而 UserMapper 中 update 操作只有一个 update(User user) 方法（get、delete、insert都有）\n在这里你是会给接口新加一个方法用于更新 user 的 name；还是用 UserMapper 提供的 getById 获取一个 User 实例，更改 name 后再调用 update(user) 把这个实例传入。\n注：User 继承自 AbstractEntity，里面有多个字段如 id，createdTime，updatedTime\nQ7 如果使用 PageHelper 处理分页查询，会不会有线程安全问题\nPageHelper的使用\nPageHelper 只会对紧跟在其后的第一条 SQL 语句进行分页处理，如：\n1 2 3 4 5 6 7 8 9 @Override public PageBean page(Integer page, Integer pageSize) { PageHelper.startPage(page, pageSize); List\u0026lt;Emp\u0026gt; empList = empMapper.list(); Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; return new PageBean(p.getTotal(), p.getResult()); } 只要可以保证在 PageHelper 方法调用后紧跟着查询方法，就是安全的。\n线程安全问题的产生原因\nPageHelper 使用了静态的 ThreadLocal 参数，这意味着分页设置是与当前啊线程相关联的。\n1 2 3 4 5 6 7 8 9 //使用PageHelper分页助手插件进行分页操作 PageHelper.startPage(0, 10); List\u0026lt;Country\u0026gt; list; if(param1 != null){ list = countryMapper.selectIf(param1); } else { list = new ArrayList\u0026lt;Country\u0026gt;(); } Page\u0026lt;CheckItem\u0026gt; page = checkItemDao.selectByCondition(queryString); 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。\nQ8 对于一个请求参数\n1 2 3 4 5 6 7 8 9 10 11 12 @Data public class EmpQueryParam { // 对于请求中的参数，只有映射到 String 类型时会把空字符串映射，对于其他的类型遇到 \u0026#34;\u0026#34; 会映射为 null private Integer page = 1; // 页码，默认值1 private Integer pageSize = 10; // 每页展示记录数，默认值10 private String name; // 姓名 private Integer gender; // 性别 @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate begin; // 入职开始时间， @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate end; // 入职结束时间 } 编写动态 SQL 语句如下\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.gaj.pojo.Emp\u0026#34;\u0026gt; select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;param.name != null and param.name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; e.name like concat(\u0026#39;%\u0026#39;, #{param.name}, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;param.gender != null\u0026#34;\u0026gt; and e.gender = #{param.gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;param.begin != null and param.end != null\u0026#34;\u0026gt; and e.entry_date between #{param.begin} and #{param.end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by e.update_time desc \u0026lt;/select\u0026gt; 前端的请求\nhttp://localhost:90/api/emps?begin=\u0026amp;end=\u0026amp;gender=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=5 这里的 begin end gender 都是空字符串，为什么对它们不用判空字符串（只用判空），对 name 要判\n很显然Integer 和 LocalDate 只会为 null，不会为空字符串， 简单来说这里只有 String 需要判断是否为 \u0026quot;\u0026quot; 因为编译器已经确保了 \u0026quot;\u0026quot; 空字符串不会映射到其他引用类型\nQ9 spring 开启一个事务是怎么样的，底层是通过操作什么来开启\n答题思路\n简述 spring 框架中事务如何启用 @EnableTransaction PlatformTransactionManager 数据库底层 显式事务和隐式事务 JDBC 开启事务的关键代码是 conn.setAutoCommit(false) 表示关闭提交 spring 启用声明式事务 spring 中启用声明式事务和和开启一个声明式事务没什么好说的，前者需要在启动类上加上@EnableTransaction注解；后者只要在开启一个事务的类上（或者方法上）加上@Transactional注解，然后在需要回滚的地方抛出RunTimeException（默认情况下，也可以在Transactional注解声明rollbackFor属性），spring 的事务管理类（PlatformTransactionManager）会自动rollback。\nspring 启用编程式事务 spring 中使用编程式事务主要是PlatformTransactionManager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 TransactionStatus tx = null; try { // 开启事务: tx = txManager.getTransaction(new DefaultTransactionDefinition()); // 相关JDBC操作: jdbcTemplate.update(\u0026#34;...\u0026#34;); jdbcTemplate.update(\u0026#34;...\u0026#34;); // 提交事务: txManager.commit(tx); } catch (RuntimeException e) { // 回滚事务: txManager.rollback(tx); throw e; } 比较繁琐\n底层启用事务的原理 若是从数据库层面来说的话，开启一个事务是用BEGIN，COMMIT提交一个事务，ROLLBACK回滚事务。事务有隔离级别，但不是本题的讨论范围这里不做讲解。\n主要的答题点应为 JDBC 层面的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Connection conn = openConnection(); try { // 关闭自动提交: conn.setAutoCommit(false); // 执行多条SQL语句: insert(); update(); delete(); // 提交事务: conn.commit(); } catch (SQLException e) { // 回滚事务: conn.rollback(); } finally { conn.setAutoCommit(true); conn.close(); } 开启事务的关键代码是 conn.setAutoCommit(false) 表示关闭提交。\n因为事务分为显示事务和隐式事务，对于单条 SQL 语句，数据库系统自动将其作为一个事务执行，这就是隐式事务。\n关闭自动提交就代表开启了显示事务，然后在执行多条sql语句的过程中如果 catch 到了异常，就可以选择回滚事务，如果程序正常执行就将 commit\n自动提交更改后必须要改回原来的值\n所以 spring 框架在开启事务的时候其实就是对自动提交的操作。\nQ10 使用@Transactional注解可以开启一个事务，在什么时候会回滚？\n默认抛出RuntimeException异常时会回滚，非RuntimeException（包括IOException、ReflectiveOperationException等等）不会回滚。\n为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作。\nQ11 Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？\nQ12 事务失效场景\n事务方法非 public 修饰\n非事务方法调用事务方法\n事务方法的异常被捕获了\n事务异常类型不对\n事务传播行为不对\n没有被 Spring 管理\nQ13 数据库事务具有 ACID 特性\nAtomicity 原子性 Consistency 一致性 Isolation 隔离性 Durability 持久性 Q14 SQL 标准定义了哪四种隔离级别\nIsolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - Q15 你实现过文件上传功能吗，说一下你项目中的方案\nOSS\n有什么好处\nQ16 mybatis 新增操作怎么获取新增记录的主键，怎么确保它的正确映射\n@Options(useGeneratedKeys = true, keyProperty = \u0026quot;id\u0026quot;, keyColumn = \u0026quot;id\u0026quot;)\nproperty 和 column\nQ17 跨表操作在我们查询的时候非常常见，你怎么决定是在 mapper 层通过表连接 SQL JOIN 来处理跨表，还是在 service 层做跨表，都有什么优劣\n思路\n性能 灵活、拓展性 跨表操作在 mapper 层\n优点 性能更优，数据库引擎的优化 事务的一致性 缺点 复杂的 sql 维护困难 耦合性高 跨表操作在 service 层\n优点 可读性、可维护性 灵活性 可拓展性 缺点 性能 事务管理复杂 我更偏向将复杂的跨表操作放在 service 层，项目的稳健性是非常重要的，非常简单的跨表操作才考虑放在mapper 层。放在 mapper 层虽然提高了性能且减少了事务管理的麻烦，但是带来的弊端是在项目未来继续扩张时一定会碰到的。\n避免过早优化\nmapper 层的跨表操作通常遵循低复杂性和高效率的原则。因此，通常建议 mapper 层的跨表操作仅限于必要且简单的场景。\n复杂查询的最佳实践\n在开发中，遇到需要跨表操作的场景时，建议采取以下策略：\n拆分查询：尽量避免过度依赖 JOIN，可以通过多次查询分别获取数据，再通过 service 层合并处理。 视图或存储过程：如果有较为复杂的跨表查询需求，可以考虑在数据库中创建视图或者存储过程，将复杂的逻辑封装在数据库中，以便简化 mapper 层的操作。 DTO 或 VO 封装：将查询结果封装到 DTO 或 VO，而不是直接在 mapper 层进行业务逻辑处理。例如，查询班级与班主任的名字，可以在 service 层执行两次查询，将数据封装成一个完整的 DTO 返回给前端。 ","date":"2024-09-14T20:02:00+08:00","permalink":"https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"数据库"},{"content":"","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/mysql%E7%B4%A2%E5%BC%95/","title":"mysql索引"},{"content":"Spring IoC ","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/spring-ioc/","title":"Spring IoC"},{"content":"Q1 private final Logger logger = LoggerFactory.getLogger(getClass());\n还是\nprivate statci final Logger logger = LoggerFactory.getLogger(ClassName.class);\n两种写法各有优缺点，选择哪一种取决于你的需求和项目风格。\nprivate final Logger logger = LoggerFactory.getLogger(getClass());\n优点：\n通用性高：可以用于任何类，无需手动更新类名（适合复制粘贴代码到其他类中时无需修改）。 适应继承：如果这个类被继承，getClass() 会返回子类的类型，日志会正确显示子类的类名。 缺点：\n运行时开销：getClass() 是在运行时确定的，虽然开销不大，但比静态方法稍微慢一些。 private static final Logger logger = LoggerFactory.getLogger(ClassName.class);\n优点：\n效率稍高：因为 ClassName.class 是在编译时确定的，性能上稍微优于 getClass()。 符合静态常量的惯例：logger 是静态的，通常被定义为 static final，符合惯例。 日志清晰：明确指定类名，在日志中始终使用这个类的名字，不管它是否被继承。 缺点：\n继承问题：如果类被继承，日志依然显示的是父类的类名，而不是子类的名字，这在需要记录子类日志时可能不是理想的选择。 类名需要手动更新：如果你复制这个类或重命名它，你需要手动更新 ClassName，否则会导致日志记录混乱。 推荐用法： 使用 static final 和类名 的方式更为常见，尤其在不涉及继承的情况下。这种方式在性能上更高效，且更符合静态常量的使用习惯。 1 private static final Logger logger = LoggerFactory.getLogger(ClassName.class); 如果你的类可能会被继承并且你希望日志记录子类的类名，则可以考虑使用 getClass()： 1 private final Logger logger = LoggerFactory.getLogger(getClass()); 总结：对于一般类，建议使用 static final Logger 和类名；如果有继承需求，使用 getClass() 更灵活。\n单体项目平滑发布 蓝绿发布\n单机多双结点\nk8s和docker\n广告投放定时任务 从半小时到秒级-京东定时任务优化实战_哔哩哔哩_bilibili\n限制堆外内存 深分页 limit 5000000, 100 和 where id \u0026gt; 5000000 limit 100\n","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/%E9%9A%8F%E8%AE%B0/","title":"随记"},{"content":"Q1 private final Logger logger = LoggerFactory.getLogger(getClass());\n还是\nprivate statci final Logger logger = LoggerFactory.getLogger(ClassName.class);\n两种写法各有优缺点，选择哪一种取决于你的需求和项目风格。\nprivate final Logger logger = LoggerFactory.getLogger(getClass());\n优点：\n通用性高：可以用于任何类，无需手动更新类名（适合复制粘贴代码到其他类中时无需修改）。 适应继承：如果这个类被继承，getClass() 会返回子类的类型，日志会正确显示子类的类名。 缺点：\n运行时开销：getClass() 是在运行时确定的，虽然开销不大，但比静态方法稍微慢一些。 private static final Logger logger = LoggerFactory.getLogger(ClassName.class);\n优点：\n效率稍高：因为 ClassName.class 是在编译时确定的，性能上稍微优于 getClass()。 符合静态常量的惯例：logger 是静态的，通常被定义为 static final，符合惯例。 日志清晰：明确指定类名，在日志中始终使用这个类的名字，不管它是否被继承。 缺点：\n继承问题：如果类被继承，日志依然显示的是父类的类名，而不是子类的名字，这在需要记录子类日志时可能不是理想的选择。 类名需要手动更新：如果你复制这个类或重命名它，你需要手动更新 ClassName，否则会导致日志记录混乱。 推荐用法： 使用 static final 和类名 的方式更为常见，尤其在不涉及继承的情况下。这种方式在性能上更高效，且更符合静态常量的使用习惯。 1 private static final Logger logger = LoggerFactory.getLogger(ClassName.class); 如果你的类可能会被继承并且你希望日志记录子类的类名，则可以考虑使用 getClass()： 1 private final Logger logger = LoggerFactory.getLogger(getClass()); 总结：对于一般类，建议使用 static final Logger 和类名；如果有继承需求，使用 getClass() 更灵活\n单体项目平滑发布 蓝绿发布\n单机多双结点\nk8s和docker\n广告投放定时任务 从半小时到秒级-京东定时任务优化实战_哔哩哔哩_bilibili\n限制堆外内存 深分页 limit 5000000, 100 和 where id \u0026gt; 5000000 limit 100\n服务器情况 ","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/%E9%9A%8F%E8%AE%B0/","title":"随记"},{"content":"1. main 分支 用途: main（或 master）是项目的主要分支，通常代表的是当前稳定和可发布的版本。它是用户和生产环境直接使用的分支。 说明: 代码合并到 main 分支时，通常已经经过充分的测试，并且功能已经完全实现。 2. build 分支 用途: 用于存储构建脚本、构建配置文件或持续集成和部署的代码。 说明: 该分支可能包含自动化构建系统所需的工具或配置文件，比如 Jenkinsfile、Dockerfile 或者 CI/CD 的脚本。 3. exp 分支 用途: exp 是实验（experimental）的缩写。用于进行实验性的开发。 说明: 该分支可能包含尚未确定的功能或新技术的尝试，通常不保证稳定性，并且可能会在未来被删除或合并到其他分支。 4. feat 分支 用途: feat 是 feature 的缩写。用于开发新功能。 说明: 通常每个功能都会有一个单独的分支（如 feat/feature-name），开发完成并通过测试后再合并到 dev 或 main。 5. fix 分支 用途: fix 分支专门用于修复 bug。 说明: 修复特定问题或 bug 的代码会先提交到 fix 分支，然后再合并到 dev 或 main，以确保问题修复后能立即进入下一步发布流程。 6. issues 分支 用途: 与项目的 issue 管理工具（如 GitHub Issues）相结合，专门用于处理特定的 issues（问题/任务）。 说明: 该分支通常用于实现特定问题的修复或功能改进，分支名称通常会包括 issue 的编号（如 issues/#123）。 7. perf 分支 用途: perf 是 performance 的缩写。用于进行性能优化。 说明: 该分支会涉及到代码的性能改进，例如减少内存使用、优化算法等，然后这些改动会被测试和验证后合并回主分支。 8. refactor 分支 用途: 用于重构代码。 说明: 该分支上的改动通常不影响功能，但会改善代码质量、结构和可维护性。这些改动通常需要经过充分的测试，以确保没有引入新的 bug。 9. rework 分支 用途: 专门用于重新开发或重写某部分代码。 说明: 当某个功能或模块需要大规模重写而不破坏现有版本时，rework 分支会被创建。在完成后，这些改动可以被合并到 dev 或其他相应的分支。 10. dev 分支 用途: dev 是开发分支，通常是用于日常开发的主要分支。 说明: 这个分支包含尚在开发中的功能和改进，在合并到 main 之前通常会在这个分支进行测试和 bug 修复。 11. 0.17_LTS 分支 用途: 该分支代表一个长期支持（Long Term Support, LTS）的版本。 说明: 此版本通常比最新版本更稳定，且会定期接收安全更新和重要的 bug 修复。它可能用于需要长期支持的客户或产品环境。 12. litecommand 分支 用途: 可能用于开发一个名为 litecommand 的特定功能或模块。 说明: 该分支上可能包含与 litecommand 功能相关的代码，开发完成后再合并回主分支。 ","date":"2024-09-11T20:02:00+08:00","permalink":"https://example.com/p/git%E5%88%86%E6%94%AF/","title":"Git分支"},{"content":"多线程 线程 创建线程 继承 Thread 类，重写 run 方法，然后创建子类对象调用 start() 方法 实现 Runnable 接口，重写 run 方法，然后创建实现类对象并传递给一个 Thread，调用 start() 实现 Callable 接口，重写 call 方法，然后创建实现类对象并传递给一个 FutureTask 类对象，最后传递给一个 Thread 对象调用 start() 线程的六种状态 NEW 新建状态 RUNNABLE 可运行状态，线程调用 start() 方法后即处于这个状态 BLOCKED 锁阻塞状态，没有获取到锁即处于这个状态 WAITING 无线等待状态，线程执行时被调用了 wait() 方法处于这个状态 TIMED_WAITING 计时等待状态，线程执行时被调用了 sleep(ms) 或 wait(ms) 方法即处于这个状态 TERMINATED 终止状态，线程执行完毕或遇到异常即处于这个状态 线程池 ThreadPoolExcutor 线程池内部使用 AtomicTnteger 来维护 runState(运行状态) 和 workerCount(线程数量) 用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。\n顶层接口是 Excutor\n线程池的五种运行状态 RUNNING 能接受新提交的任务，并且也能处理阻塞队列中的任务 SHUTDOWN 关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中保存的任务 STOP 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程 TIDYING 所有的任务都终止了，workerCount(有效线程数)为0 TERMINATED 在 terminated() 方法执行完后加入该状态 Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)\nQ 乐观锁 乐观锁的基本原理： 乐观锁的思想是假设并发情况下不会有冲突，只有在提交数据时才会检测是否存在冲突。\n","date":"2024-09-01T21:52:54+08:00","permalink":"https://example.com/p/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"多线程"},{"content":" Spring 简化了数据库访问：\n提供简化的访问 JDBC 的模板类，不必手动释放 提供一个统一的 DAO 类以实现 Data Access Object模式 把 SQLException 封装为 DataAccessException，这是一个 RuntimeException 能方便地继承 Hibernate、JPA 和 MyBatis 这些数据库访问框架 使用 JDBC 引入以下依赖：\norg.springframework:spring-context:6.0.0 org.springframework:spring-jdbc:6.0.0 jakarta.annotation:jakarta.annotation-api:2.1.1 com.zaxxer:HikariCP:5.0.1 org.hsqldb:hsqldb:2.7.1 在 AppConfig 中，创建以下几个必须的 Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) // 读取数据库配置文件 public class AppConfig { @Value(\u0026#34;${jdbc:url}\u0026#34;) // 注入配置文件的相关配置 String jdbcUrl; @Value(\u0026#34;${jdbc.username}\u0026#34;) String jdbcUsername; @Value(\u0026#34;${jdbc.password}\u0026#34;) String jdbcPassword; @Bean DataSource createDataSource() { // 创建需要用到注入的配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(jdbcUrl); config.setUsername(jdbcUsername); config.setPassword(jdbcPassword); config.addDataSourceProperty(\u0026#34;autoCommit\u0026#34;, \u0026#34;true\u0026#34;); config.addDataSourceProperty(\u0026#34;connectionTimeout\u0026#34;, \u0026#34;5\u0026#34;); config.addDataSourceProperty(\u0026#34;idleTimeout\u0026#34;, \u0026#34;60\u0026#34;); // 创建 DataSource 实例，实际类型为 HikariDataSource return new HikariDataSource(config); } @Bean JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) { return new JdbcTemplate(dataSource); } } 在需要访问数据库的 Bean 中，注入 JdbcTemplate：\n1 2 3 4 @Component public class UserService { @Autowired JdbcTemplate jdbcTemplate; 使用 JdbcTemplate T execute(ConnectionCallback action) 方法，提供了 Connection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public User getUserById(long id) { // 传入 ConnectionCallback return jdbcTemplate.execute((Connection conn) -\u0026gt; { // 可以直接使用 conn 实例，不用释放，回调结束后 jdbcTemplate 自动释放 // 在内部手动创建的 PreparedStatement、ResultSet 必须用 try(...) 释放 try (var ps = conn.prepareStatement(\u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;)) { ps.setLong(1, id); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by id:\u0026#34; + id); } } }); } T execute(String sql, PreparedStatementCallback action)，PreparedStatement 实例已经由JdbcTemplate 创建，并在回调后自动释放: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public User getUserByName(String name) { return jdbcTemplate.execute(\u0026#34;SELECT * FROM users WHERE name = ?\u0026#34;, (PreparedStatement ps) -\u0026gt; { // PreparedStatement 实例已经由 JDBCTemplate 创建，并在回调后自动释放 ps.setString(1, name); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by name: \u0026#34; + name); } }); } T queryForObject(String sql, RowMapper rowMapper, Object\u0026hellip; args)，传入 SQL 以及 SQL 参数后，JdbcTemplate 会自动创建 PreparedStatement，自动执行查询并返回 ResultSet，我们提供的RowMapper 需要做的事情就是把 ResultSet 的当前行映射成一个 JavaBean 并返回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public User getUserByEmail(String email) { // 传入 SQL，参数和 RowMapper 实例 return jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM users WHERE email = ?\u0026#34;, (ResultSet rs, int rowNum) -\u0026gt; { // 将 ResultSet 的当前行映射为一个 JavaBean return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } ); } JdbcTemplate 设计的目的就是为了避免繁琐的 try\u0026hellip;catch 语句\nquery() 方法返回多行记录，传入 SQL 语句，SQL 参数以及 RowMapper 实例\nSpring 提供了 BeanPropertyRowMapper\n1 2 3 4 5 6 7 8 public List\u0026lt;User\u0026gt; getUsers(int pageIndex) { int limit = 2; int offset = limit * (pageIndex - 1); return jdbcTemplate.query(\u0026#34;SELECT * FROM users LIMIT ? OFFSET ?\u0026#34;, new BeanPropertyRowMapper\u0026lt;\u0026gt;(User.class), limit, offset ); } 插入、更新、删除使用 update() 1 2 3 4 5 6 7 public void updateUser(User user) { // 传入 SQL、SQL 参数、返回更新的行数 if (1 != jdbcTemplate.update(\u0026#34;UPDATE users SET name = ? WHERE id = ?\u0026#34;, user.getName(), user.getId())) { throw new RuntimeException(\u0026#34;User not found by id\u0026#34;); } } 使用 KeyHolder 获取插入后的自增值\nupdate() 时传入 PreparedStatementCreator 和 KeyHolder 两个参数\nholder.getKey() 可以获取返回自增值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public User register(String email, String password, String name) { KeyHolder holder = new GeneratedKeyHolder(); if (1 != jdbcTemplate.update( // 参数 PreparedStatementCreator (conn) -\u0026gt; { PreparedStatement ps = conn.prepareStatement(\u0026#34;INSERT INTO users(email, password, name) VALUES (?,?,?)\u0026#34;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, email); ps.setString(2, password); ps.setString(3, name); return ps; }, // 参数 KeyHolder holder )) { throw new RuntimeException(\u0026#34;Insert failed.\u0026#34;); } return new User(holder.getKey().longValue(), email, password, name); } JdbcTemplate 用法总结 简单查询使用 query()，只需要提供 SQL 语句、参数和 RowMapper 更新操作使用 update()，只需要提供 SQL 语句和参数 任何复杂的操作使用 execute(ConnectionCallback)，拿到了 Connection 就可以做任何 JDBC 操作 设计表结构的时候要和 JavaBean 的属性一一对应，这样就可以方便的使用 Spring 提供的 BeanPropertyRowMapper。\n如果表结构和 JavaBean 不一致，则需要稍微改写查询使得结果集和 JavaBean 保持一致\n数据库列名与 JavaBean 属性名不一致\n在 SQL 查询中使用别名将列名与 JavaBean 属性名对齐。\n1 SELECT user_id AS id, user_name AS name FROM users LIMIT ? OFFSET ? 数据库表包含 JavaBean 中没有的字段\n在查询中只选择 JavaBean 中定义的字段.\nJavaBean 中包含数据库表没有的字段\nJavaBean 中的字段需要进行转换\n1 SELECT user_id AS id, user_name AS name, CASE WHEN is_active = 1 THEN TRUE ELSE FALSE END AS active FROM users LIMIT ? OFFSET ? 需要使用自定义的行映射器 1 2 3 4 5 6 7 8 9 10 11 class UserRowMapper implements RowMapper\u0026lt;User\u0026gt; { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setId(rs.getLong(\u0026#34;user_id\u0026#34;)); user.setName(rs.getString(\u0026#34;user_name\u0026#34;)); user.setActive(rs.getInt(\u0026#34;is_active\u0026#34;) == 1); // 其他属性的映射 return user; } } 使用声明式事务 Spring 中提供了一个 PlatformTransactionManager 来表示事务管理器。事务由 TransactionStatus 表示。\n手写事务代码的话，一般在 try{\u0026hellip;..} 中执行数据操作，然后 catch{\u0026hellip;..} 中捕获错误然后 rollback 事务，没有捕获到错误的话就 commit() 提交事务。\n启用声明式事务 在 AppConfig 中追加一个 PlatformTransactionManager 对应的 Bean，然后再加一个 @EnableTransactionManagement 注解\nPlatformTransactionManager 对应的 Bean：\n1 2 3 4 5 @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) { // 实际类型是 DataSourceTransactionManager return new DataSourceTransactionManager(dataSource); } @EnableTransactionManagement 注解\n1 2 3 4 5 6 7 8 9 10 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) @EnableTransactionManagement // 启用声明式事务 public class AppConfig { @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } } 这样就启用了声明式事务，然后对需要事务支持的方法或者在 Bean 上加（表示对所有 public 方法都具有事务支持），加上一个 @Transactional 注解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Transactional public User register(String email, String password, String name) { KeyHolder holder = new GeneratedKeyHolder(); if (1 == jdbcTemplate.update( // 将会抛出异常 // 参数 PreparedStatementCreator (conn) -\u0026gt; { PreparedStatement ps = conn.prepareStatement(\u0026#34;INSERT INTO users(email, password, name) VALUES (?,?,?)\u0026#34;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, email); ps.setObject(2, password); ps.setString(3, name); return ps; }, // 参数 KeyHolder holder )) { throw new RuntimeException(\u0026#34;Insert failed, will roll back.\u0026#34;); // 将会 rollback } return new User(holder.getKey().longValue(), email, password, name); } Spring 会通过 AOP 代理实现事务的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... PlatformTransactionManager txManager = ... public User register(String email, String password, String name) { TransactionStatus tx = null; try { tx = txManager.getTransaction(new DefaultTransactionDefinition()); target.register(email, password, name); txManager.commit(tx); } catch (RuntimeException e) { // 默认情况下只有 RuntimeException 触发回滚 txManager.rollback(tx); throw e; } } ... } 针对异常类型决定是否回滚 1 @Transactional(rollbackFor = {RuntimeException.class, IOException.class}) 强烈建议业务异常体系从 RuntimeException 派生\n事务边界 一般来说一个事务的开始就是方法的开始，事务的结束就是方法的结束。\n新用户注册的事务：\n1 2 3 4 5 6 7 @Component public class UserService { @Transactional public User register(String email, String password, String name) { // 事务开始 .... } // 事务结束 } 发表博客的事务：\n1 2 3 4 5 6 7 @Componet public class BlogService { @Transaction public Blog addBlog(User user, String content) { // 事务开始 ... } // 事务结束 } 如果我们想要这样的效果：新用户注册后自动发表一个打招呼的博客：\n1 2 3 4 5 6 7 8 9 10 11 12 @Component public class UserService { @Autowired BlogService blogService; @Transactional public User register(String email, String password, String name) { .... User user = jdbcTemplate.insert(\u0026#34;....\u0026#34;); blogService.addBlog(user.id, \u0026#34;Hello Blog!\u0026#34;); } } 如果 addBlog() 抛出异常， register() 是否也需要回滚？\n事务传播 Spring 为事务传播定义的几个级别\nREQUIRED\n默认的事务传播级别，表示如果当前没有事务，就创建一个事务，如果当前有事务，就加入到当前事务中执行\nSUPPORTS\n表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行\nMANDATORY\n表示必须要存在当前事务并加入执行，否则将抛出异常\nREQUIRES_NEW\n表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已有事务，将当前事务挂起，等新事务完成后，再恢复执行\nNOT_SUPPORTED\n表示不支持事务，如果当前有事务，将当前事务挂起，等这个方法执行完成后，再恢复执行\nNEVER\n和 NOT_SUPPORTED 相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行\nNESTED\n表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务\n默认的 REQUIRED 已经满足绝大部分需求，SUPPORTS 和 REQUIRES_NEW 在少数情况下会用到，其他基本不会用到\n定义事务的传播级别\n1 2 3 4 @Transactional(propagation = Propagation.REQUIRES_NEW) public Product createProduct() { ... } Spring 使用 ThreadLocal 来传播事务，如果一个事务方法从 ThreadLocal 未取到事务，那么它会打开一个新的 JDBC 连接，同时开启一个新的事务，否则，它就直接使用从 ThreadLocal 获取的 JDBC 连接以及 TransactionStatus。因此事务能正确传播的前提是，方法调用是再一个线程内才行。\n使用 DAO 集成 Hibernate 集成 JPA 集成 MyBatis ","date":"2024-08-28T20:40:00+08:00","permalink":"https://example.com/p/spring%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Spring访问数据库"},{"content":"1 数据结构 1.1 算法复杂度 时间复杂度和空间复杂度\n大 O 复杂度表示法\n舍去低阶、常量、系数\n2 常见数据结构 2.2.1 数组： 存储方式：\n内存中连续的空间，存储相同的数据类型；\n增删改查：\n遍历：\n2.2.2 链表： 存储方式：\n内存中离散的结点，data（数据）和 next（下一个元素的地址）；\n增删改查：\n遍历：\n2.2.3 栈： 存储方式：\n满足先进后出的存储结构；\n入栈和出栈操作：\n2.2.4 队列： 满足先进先出的存储结构；\n入队和出队操作；\n2.2.5 散列表 理想的哈希表是不会产生冲突，即每一个元素的键（Key）都不相同的数组，但显然这种数据结构在计算机有限的空间下无法实现，注定产生哈希冲突；\n哈希冲突的解决方案决定了哈希表的具体数据结构：\n链地址\nJava 中采用的方案，将冲突的值将通过链表存储，并根据一定的规则将链表转换为红黑树（红黑树相对链表能显著优化查找速度）\n开放定址、再哈希法、公共溢出区\u0026hellip;\n衡量一个哈希算法的好坏主要参考该算法能否将数据均匀的映射到Key的取值范围中\n2.2.6 二叉树： data 域和 左右儿子的指针\n","date":"2024-08-28T20:02:00+08:00","permalink":"https://example.com/p/%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/","title":"集合八股文"},{"content":"1 数据结构 1.1 算法复杂度 时间复杂度和空间复杂度\n大 O 复杂度表示法\n舍去低阶、常量、系数\n2 常见数据结构 2.2.1 数组： 存储方式：\n内存中连续的空间，存储相同的数据类型；\n增删改查：\n遍历：\n2.2.2 链表： 存储方式：\n内存中离散的结点，data（数据）和 next（下一个元素的地址）；\n增删改查：\n遍历：\n2.2.3 栈： 存储方式：\n满足先进后出的存储结构；\n入栈和出栈操作：\n2.2.4 队列： 满足先进先出的存储结构；\n入队和出队操作；\n2.2.5 散列表 理想的哈希表是不会产生冲突，即每一个元素的键（Key）都不相同的数组，但显然这种数据结构在计算机有限的空间下无法实现，注定产生哈希冲突；\n哈希冲突的解决方案决定了哈希表的具体数据结构：\n链地址\nJava 中采用的方案，将冲突的值将通过链表存储，并根据一定的规则将链表转换为红黑树（红黑树相对链表能显著优化查找速度）\n开放定址、再哈希法、公共溢出区\u0026hellip;\n衡量一个哈希算法的好坏主要参考该算法能否将数据均匀的映射到Key的取值范围中\n2.2.6 二叉树： data 域和 左右儿子的指针\n","date":"2024-08-28T20:02:00+08:00","permalink":"https://example.com/p/%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/","title":"集合八股文"},{"content":"AOP Aspect Oriented Programming，即面向切面编程\n何谓面向切面？我们对一个在 OOP 中的 BookService 的业务组件来考察，它应该会有几个业务方法：\ncreateBook updateBook deleteBook 那么，对于每个方法，我们都会需要设置安全检查、记录日志等等的公共逻辑，它们会重复的出现在各个业务方法中。在这些方法的某些代码段中就会出现重复的代码，加入把他们当作火腿肠一般并在一排，用刀切开就能够去考察这些切面了。\n对将这些切面如何正确的组装进火腿肠来说，有三种方法：\n在准备原料的时候就将它们按照顺序排列好，然后一次性注入进肠衣； 在将原料注入到肠衣的时候，按照需要的顺序先注入一种然后再切换到另外的； 业务逻辑这种原料先全部注入，然后按照需要切开再组装。 上述所言是在太过抽象，也或许并不贴且，但我们可以先有较为具体的例子，再去看对应到 Java 中 AOP 将切片织入到 BookService 的具体方案：\n编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ 就扩展了 Java 编译器，使用关键字 aspect 来实现织入； 类加载器：在目标类被装载到 JVM 时，通过一个特殊的类加载器，对目标类的字节码重新“增强”； 运行期：目标对象和切面都是普通 Java 类，通过 JVM 的动态代理功能或者第三方库实现运行期动态织入。 Spring 的 AOP 实现就是基于 JVM 的动态代理。\n由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。\n装配 AOP Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点 Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行 Pointcut：切入点，即一组连接点的集合 Advice：增强，指特定连接点上执行的动作 Introduction：引介，指为一个已有的Java对象动态的增加新的接口 Weaving：织入，指将切面整合到程序的执行流程中 Interceptor：拦截器，是一种实现增强的方式 Target Object：目标对象，即真正执行业务的核心逻辑对象 AOP Proxy：AOP 代理，是客户端持有的增强后的对象引用 要实现 AOP，我们先要引入 Spring 对 AOP 的支持：\norg.springframework:spring-aspects:6.0.0\n然后定义一个 Aspect：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Aspect @Component public class LoggingAspect { // 在执行 UserService 的每个方法前执行 @Before(\u0026#34;execution(public * com.gaj.demo01aop.service.UserService.*(..))\u0026#34;) public void doAccessCheck() { System.err.println(\u0026#34;[Before] do access check...\u0026#34;); } // 在执行 MailService 的每个方法前后执行 @Around(\u0026#34;execution(public * com.gaj.demo01aop.service.MailService.*(..))\u0026#34;) public Object doLogging(ProceedingJoinPoint pjp) throws Throwable { System.err.println(\u0026#34;[Around] start \u0026#34; + pjp.getSignature()); Object retval = pjp.proceed(); System.err.println(\u0026#34;[Around] done \u0026#34; + pjp.getSignature()); return retval; } } @Before 注解后面的字符串是告诉 AspectJ应该在何处执行该方法，这里写的意思是：执行 UserService 的每个 public 方法前执行 doAccessCheck() 代码。\n@Around 注解可以决定是否执行目标方法。\n同时还要给 @Configuration 类加上 @EnableAspectJAutoProxy 注解，这样 Spring 的 IoC容器就会自动查找带有 @Aspect 的 Bean，然后根据每个方法的 @Before、@Around 等注解把 AOP 注入到特定的 Bean 中。\n所以使用 AOP 的步骤如下：\n定义执行方法，并在方法上通过 AspectJ 的注解告诉 Spring 应该在何处调用此方法； 标记 @Component 和 @Aspect； 在 @Configuration 类上标注 @EnableAspectJAutoProxy。 拦截器类型：\n@Before\n先拦截代码，再执行目标代码。如果拦截器抛出异常，目标代码就不执行；\n@After\n先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；\n@AfterReturning\n和 @After 不同的是，只有当目标代码正常返回时，才执行拦截器代码；\n@AfterThrowing\n和 @After 不同的是，只有当目标代码正常抛出了异常时，才执行拦截器代码；\n@Around\n能完全控制目标代码是否执行，并且可以在执行前后、抛异常后执行任意拦截代码。\n使用注解装配 AOP 自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。\n以监控应用程序性能为例，先定义一个性能监控的注解：\n1 2 3 4 5 @Target(METHOD) @Retention(RUNTIME) public @interface MetricTime { String value(); } 在需要被监控的关键方法上标注该注解\n1 2 3 4 5 6 7 8 9 @Component public class UserService { // 监控register()方法性能: @MetricTime(\u0026#34;register\u0026#34;) public User register(String email, String password, String name) { ... } ... } 然后定义切片 MetricAspect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class MetricAspect { @Around(\u0026#34;@annotation(metricTime)\u0026#34;) public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable { String name = metricTime.value(); long start = System.currentTimeMillis(); try { return joinPoint.proceed(); } finally { long t = System.currentTimeMillis() - start; // 写入日志或发送至JMX: System.err.println(\u0026#34;[Metrics] \u0026#34; + name + \u0026#34;: \u0026#34; + t + \u0026#34;ms\u0026#34;); } } } @Around(\u0026quot;@annotation(metricTime)\u0026quot;) 表示符合条件的目标方法时带有 @MetricTime 注解的方法\nAOP 避坑 Spring 通过 CGLIB 动态创建的代理类生成的构造方法中，并未调用 super()，因此从成员变量并未初始化。Java 编译器虽然会默认在构造方法的第一行自动加 super()，但是， CGLIB 构造的代理类，是通过直接生成字节码，没有源码-编译-字节码的这个步骤，因此：\nSpring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！\n如何解决这个问题，需要在访问字段的代码，改成通过方法访问（用 getter 访问而不用 对象.字段直接访问字段），在代理实例中，因为代理类会覆写 getter 方法，并且将其委托给原始实例：\n1 2 3 4 5 6 7 8 public UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... // 原始实例 ... public ZoneId getZoneId() { return target.getZoneId(); // 委托给原始实例 } } 如果有方法是用 public + final 修饰的方法，\n1 2 3 4 5 6 7 @Component public class UserService { ... public final ZoneId getFinalZoneId() { return zoneId; } } 如果在MailService中，调用的不是getZoneId()，而是getFinalZoneId()，又会出现NullPointerException，这是因为，代理类无法覆写final方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的zoneId字段，即null。\n因此，正确使用AOP，我们需要一个避坑指南：\n访问被注入的Bean时，总是调用方法而非直接访问字段； 编写Bean时，如果可能会被代理，就不要编写public final方法。 这样才能保证有没有AOP，代码都能正常工作。\n","date":"2024-08-26T09:52:54+08:00","permalink":"https://example.com/p/aop/","title":"AOP"},{"content":"Cookie Cookie是另一种在Web应用中保持状态的机制，但与session不同的是，cookie存储在客户端，而不是服务器端。以下是cookie的详细介绍：\n1. Cookie的工作原理 存储位置: cookie存储在客户端的浏览器中，由浏览器管理。 传递机制: 每次客户端发送HTTP请求时，浏览器会自动将相关的cookie信息添加到请求头中发送给服务器。这些cookie可以包含各种数据，如用户ID、偏好设置等。 2. Cookie的创建和使用 设置Cookie:\n服务器通过HTTP响应头中的Set-Cookie指令来设置cookie。\n例如：\n1 2 3 Cookie cookie = new Cookie(\u0026#34;username\u0026#34;, \u0026#34;Alice\u0026#34;); cookie.setMaxAge(60 * 60); // 设置cookie的生命周期为1小时 response.addCookie(cookie); 这段代码在服务器响应时，告诉客户端保存一个名为\u0026quot;username\u0026quot;、值为\u0026quot;Alice\u0026quot;的cookie，并设定这个cookie的有效期为1小时。\n读取Cookie:\n服务器可以通过HttpServletRequest对象读取客户端发送的cookie。\n例如：\n1 2 3 4 5 6 7 8 9 Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie c : cookies) { if (\u0026#34;username\u0026#34;.equals(c.getName())) { String username = c.getValue(); // 使用username进行后续操作 } } } 这段代码获取客户端发送的所有cookie，并从中找到名为\u0026quot;username\u0026quot;的cookie，然后提取其值。\n3. Cookie与Session的区别 存储位置: Session存储在服务器端（内存、数据库、文件等）。 Cookie存储在客户端（浏览器）。 生命周期: Session的生命周期通常与客户端会话相关联，且可以配置为持久化或基于时间过期。 Cookie的生命周期由服务器通过Max-Age或Expires属性指定。如果不设置，cookie会在浏览器关闭后失效。 安全性: Session数据在服务器端保存，客户端无法直接访问或篡改，安全性较高。 Cookie数据保存在客户端，虽然可以设置为HttpOnly（仅供服务器读取）或Secure（仅在HTTPS下传输），但仍然容易受到客户端篡改或窃取的风险。 典型用途: Session通常用于存储用户的会话数据（如登录状态），在多个请求之间保持状态。 Cookie可以用于在客户端存储小型数据，如用户偏好、会话ID等。 4. Session与Cookie的关系 通常，session和cookie是一起使用的。为了在多个请求之间识别用户的session，服务器会创建一个session ID，并通过cookie发送给客户端。 每次客户端发送请求时，浏览器会将session ID的cookie返回给服务器，服务器通过这个session ID找到对应的session，从而维持会话状态。 总结 Cookie: 存储在客户端，由服务器通过Set-Cookie设置。每次请求时，浏览器会自动发送相关cookie。 Session: 存储在服务器端，用于管理与特定用户的会话状态。通常通过session ID来关联客户端和服务端的会话。 Cookie和session各有其用途，通常根据应用需求选择最适合的方式来管理用户状态。\n","date":"2024-08-25T08:52:54+08:00","image":"https://example.com/p/cookie/cookie_hu8143540753659831620.jpg","permalink":"https://example.com/p/cookie/","title":"Cookie"},{"content":"Filter \u0026amp; DispatcherServlet \u0026amp; Interceptor Filter 过滤器，它是 JavaEE 的 Servlet 规范提供的一种组件\n作用\n在 Http 请求到达 Servlet 之前，可以被一个或多个 Filter 预处理，主要是做的一些代码的公共逻辑。\n调用链\n多个 Filter 是具有调用链的存在的，每个请求都会被链上的 Filter 依次处理，需要在 web.xml 中配置它们的顺序。\nFilter 可以有针对性地拦截或者放行 HTTP 请求，如果在 Filter 内部直接发送重定向，且没有调用 chain.doFilter() ，后续的 Filter 就不会在处理这个请求了\nDispatcherServlet 它是 MVC 框架中用来接收所有请求的 Servlet，总是映射到 /\nDispatcherServlet 在接收到一个 Request 之后，会根据 Controller 的注解来决定调用哪个方法（需要先通过反射获取 Controller 的实例、get 或 post 方法、方法的参数类型、方法的参数名称），并获得方法返回的 ModelAndView ，或方法内部已经自行处理完毕，返回的就是 null\nView 使用来给模板引擎指定渲染的模板的，而 Model 是一个 Map\u0026lt;String, Object\u0026gt;，model 会由渲染引擎（如 Pebble 这类引擎）在生成模板的时候通过反射来获取数据\nInterceptor 拦截器，它是 Spring MVC 框架用于拦截 HTTP 请求的逻辑\n作用于请求到 controller 之前、controller 处理请求之后\n作用范围比 Filter 更小，更加精细\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/filter-dispatcherservlet-interceptor/","title":"Filter \u0026 DispatcherServlet \u0026 Interceptor"},{"content":"Session session用于指代服务器将数据存储在当前用户的会话中，这个session是由服务端保存的，具体来说，它是一个HttpSession类，我们在获取的时候是由HttpServletRequest.getSession()这样获取到当前用户的session，通过唯一表示符JSESSIONID在服务端区分。\n客户端只会保存JSESSIONID，服务端通过这个id查找到对应的session。\n服务端通过setAttribute()和getAttribute()来读或写session存储的属性及其值\n但是，HttpServletRequest在响应完请求后就会销毁，说明这个Session不是由HttpServletRequest，而是由tomcat的相关组件来处理的：\norg.apache.catalina.session.StandardSession:\nStandardSession是Tomcat中表示会话的类。每个会话对象都由这个类的一个实例表示，StandardSession对象包含了会话的所有数据，包括会话ID、会话属性（如user、name）、创建时间、最后访问时间等。 org.apache.catalina.session.StandardManager:\nStandardManager是Tomcat的默认会话管理器，它负责创建、查找、删除和持久化StandardSession对象。 当你通过HttpServletRequest.getSession()获取会话时，Tomcat实际上是通过StandardManager查找或创建一个StandardSession对象。 org.apache.catalina.Context:\nContext对象代表一个Web应用的上下文。在每个Context对象中，有一个Manager（即StandardManager）实例来管理该上下文的所有会话。 工作流程概述 创建会话: 当客户端第一次请求并调用HttpServletRequest.getSession()时，如果没有现有的会话，Tomcat会通过StandardManager创建一个新的StandardSession对象并返回。 这个新创建的会话对象会被StandardManager保存，以便在后续请求中使用。 管理会话生命周期: StandardManager会定期检查会话是否过期，并销毁过期的会话。 如果应用程序或服务器设置了持久化配置，StandardManager还可以将会话数据序列化到文件系统中，以便在服务器重启后恢复。 会话存储: 默认情况下，session数据存储在Tomcat服务器的内存中。StandardManager会持有所有活动会话的引用，并在Tomcat运行期间负责管理它们。 会话在Tomcat中的持有者 因此，在Tomcat中，HttpSession对象是由StandardSession类表示的，而这些会话对象由StandardManager持有和管理。即使HttpServletRequest对象被销毁，StandardSession对象依然存在于StandardManager中，直到会话超时或被显式销毁。\n如果Tomcat重启，默认情况下，保存在内存中的session会消失。这意味着如果没有特殊配置，当Tomcat重新启动时，所有活跃的session数据都会丢失，用户会话将被中断，用户需要重新登录或重新建立会话。\n持久化会话数据的方法 为了在Tomcat重启后保留session数据，可以使用以下方法：\n启用session持久化:\nTomcat提供了会话持久化的功能，可以将session数据序列化到磁盘上，并在服务器重启时重新加载。 这通过StandardManager的持久化机制来实现。你可以在\u0026lt;Context\u0026gt;配置中启用session持久化。 示例配置（在conf/context.xml或Web应用的META-INF/context.xml中）：\n1 \u0026lt;Manager pathname=\u0026#34;session.ser\u0026#34;/\u0026gt; 这里的pathname属性指定了会话数据文件的路径。如果不指定路径，Tomcat将默认保存会话数据到work目录下的session.ser文件中。 使用外部持久化存储:\n可以将session数据存储在外部数据库、Redis、Memcached等持久化存储中。通过这种方式，即使Tomcat重启，会话数据也能持久存在。 这需要自定义Manager类或者使用第三方的解决方案，例如使用RedisSessionManager来将session数据保存在Redis中。 总结 默认情况下，Tomcat重启后，session数据会丢失，因为它们存储在内存中。\n启用持久化 或 使用 外部存储 是保留session数据的两种常见方法。如果需要在重启后保持会话，建议配置持久化或者使用外部存储机制。\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/session/","title":"Session"},{"content":"测试文章 测试内容\n测试 toc 自动生成目录1 测试 toc 自动生成多级目录（二级目录） 测试 toc 自动生成多级目录（三级目录） 多级目录最多三层\n测试 toc 自动生成目录2 下面是图片↓↓↓↓↓↓↓↓↓↓↓↓\n上面是图片↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n图片中间不能有空格\n测试图片上传方案 测试代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* 读取配置文件 使用 @PropertySource(\u0026#34;app.properties\u0026#34;) 自动读取配置文件，Spring 容器看到这个注解后，自动读取这个配置文件 */ @Configuration @ComponentScan @PropertySource(\u0026#34;app.properties\u0026#34;) // 表示读取 classpath 的 app.properties @PropertySource(\u0026#34;smtp.properties\u0026#34;) public class AppConfig { @SuppressWarnings(\u0026#34;resource\u0026#34;) public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); UserService userService = context.getBean(UserService.class); userService.login(\u0026#34;bob@example.com\u0026#34;, \u0026#34;password\u0026#34;); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;ada\u0026#34;, 2); map.put(\u0026#34;awui\u0026#34;, 1); map.put(\u0026#34;dawcf\u0026#34;, 3); map.put(\u0026#34;afafds\u0026#34;, 4); for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + entry.getValue()); } } /* 注入的字符串语法 1.\u0026#34;${app.zone}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，启动将报错 2.\u0026#34;${app.zone:Z}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，就用使用默认值 */ @Bean ZoneId createZoneId(@Value(\u0026#34;${app.zone:Z}\u0026#34;) String zoneId) { return ZoneId.of(zoneId); } } ","date":"2023-08-24T09:52:54+08:00","image":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87_hu6886787404485992962.png","permalink":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","title":"测试文章"}]