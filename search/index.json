[{"content":"Q1 Web 程序总是由 Servlet 容器创建，那么在一个 Web 程序中，那么，Spring 容器应该由谁创建？在什么时候创建？Spring 容器中的 Controller 又是如何通过 Servlet 调用的？\n在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种最简单的启动Spring容器的方式。\n第一步，我们在web.xml中配置Spring MVC提供的DispatcherServlet：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;web-app\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextClass\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;com.itranswarp.learnjava.AppConfig\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;0\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 初始化参数contextClass指定使用注解配置的AnnotationConfigWebApplicationContext，配置文件的位置参数contextConfigLocation指向AppConfig的完整类名，最后，把这个Servlet映射到/*，即处理所有URL。\n上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的DispatcherServlet，在DispatcherServlet启动时，它根据配置AppConfig创建了一个类型是WebApplicationContext的IoC容器，完成所有Bean的初始化，并将容器绑到ServletContext上。\n因为DispatcherServlet持有IoC容器，能从IoC容器中获取所有@Controller的Bean，因此，DispatcherServlet接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的ModelAndView决定如何渲染页面。\n","date":"2024-09-15T16:02:00+08:00","permalink":"https://example.com/p/spring/","title":"spring"},{"content":"Q1 mapper\nMapper 就是用来执行 SQL 语句的\nQ2 ORM 框架是如何跟踪 Java Bean 的修改，以便在 update() 操作中更新必要的属性\n使用 Proxy 模式，从 ORM 框架读取的 User 示例实际上并不是 User 类，而是代理类，代理类继承自 User 类，但对每个 setter 方法都做了覆写\nQ3 ORM 分为全自动和半自动框架，有什么区别\nQ4 Spring 提供的 JdbcTemplate 相对于全自动的 ORM 框架有什么差别，有什么优势\n区别： 查询后需要手动提供 Mapper 实例一边把 ResultSet 的每一行变为 Java 对象 增删改操作所需的参数列表，需要手动传入，即把 User 实例变为 [user.id, user.name, user.email] 这样的列表，比较麻烦 优势：确定性 每次读取操作一定是数据库操作而不是缓存，即每次读取操作一定是数据库操作而不是缓存， 而 ORM 框架有一级二级缓存机制 缺点：繁琐、复杂 解决方案： 使用半自动的 ORM 框架 MyBatis，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。 Q5 sql 注入是什么，怎么解决\nStatement\nPrepareStatement\n#{}\n${} 用在动态表名\nQ6 给一个场景：\n现在 UserService 中有一个 updateUser(Long id, String name) 方法，而 UserMapper 中 update 操作只有一个 update(User user) 方法（get、delete、insert都有）\n在这里你是会给接口新加一个方法用于更新 user 的 name；还是用 UserMapper 提供的 getById 获取一个 User 实例，更改 name 后再调用 update(user) 把这个实例传入。\n注：User 继承自 AbstractEntity，里面有多个字段如 id，createdTime，updatedTime\nQ7 如果使用 PageHelper 处理分页查询，会不会有线程安全问题\nPageHelper的使用\nPageHelper 只会对紧跟在其后的第一条 SQL 语句进行分页处理，如：\n1 2 3 4 5 6 7 8 9 @Override public PageBean page(Integer page, Integer pageSize) { PageHelper.startPage(page, pageSize); List\u0026lt;Emp\u0026gt; empList = empMapper.list(); Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; return new PageBean(p.getTotal(), p.getResult()); } 只要可以保证在 PageHelper 方法调用后紧跟着查询方法，就是安全的。\n线程安全问题的产生原因\nPageHelper 使用了静态的 ThreadLocal 参数，这意味着分页设置是与当前啊线程相关联的。\n1 2 3 4 5 6 7 8 9 //使用PageHelper分页助手插件进行分页操作 PageHelper.startPage(0, 10); List\u0026lt;Country\u0026gt; list; if(param1 != null){ list = countryMapper.selectIf(param1); } else { list = new ArrayList\u0026lt;Country\u0026gt;(); } Page\u0026lt;CheckItem\u0026gt; page = checkItemDao.selectByCondition(queryString); 这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。\nQ8 对于一个请求参数\n1 2 3 4 5 6 7 8 9 10 11 12 @Data public class EmpQueryParam { // 对于请求中的参数，只有映射到 String 类型时会把空字符串映射，对于其他的类型遇到 \u0026#34;\u0026#34; 会映射为 null private Integer page = 1; // 页码，默认值1 private Integer pageSize = 10; // 每页展示记录数，默认值10 private String name; // 姓名 private Integer gender; // 性别 @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate begin; // 入职开始时间， @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate end; // 入职结束时间 } 编写动态 SQL 语句如下\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.gaj.pojo.Emp\u0026#34;\u0026gt; select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;param.name != null and param.name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; e.name like concat(\u0026#39;%\u0026#39;, #{param.name}, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;param.gender != null\u0026#34;\u0026gt; and e.gender = #{param.gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;param.begin != null and param.end != null\u0026#34;\u0026gt; and e.entry_date between #{param.begin} and #{param.end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by e.update_time desc \u0026lt;/select\u0026gt; 前端的请求\nhttp://localhost:90/api/emps?begin=\u0026amp;end=\u0026amp;gender=\u0026amp;name=\u0026amp;page=1\u0026amp;pageSize=5 这里的 begin end gender 都是空字符串，为什么对它们不用判空字符串（只用判空），对 name 要判\n很显然Integer 和 LocalDate 只会为 null，不会为空字符串， 简单来说这里只有 String 需要判断是否为 \u0026quot;\u0026quot; 因为编译器已经确保了 \u0026quot;\u0026quot; 空字符串不会映射到其他引用类型\nQ9 spring 开启一个事务是怎么样的，底层是通过操作什么来开启\n答题思路\n简述 spring 框架中事务如何启用 @EnableTransaction PlatformTransactionManager 数据库底层 显式事务和隐式事务 JDBC 开启事务的关键代码是 conn.setAutoCommit(false) 表示关闭提交 spring 启用声明式事务 spring 中启用声明式事务和和开启一个声明式事务没什么好说的，前者需要在启动类上加上@EnableTransaction注解；后者只要在开启一个事务的类上（或者方法上）加上@Transactional注解，然后在需要回滚的地方抛出RunTimeException（默认情况下，也可以在Transactional注解声明rollbackFor属性），spring 的事务管理类（PlatformTransactionManager）会自动rollback。\nspring 启用编程式事务 spring 中使用编程式事务主要是PlatformTransactionManager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 TransactionStatus tx = null; try { // 开启事务: tx = txManager.getTransaction(new DefaultTransactionDefinition()); // 相关JDBC操作: jdbcTemplate.update(\u0026#34;...\u0026#34;); jdbcTemplate.update(\u0026#34;...\u0026#34;); // 提交事务: txManager.commit(tx); } catch (RuntimeException e) { // 回滚事务: txManager.rollback(tx); throw e; } 比较繁琐\n底层启用事务的原理 若是从数据库层面来说的话，开启一个事务是用BEGIN，COMMIT提交一个事务，ROLLBACK回滚事务。事务有隔离级别，但不是本题的讨论范围这里不做讲解。\n主要的答题点应为 JDBC 层面的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Connection conn = openConnection(); try { // 关闭自动提交: conn.setAutoCommit(false); // 执行多条SQL语句: insert(); update(); delete(); // 提交事务: conn.commit(); } catch (SQLException e) { // 回滚事务: conn.rollback(); } finally { conn.setAutoCommit(true); conn.close(); } 开启事务的关键代码是 conn.setAutoCommit(false) 表示关闭提交。\n因为事务分为显示事务和隐式事务，对于单条 SQL 语句，数据库系统自动将其作为一个事务执行，这就是隐式事务。\n关闭自动提交就代表开启了显示事务，然后在执行多条sql语句的过程中如果 catch 到了异常，就可以选择回滚事务，如果程序正常执行就将 commit\n自动提交更改后必须要改回原来的值\n所以 spring 框架在开启事务的时候其实就是对自动提交的操作。\nQ10 使用@Transactional注解可以开启一个事务，在什么时候会回滚？\n默认抛出RuntimeException异常时会回滚，非RuntimeException（包括IOException、ReflectiveOperationException等等）不会回滚。\n为了简化代码，我们强烈建议业务异常体系从RuntimeException派生，这样就不必声明任何特殊异常即可让Spring的声明式事务正常工作。\nQ11 Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？\nQ12 事务失效场景\n事务方法非 public 修饰\n非事务方法调用事务方法\n事务方法的异常被捕获了\n事务异常类型不对\n事务传播行为不对\n没有被 Spring 管理\nQ13 数据库事务具有 ACID 特性\nAtomicity 原子性 Consistency 一致性 Isolation 隔离性 Durability 持久性 Q14 SQL 标准定义了哪四种隔离级别\nIsolation Level 脏读（Dirty Read） 不可重复读（Non Repeatable Read） 幻读（Phantom Read） Read Uncommitted Yes Yes Yes Read Committed - Yes Yes Repeatable Read - - Yes Serializable - - - ","date":"2024-09-14T20:02:00+08:00","permalink":"https://example.com/p/%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"数据库"},{"content":"Spring IoC ","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/spring-ioc/","title":"Spring IoC"},{"content":"Q1 private final Logger logger = LoggerFactory.getLogger(getClass());\n还是\nprivate statci final Logger logger = LoggerFactory.getLogger(ClassName.class);\n两种写法各有优缺点，选择哪一种取决于你的需求和项目风格。\nprivate final Logger logger = LoggerFactory.getLogger(getClass());\n优点：\n通用性高：可以用于任何类，无需手动更新类名（适合复制粘贴代码到其他类中时无需修改）。 适应继承：如果这个类被继承，getClass() 会返回子类的类型，日志会正确显示子类的类名。 缺点：\n运行时开销：getClass() 是在运行时确定的，虽然开销不大，但比静态方法稍微慢一些。 private static final Logger logger = LoggerFactory.getLogger(ClassName.class);\n优点：\n效率稍高：因为 ClassName.class 是在编译时确定的，性能上稍微优于 getClass()。 符合静态常量的惯例：logger 是静态的，通常被定义为 static final，符合惯例。 日志清晰：明确指定类名，在日志中始终使用这个类的名字，不管它是否被继承。 缺点：\n继承问题：如果类被继承，日志依然显示的是父类的类名，而不是子类的名字，这在需要记录子类日志时可能不是理想的选择。 类名需要手动更新：如果你复制这个类或重命名它，你需要手动更新 ClassName，否则会导致日志记录混乱。 推荐用法： 使用 static final 和类名 的方式更为常见，尤其在不涉及继承的情况下。这种方式在性能上更高效，且更符合静态常量的使用习惯。 1 private static final Logger logger = LoggerFactory.getLogger(ClassName.class); 如果你的类可能会被继承并且你希望日志记录子类的类名，则可以考虑使用 getClass()： 1 private final Logger logger = LoggerFactory.getLogger(getClass()); 总结：对于一般类，建议使用 static final Logger 和类名；如果有继承需求，使用 getClass() 更灵活。\n","date":"2024-09-12T16:02:00+08:00","permalink":"https://example.com/p/%E9%9A%8F%E8%AE%B0/","title":"随记"},{"content":"1. main 分支 用途: main（或 master）是项目的主要分支，通常代表的是当前稳定和可发布的版本。它是用户和生产环境直接使用的分支。 说明: 代码合并到 main 分支时，通常已经经过充分的测试，并且功能已经完全实现。 2. build 分支 用途: 用于存储构建脚本、构建配置文件或持续集成和部署的代码。 说明: 该分支可能包含自动化构建系统所需的工具或配置文件，比如 Jenkinsfile、Dockerfile 或者 CI/CD 的脚本。 3. exp 分支 用途: exp 是实验（experimental）的缩写。用于进行实验性的开发。 说明: 该分支可能包含尚未确定的功能或新技术的尝试，通常不保证稳定性，并且可能会在未来被删除或合并到其他分支。 4. feat 分支 用途: feat 是 feature 的缩写。用于开发新功能。 说明: 通常每个功能都会有一个单独的分支（如 feat/feature-name），开发完成并通过测试后再合并到 dev 或 main。 5. fix 分支 用途: fix 分支专门用于修复 bug。 说明: 修复特定问题或 bug 的代码会先提交到 fix 分支，然后再合并到 dev 或 main，以确保问题修复后能立即进入下一步发布流程。 6. issues 分支 用途: 与项目的 issue 管理工具（如 GitHub Issues）相结合，专门用于处理特定的 issues（问题/任务）。 说明: 该分支通常用于实现特定问题的修复或功能改进，分支名称通常会包括 issue 的编号（如 issues/#123）。 7. perf 分支 用途: perf 是 performance 的缩写。用于进行性能优化。 说明: 该分支会涉及到代码的性能改进，例如减少内存使用、优化算法等，然后这些改动会被测试和验证后合并回主分支。 8. refactor 分支 用途: 用于重构代码。 说明: 该分支上的改动通常不影响功能，但会改善代码质量、结构和可维护性。这些改动通常需要经过充分的测试，以确保没有引入新的 bug。 9. rework 分支 用途: 专门用于重新开发或重写某部分代码。 说明: 当某个功能或模块需要大规模重写而不破坏现有版本时，rework 分支会被创建。在完成后，这些改动可以被合并到 dev 或其他相应的分支。 10. dev 分支 用途: dev 是开发分支，通常是用于日常开发的主要分支。 说明: 这个分支包含尚在开发中的功能和改进，在合并到 main 之前通常会在这个分支进行测试和 bug 修复。 11. 0.17_LTS 分支 用途: 该分支代表一个长期支持（Long Term Support, LTS）的版本。 说明: 此版本通常比最新版本更稳定，且会定期接收安全更新和重要的 bug 修复。它可能用于需要长期支持的客户或产品环境。 12. litecommand 分支 用途: 可能用于开发一个名为 litecommand 的特定功能或模块。 说明: 该分支上可能包含与 litecommand 功能相关的代码，开发完成后再合并回主分支。 ","date":"2024-09-11T20:02:00+08:00","permalink":"https://example.com/p/git%E5%88%86%E6%94%AF/","title":"Git分支"},{"content":"多线程 线程 创建线程 继承 Thread 类，重写 run 方法，然后创建子类对象调用 start() 方法 实现 Runnable 接口，重写 run 方法，然后创建实现类对象并传递给一个 Thread，调用 start() 实现 Callable 接口，重写 call 方法，然后创建实现类对象并传递给一个 FutureTask 类对象，最后传递给一个 Thread 对象调用 start() 线程的六种状态 NEW 新建状态 RUNNABLE 可运行状态，线程调用 start() 方法后即处于这个状态 BLOCKED 锁阻塞状态，没有获取到锁即处于这个状态 WAITING 无线等待状态，线程执行时被调用了 wait() 方法处于这个状态 TIMED_WAITING 计时等待状态，线程执行时被调用了 sleep(ms) 或 wait(ms) 方法即处于这个状态 TERMINATED 终止状态，线程执行完毕或遇到异常即处于这个状态 线程池 ThreadPoolExcutor 线程池内部使用 AtomicTnteger 来维护 runState(运行状态) 和 workerCount(线程数量) 用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。\n顶层接口是 Excutor\n线程池的五种运行状态 RUNNING 能接受新提交的任务，并且也能处理阻塞队列中的任务 SHUTDOWN 关闭状态，不再接受新提交的任务，但可以继续处理阻塞队列中保存的任务 STOP 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程 TIDYING 所有的任务都终止了，workerCount(有效线程数)为0 TERMINATED 在 terminated() 方法执行完后加入该状态 Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)\n","date":"2024-09-01T21:52:54+08:00","permalink":"https://example.com/p/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"多线程"},{"content":" Spring 简化了数据库访问：\n提供简化的访问 JDBC 的模板类，不必手动释放 提供一个统一的 DAO 类以实现 Data Access Object模式 把 SQLException 封装为 DataAccessException，这是一个 RuntimeException 能方便地继承 Hibernate、JPA 和 MyBatis 这些数据库访问框架 使用 JDBC 引入以下依赖：\norg.springframework:spring-context:6.0.0 org.springframework:spring-jdbc:6.0.0 jakarta.annotation:jakarta.annotation-api:2.1.1 com.zaxxer:HikariCP:5.0.1 org.hsqldb:hsqldb:2.7.1 在 AppConfig 中，创建以下几个必须的 Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) // 读取数据库配置文件 public class AppConfig { @Value(\u0026#34;${jdbc:url}\u0026#34;) // 注入配置文件的相关配置 String jdbcUrl; @Value(\u0026#34;${jdbc.username}\u0026#34;) String jdbcUsername; @Value(\u0026#34;${jdbc.password}\u0026#34;) String jdbcPassword; @Bean DataSource createDataSource() { // 创建需要用到注入的配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(jdbcUrl); config.setUsername(jdbcUsername); config.setPassword(jdbcPassword); config.addDataSourceProperty(\u0026#34;autoCommit\u0026#34;, \u0026#34;true\u0026#34;); config.addDataSourceProperty(\u0026#34;connectionTimeout\u0026#34;, \u0026#34;5\u0026#34;); config.addDataSourceProperty(\u0026#34;idleTimeout\u0026#34;, \u0026#34;60\u0026#34;); // 创建 DataSource 实例，实际类型为 HikariDataSource return new HikariDataSource(config); } @Bean JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) { return new JdbcTemplate(dataSource); } } 在需要访问数据库的 Bean 中，注入 JdbcTemplate：\n1 2 3 4 @Component public class UserService { @Autowired JdbcTemplate jdbcTemplate; 使用 JdbcTemplate T execute(ConnectionCallback action) 方法，提供了 Connection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public User getUserById(long id) { // 传入 ConnectionCallback return jdbcTemplate.execute((Connection conn) -\u0026gt; { // 可以直接使用 conn 实例，不用释放，回调结束后 jdbcTemplate 自动释放 // 在内部手动创建的 PreparedStatement、ResultSet 必须用 try(...) 释放 try (var ps = conn.prepareStatement(\u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;)) { ps.setLong(1, id); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by id:\u0026#34; + id); } } }); } T execute(String sql, PreparedStatementCallback action)，PreparedStatement 实例已经由JdbcTemplate 创建，并在回调后自动释放: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public User getUserByName(String name) { return jdbcTemplate.execute(\u0026#34;SELECT * FROM users WHERE name = ?\u0026#34;, (PreparedStatement ps) -\u0026gt; { // PreparedStatement 实例已经由 JDBCTemplate 创建，并在回调后自动释放 ps.setString(1, name); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by name: \u0026#34; + name); } }); } T queryForObject(String sql, RowMapper rowMapper, Object\u0026hellip; args)，传入 SQL 以及 SQL 参数后，JdbcTemplate 会自动创建 PreparedStatement，自动执行查询并返回 ResultSet，我们提供的RowMapper 需要做的事情就是把 ResultSet 的当前行映射成一个 JavaBean 并返回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public User getUserByEmail(String email) { // 传入 SQL，参数和 RowMapper 实例 return jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM users WHERE email = ?\u0026#34;, (ResultSet rs, int rowNum) -\u0026gt; { // 将 ResultSet 的当前行映射为一个 JavaBean return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } ); } JdbcTemplate 设计的目的就是为了避免繁琐的 try\u0026hellip;catch 语句\nquery() 方法返回多行记录，传入 SQL 语句，SQL 参数以及 RowMapper 实例\nSpring 提供了 BeanPropertyRowMapper\n1 2 3 4 5 6 7 8 public List\u0026lt;User\u0026gt; getUsers(int pageIndex) { int limit = 2; int offset = limit * (pageIndex - 1); return jdbcTemplate.query(\u0026#34;SELECT * FROM users LIMIT ? OFFSET ?\u0026#34;, new BeanPropertyRowMapper\u0026lt;\u0026gt;(User.class), limit, offset ); } 插入、更新、删除使用 update() 1 2 3 4 5 6 7 public void updateUser(User user) { // 传入 SQL、SQL 参数、返回更新的行数 if (1 != jdbcTemplate.update(\u0026#34;UPDATE users SET name = ? WHERE id = ?\u0026#34;, user.getName(), user.getId())) { throw new RuntimeException(\u0026#34;User not found by id\u0026#34;); } } 使用 KeyHolder 获取插入后的自增值\nupdate() 时传入 PreparedStatementCreator 和 KeyHolder 两个参数\nholder.getKey() 可以获取返回自增值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public User register(String email, String password, String name) { KeyHolder holder = new GeneratedKeyHolder(); if (1 != jdbcTemplate.update( // 参数 PreparedStatementCreator (conn) -\u0026gt; { PreparedStatement ps = conn.prepareStatement(\u0026#34;INSERT INTO users(email, password, name) VALUES (?,?,?)\u0026#34;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, email); ps.setString(2, password); ps.setString(3, name); return ps; }, // 参数 KeyHolder holder )) { throw new RuntimeException(\u0026#34;Insert failed.\u0026#34;); } return new User(holder.getKey().longValue(), email, password, name); } JdbcTemplate 用法总结 简单查询使用 query()，只需要提供 SQL 语句、参数和 RowMapper 更新操作使用 update()，只需要提供 SQL 语句和参数 任何复杂的操作使用 execute(ConnectionCallback)，拿到了 Connection 就可以做任何 JDBC 操作 设计表结构的时候要和 JavaBean 的属性一一对应，这样就可以方便的使用 Spring 提供的 BeanPropertyRowMapper。\n如果表结构和 JavaBean 不一致，则需要稍微改写查询使得结果集和 JavaBean 保持一致\n数据库列名与 JavaBean 属性名不一致\n在 SQL 查询中使用别名将列名与 JavaBean 属性名对齐。\n1 SELECT user_id AS id, user_name AS name FROM users LIMIT ? OFFSET ? 数据库表包含 JavaBean 中没有的字段\n在查询中只选择 JavaBean 中定义的字段.\nJavaBean 中包含数据库表没有的字段\nJavaBean 中的字段需要进行转换\n1 SELECT user_id AS id, user_name AS name, CASE WHEN is_active = 1 THEN TRUE ELSE FALSE END AS active FROM users LIMIT ? OFFSET ? 需要使用自定义的行映射器 1 2 3 4 5 6 7 8 9 10 11 class UserRowMapper implements RowMapper\u0026lt;User\u0026gt; { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setId(rs.getLong(\u0026#34;user_id\u0026#34;)); user.setName(rs.getString(\u0026#34;user_name\u0026#34;)); user.setActive(rs.getInt(\u0026#34;is_active\u0026#34;) == 1); // 其他属性的映射 return user; } } 使用声明式事务 Spring 中提供了一个 PlatformTransactionManager 来表示事务管理器。事务由 TransactionStatus 表示。\n手写事务代码的话，一般在 try{\u0026hellip;..} 中执行数据操作，然后 catch{\u0026hellip;..} 中捕获错误然后 rollback 事务，没有捕获到错误的话就 commit() 提交事务。\n启用声明式事务 在 AppConfig 中追加一个 PlatformTransactionManager 对应的 Bean，然后再加一个 @EnableTransactionManagement 注解\nPlatformTransactionManager 对应的 Bean：\n1 2 3 4 5 @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) { // 实际类型是 DataSourceTransactionManager return new DataSourceTransactionManager(dataSource); } @EnableTransactionManagement 注解\n1 2 3 4 5 6 7 8 9 10 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) @EnableTransactionManagement // 启用声明式事务 public class AppConfig { @Bean PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } } 这样就启用了声明式事务，然后对需要事务支持的方法或者在 Bean 上加（表示对所有 public 方法都具有事务支持），加上一个 @Transactional 注解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Transactional public User register(String email, String password, String name) { KeyHolder holder = new GeneratedKeyHolder(); if (1 == jdbcTemplate.update( // 将会抛出异常 // 参数 PreparedStatementCreator (conn) -\u0026gt; { PreparedStatement ps = conn.prepareStatement(\u0026#34;INSERT INTO users(email, password, name) VALUES (?,?,?)\u0026#34;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, email); ps.setObject(2, password); ps.setString(3, name); return ps; }, // 参数 KeyHolder holder )) { throw new RuntimeException(\u0026#34;Insert failed, will roll back.\u0026#34;); // 将会 rollback } return new User(holder.getKey().longValue(), email, password, name); } Spring 会通过 AOP 代理实现事务的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... PlatformTransactionManager txManager = ... public User register(String email, String password, String name) { TransactionStatus tx = null; try { tx = txManager.getTransaction(new DefaultTransactionDefinition()); target.register(email, password, name); txManager.commit(tx); } catch (RuntimeException e) { // 默认情况下只有 RuntimeException 触发回滚 txManager.rollback(tx); throw e; } } ... } 针对异常类型决定是否回滚 1 @Transactional(rollbackFor = {RuntimeException.class, IOException.class}) 强烈建议业务异常体系从 RuntimeException 派生\n事务边界 一般来说一个事务的开始就是方法的开始，事务的结束就是方法的结束。\n新用户注册的事务：\n1 2 3 4 5 6 7 @Component public class UserService { @Transactional public User register(String email, String password, String name) { // 事务开始 .... } // 事务结束 } 发表博客的事务：\n1 2 3 4 5 6 7 @Componet public class BlogService { @Transaction public Blog addBlog(User user, String content) { // 事务开始 ... } // 事务结束 } 如果我们想要这样的效果：新用户注册后自动发表一个打招呼的博客：\n1 2 3 4 5 6 7 8 9 10 11 12 @Component public class UserService { @Autowired BlogService blogService; @Transactional public User register(String email, String password, String name) { .... User user = jdbcTemplate.insert(\u0026#34;....\u0026#34;); blogService.addBlog(user.id, \u0026#34;Hello Blog!\u0026#34;); } } 如果 addBlog() 抛出异常， register() 是否也需要回滚？\n事务传播 Spring 为事务传播定义的几个级别\nREQUIRED\n默认的事务传播级别，表示如果当前没有事务，就创建一个事务，如果当前有事务，就加入到当前事务中执行\nSUPPORTS\n表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行\nMANDATORY\n表示必须要存在当前事务并加入执行，否则将抛出异常\nREQUIRES_NEW\n表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已有事务，将当前事务挂起，等新事务完成后，再恢复执行\nNOT_SUPPORTED\n表示不支持事务，如果当前有事务，将当前事务挂起，等这个方法执行完成后，再恢复执行\nNEVER\n和 NOT_SUPPORTED 相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行\nNESTED\n表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务\n默认的 REQUIRED 已经满足绝大部分需求，SUPPORTS 和 REQUIRES_NEW 在少数情况下会用到，其他基本不会用到\n定义事务的传播级别\n1 2 3 4 @Transactional(propagation = Propagation.REQUIRES_NEW) public Product createProduct() { ... } Spring 使用 ThreadLocal 来传播事务，如果一个事务方法从 ThreadLocal 未取到事务，那么它会打开一个新的 JDBC 连接，同时开启一个新的事务，否则，它就直接使用从 ThreadLocal 获取的 JDBC 连接以及 TransactionStatus。因此事务能正确传播的前提是，方法调用是再一个线程内才行。\n使用 DAO 集成 Hibernate 集成 JPA 集成 MyBatis ","date":"2024-08-28T20:40:00+08:00","permalink":"https://example.com/p/spring%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Spring访问数据库"},{"content":"1 数据结构 1.1 算法复杂度 时间复杂度和空间复杂度\n大 O 复杂度表示法\n舍去低阶、常量、系数\n2 常见数据结构 2.2.1 数组： 存储方式：\n内存中连续的空间，存储相同的数据类型；\n增删改查：\n遍历：\n2.2.2 链表： 存储方式：\n内存中离散的结点，data（数据）和 next（下一个元素的地址）；\n增删改查：\n遍历：\n2.2.3 栈： 存储方式：\n满足先进后出的存储结构；\n入栈和出栈操作：\n2.2.4 队列： 满足先进先出的存储结构；\n入队和出队操作；\n2.2.5 散列表 理想的哈希表是不会产生冲突，即每一个元素的键（Key）都不相同的数组，但显然这种数据结构在计算机有限的空间下无法实现，注定产生哈希冲突；\n哈希冲突的解决方案决定了哈希表的具体数据结构：\n链地址\nJava 中采用的方案，将冲突的值将通过链表存储，并根据一定的规则将链表转换为红黑树（红黑树相对链表能显著优化查找速度）\n开放定址、再哈希法、公共溢出区\u0026hellip;\n衡量一个哈希算法的好坏主要参考该算法能否将数据均匀的映射到Key的取值范围中\n2.2.6 二叉树： data 域和 左右儿子的指针\n","date":"2024-08-28T20:02:00+08:00","permalink":"https://example.com/p/%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/","title":"集合八股文"},{"content":"AOP Aspect Oriented Programming，即面向切面编程\n何谓面向切面？我们对一个在 OOP 中的 BookService 的业务组件来考察，它应该会有几个业务方法：\ncreateBook updateBook deleteBook 那么，对于每个方法，我们都会需要设置安全检查、记录日志等等的公共逻辑，它们会重复的出现在各个业务方法中。在这些方法的某些代码段中就会出现重复的代码，加入把他们当作火腿肠一般并在一排，用刀切开就能够去考察这些切面了。\n对将这些切面如何正确的组装进火腿肠来说，有三种方法：\n在准备原料的时候就将它们按照顺序排列好，然后一次性注入进肠衣； 在将原料注入到肠衣的时候，按照需要的顺序先注入一种然后再切换到另外的； 业务逻辑这种原料先全部注入，然后按照需要切开再组装。 上述所言是在太过抽象，也或许并不贴且，但我们可以先有较为具体的例子，再去看对应到 Java 中 AOP 将切片织入到 BookService 的具体方案：\n编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ 就扩展了 Java 编译器，使用关键字 aspect 来实现织入； 类加载器：在目标类被装载到 JVM 时，通过一个特殊的类加载器，对目标类的字节码重新“增强”； 运行期：目标对象和切面都是普通 Java 类，通过 JVM 的动态代理功能或者第三方库实现运行期动态织入。 Spring 的 AOP 实现就是基于 JVM 的动态代理。\n由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。\n装配 AOP Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点 Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行 Pointcut：切入点，即一组连接点的集合 Advice：增强，指特定连接点上执行的动作 Introduction：引介，指为一个已有的Java对象动态的增加新的接口 Weaving：织入，指将切面整合到程序的执行流程中 Interceptor：拦截器，是一种实现增强的方式 Target Object：目标对象，即真正执行业务的核心逻辑对象 AOP Proxy：AOP 代理，是客户端持有的增强后的对象引用 要实现 AOP，我们先要引入 Spring 对 AOP 的支持：\norg.springframework:spring-aspects:6.0.0\n然后定义一个 Aspect：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Aspect @Component public class LoggingAspect { // 在执行 UserService 的每个方法前执行 @Before(\u0026#34;execution(public * com.gaj.demo01aop.service.UserService.*(..))\u0026#34;) public void doAccessCheck() { System.err.println(\u0026#34;[Before] do access check...\u0026#34;); } // 在执行 MailService 的每个方法前后执行 @Around(\u0026#34;execution(public * com.gaj.demo01aop.service.MailService.*(..))\u0026#34;) public Object doLogging(ProceedingJoinPoint pjp) throws Throwable { System.err.println(\u0026#34;[Around] start \u0026#34; + pjp.getSignature()); Object retval = pjp.proceed(); System.err.println(\u0026#34;[Around] done \u0026#34; + pjp.getSignature()); return retval; } } @Before 注解后面的字符串是告诉 AspectJ应该在何处执行该方法，这里写的意思是：执行 UserService 的每个 public 方法前执行 doAccessCheck() 代码。\n@Around 注解可以决定是否执行目标方法。\n同时还要给 @Configuration 类加上 @EnableAspectJAutoProxy 注解，这样 Spring 的 IoC容器就会自动查找带有 @Aspect 的 Bean，然后根据每个方法的 @Before、@Around 等注解把 AOP 注入到特定的 Bean 中。\n所以使用 AOP 的步骤如下：\n定义执行方法，并在方法上通过 AspectJ 的注解告诉 Spring 应该在何处调用此方法； 标记 @Component 和 @Aspect； 在 @Configuration 类上标注 @EnableAspectJAutoProxy。 拦截器类型：\n@Before\n先拦截代码，再执行目标代码。如果拦截器抛出异常，目标代码就不执行；\n@After\n先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；\n@AfterReturning\n和 @After 不同的是，只有当目标代码正常返回时，才执行拦截器代码；\n@AfterThrowing\n和 @After 不同的是，只有当目标代码正常抛出了异常时，才执行拦截器代码；\n@Around\n能完全控制目标代码是否执行，并且可以在执行前后、抛异常后执行任意拦截代码。\n使用注解装配 AOP 自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。\n以监控应用程序性能为例，先定义一个性能监控的注解：\n1 2 3 4 5 @Target(METHOD) @Retention(RUNTIME) public @interface MetricTime { String value(); } 在需要被监控的关键方法上标注该注解\n1 2 3 4 5 6 7 8 9 @Component public class UserService { // 监控register()方法性能: @MetricTime(\u0026#34;register\u0026#34;) public User register(String email, String password, String name) { ... } ... } 然后定义切片 MetricAspect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class MetricAspect { @Around(\u0026#34;@annotation(metricTime)\u0026#34;) public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable { String name = metricTime.value(); long start = System.currentTimeMillis(); try { return joinPoint.proceed(); } finally { long t = System.currentTimeMillis() - start; // 写入日志或发送至JMX: System.err.println(\u0026#34;[Metrics] \u0026#34; + name + \u0026#34;: \u0026#34; + t + \u0026#34;ms\u0026#34;); } } } @Around(\u0026quot;@annotation(metricTime)\u0026quot;) 表示符合条件的目标方法时带有 @MetricTime 注解的方法\nAOP 避坑 Spring 通过 CGLIB 动态创建的代理类生成的构造方法中，并未调用 super()，因此从成员变量并未初始化。Java 编译器虽然会默认在构造方法的第一行自动加 super()，但是， CGLIB 构造的代理类，是通过直接生成字节码，没有源码-编译-字节码的这个步骤，因此：\nSpring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！\n如何解决这个问题，需要在访问字段的代码，改成通过方法访问（用 getter 访问而不用 对象.字段直接访问字段），在代理实例中，因为代理类会覆写 getter 方法，并且将其委托给原始实例：\n1 2 3 4 5 6 7 8 public UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... // 原始实例 ... public ZoneId getZoneId() { return target.getZoneId(); // 委托给原始实例 } } 如果有方法是用 public + final 修饰的方法，\n1 2 3 4 5 6 7 @Component public class UserService { ... public final ZoneId getFinalZoneId() { return zoneId; } } 如果在MailService中，调用的不是getZoneId()，而是getFinalZoneId()，又会出现NullPointerException，这是因为，代理类无法覆写final方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的zoneId字段，即null。\n因此，正确使用AOP，我们需要一个避坑指南：\n访问被注入的Bean时，总是调用方法而非直接访问字段； 编写Bean时，如果可能会被代理，就不要编写public final方法。 这样才能保证有没有AOP，代码都能正常工作。\n","date":"2024-08-26T09:52:54+08:00","permalink":"https://example.com/p/aop/","title":"AOP"},{"content":"Cookie Cookie是另一种在Web应用中保持状态的机制，但与session不同的是，cookie存储在客户端，而不是服务器端。以下是cookie的详细介绍：\n1. Cookie的工作原理 存储位置: cookie存储在客户端的浏览器中，由浏览器管理。 传递机制: 每次客户端发送HTTP请求时，浏览器会自动将相关的cookie信息添加到请求头中发送给服务器。这些cookie可以包含各种数据，如用户ID、偏好设置等。 2. Cookie的创建和使用 设置Cookie:\n服务器通过HTTP响应头中的Set-Cookie指令来设置cookie。\n例如：\n1 2 3 Cookie cookie = new Cookie(\u0026#34;username\u0026#34;, \u0026#34;Alice\u0026#34;); cookie.setMaxAge(60 * 60); // 设置cookie的生命周期为1小时 response.addCookie(cookie); 这段代码在服务器响应时，告诉客户端保存一个名为\u0026quot;username\u0026quot;、值为\u0026quot;Alice\u0026quot;的cookie，并设定这个cookie的有效期为1小时。\n读取Cookie:\n服务器可以通过HttpServletRequest对象读取客户端发送的cookie。\n例如：\n1 2 3 4 5 6 7 8 9 Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie c : cookies) { if (\u0026#34;username\u0026#34;.equals(c.getName())) { String username = c.getValue(); // 使用username进行后续操作 } } } 这段代码获取客户端发送的所有cookie，并从中找到名为\u0026quot;username\u0026quot;的cookie，然后提取其值。\n3. Cookie与Session的区别 存储位置: Session存储在服务器端（内存、数据库、文件等）。 Cookie存储在客户端（浏览器）。 生命周期: Session的生命周期通常与客户端会话相关联，且可以配置为持久化或基于时间过期。 Cookie的生命周期由服务器通过Max-Age或Expires属性指定。如果不设置，cookie会在浏览器关闭后失效。 安全性: Session数据在服务器端保存，客户端无法直接访问或篡改，安全性较高。 Cookie数据保存在客户端，虽然可以设置为HttpOnly（仅供服务器读取）或Secure（仅在HTTPS下传输），但仍然容易受到客户端篡改或窃取的风险。 典型用途: Session通常用于存储用户的会话数据（如登录状态），在多个请求之间保持状态。 Cookie可以用于在客户端存储小型数据，如用户偏好、会话ID等。 4. Session与Cookie的关系 通常，session和cookie是一起使用的。为了在多个请求之间识别用户的session，服务器会创建一个session ID，并通过cookie发送给客户端。 每次客户端发送请求时，浏览器会将session ID的cookie返回给服务器，服务器通过这个session ID找到对应的session，从而维持会话状态。 总结 Cookie: 存储在客户端，由服务器通过Set-Cookie设置。每次请求时，浏览器会自动发送相关cookie。 Session: 存储在服务器端，用于管理与特定用户的会话状态。通常通过session ID来关联客户端和服务端的会话。 Cookie和session各有其用途，通常根据应用需求选择最适合的方式来管理用户状态。\n","date":"2024-08-25T08:52:54+08:00","image":"https://example.com/p/cookie/cookie_hu8143540753659831620.jpg","permalink":"https://example.com/p/cookie/","title":"Cookie"},{"content":"Filter \u0026amp; DispatcherServlet \u0026amp; Interceptor Filter 过滤器，它是 JavaEE 的 Servlet 规范提供的一种组件\n作用\n在 Http 请求到达 Servlet 之前，可以被一个或多个 Filter 预处理，主要是做的一些代码的公共逻辑。\n调用链\n多个 Filter 是具有调用链的存在的，每个请求都会被链上的 Filter 依次处理，需要在 web.xml 中配置它们的顺序。\nFilter 可以有针对性地拦截或者放行 HTTP 请求，如果在 Filter 内部直接发送重定向，且没有调用 chain.doFilter() ，后续的 Filter 就不会在处理这个请求了\nDispatcherServlet 它是 MVC 框架中用来接收所有请求的 Servlet，总是映射到 /\nDispatcherServlet 在接收到一个 Request 之后，会根据 Controller 的注解来决定调用哪个方法（需要先通过反射获取 Controller 的实例、get 或 post 方法、方法的参数类型、方法的参数名称），并获得方法返回的 ModelAndView ，或方法内部已经自行处理完毕，返回的就是 null\nView 使用来给模板引擎指定渲染的模板的，而 Model 是一个 Map\u0026lt;String, Object\u0026gt;，model 会由渲染引擎（如 Pebble 这类引擎）在生成模板的时候通过反射来获取数据\nInterceptor 拦截器，它是 Spring MVC 框架用于拦截 HTTP 请求的逻辑\n作用于请求到 controller 之前、controller 处理请求之后\n作用范围比 Filter 更小，更加精细\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/filter-dispatcherservlet-interceptor/","title":"Filter \u0026 DispatcherServlet \u0026 Interceptor"},{"content":"Session session用于指代服务器将数据存储在当前用户的会话中，这个session是由服务端保存的，具体来说，它是一个HttpSession类，我们在获取的时候是由HttpServletRequest.getSession()这样获取到当前用户的session，通过唯一表示符JSESSIONID在服务端区分。\n客户端只会保存JSESSIONID，服务端通过这个id查找到对应的session。\n服务端通过setAttribute()和getAttribute()来读或写session存储的属性及其值\n但是，HttpServletRequest在响应完请求后就会销毁，说明这个Session不是由HttpServletRequest，而是由tomcat的相关组件来处理的：\norg.apache.catalina.session.StandardSession:\nStandardSession是Tomcat中表示会话的类。每个会话对象都由这个类的一个实例表示，StandardSession对象包含了会话的所有数据，包括会话ID、会话属性（如user、name）、创建时间、最后访问时间等。 org.apache.catalina.session.StandardManager:\nStandardManager是Tomcat的默认会话管理器，它负责创建、查找、删除和持久化StandardSession对象。 当你通过HttpServletRequest.getSession()获取会话时，Tomcat实际上是通过StandardManager查找或创建一个StandardSession对象。 org.apache.catalina.Context:\nContext对象代表一个Web应用的上下文。在每个Context对象中，有一个Manager（即StandardManager）实例来管理该上下文的所有会话。 工作流程概述 创建会话: 当客户端第一次请求并调用HttpServletRequest.getSession()时，如果没有现有的会话，Tomcat会通过StandardManager创建一个新的StandardSession对象并返回。 这个新创建的会话对象会被StandardManager保存，以便在后续请求中使用。 管理会话生命周期: StandardManager会定期检查会话是否过期，并销毁过期的会话。 如果应用程序或服务器设置了持久化配置，StandardManager还可以将会话数据序列化到文件系统中，以便在服务器重启后恢复。 会话存储: 默认情况下，session数据存储在Tomcat服务器的内存中。StandardManager会持有所有活动会话的引用，并在Tomcat运行期间负责管理它们。 会话在Tomcat中的持有者 因此，在Tomcat中，HttpSession对象是由StandardSession类表示的，而这些会话对象由StandardManager持有和管理。即使HttpServletRequest对象被销毁，StandardSession对象依然存在于StandardManager中，直到会话超时或被显式销毁。\n如果Tomcat重启，默认情况下，保存在内存中的session会消失。这意味着如果没有特殊配置，当Tomcat重新启动时，所有活跃的session数据都会丢失，用户会话将被中断，用户需要重新登录或重新建立会话。\n持久化会话数据的方法 为了在Tomcat重启后保留session数据，可以使用以下方法：\n启用session持久化:\nTomcat提供了会话持久化的功能，可以将session数据序列化到磁盘上，并在服务器重启时重新加载。 这通过StandardManager的持久化机制来实现。你可以在\u0026lt;Context\u0026gt;配置中启用session持久化。 示例配置（在conf/context.xml或Web应用的META-INF/context.xml中）：\n1 \u0026lt;Manager pathname=\u0026#34;session.ser\u0026#34;/\u0026gt; 这里的pathname属性指定了会话数据文件的路径。如果不指定路径，Tomcat将默认保存会话数据到work目录下的session.ser文件中。 使用外部持久化存储:\n可以将session数据存储在外部数据库、Redis、Memcached等持久化存储中。通过这种方式，即使Tomcat重启，会话数据也能持久存在。 这需要自定义Manager类或者使用第三方的解决方案，例如使用RedisSessionManager来将session数据保存在Redis中。 总结 默认情况下，Tomcat重启后，session数据会丢失，因为它们存储在内存中。\n启用持久化 或 使用 外部存储 是保留session数据的两种常见方法。如果需要在重启后保持会话，建议配置持久化或者使用外部存储机制。\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/session/","title":"Session"},{"content":"测试文章 测试内容\n测试 toc 自动生成目录1 测试 toc 自动生成多级目录（二级目录） 测试 toc 自动生成多级目录（三级目录） 多级目录最多三层\n测试 toc 自动生成目录2 下面是图片↓↓↓↓↓↓↓↓↓↓↓↓\n上面是图片↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n图片中间不能有空格\n测试图片上传方案 测试代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* 读取配置文件 使用 @PropertySource(\u0026#34;app.properties\u0026#34;) 自动读取配置文件，Spring 容器看到这个注解后，自动读取这个配置文件 */ @Configuration @ComponentScan @PropertySource(\u0026#34;app.properties\u0026#34;) // 表示读取 classpath 的 app.properties @PropertySource(\u0026#34;smtp.properties\u0026#34;) public class AppConfig { @SuppressWarnings(\u0026#34;resource\u0026#34;) public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); UserService userService = context.getBean(UserService.class); userService.login(\u0026#34;bob@example.com\u0026#34;, \u0026#34;password\u0026#34;); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;ada\u0026#34;, 2); map.put(\u0026#34;awui\u0026#34;, 1); map.put(\u0026#34;dawcf\u0026#34;, 3); map.put(\u0026#34;afafds\u0026#34;, 4); for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + entry.getValue()); } } /* 注入的字符串语法 1.\u0026#34;${app.zone}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，启动将报错 2.\u0026#34;${app.zone:Z}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，就用使用默认值 */ @Bean ZoneId createZoneId(@Value(\u0026#34;${app.zone:Z}\u0026#34;) String zoneId) { return ZoneId.of(zoneId); } } ","date":"2023-08-24T09:52:54+08:00","image":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87_hu6886787404485992962.png","permalink":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","title":"测试文章"}]